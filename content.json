[{"title":"中文 Linear Algebra （线性代数） 笔记","date":"2018-04-28T15:31:00.000Z","path":"2018/04/28/math/","text":"中文 Linear Algebra （线性代数） 笔记Overview （概述）Most of the content comes from the web.大部分内容来自网络。 I know my knowledge of linear algebra is not very thorough, so I re-learn linear algebra, record the corresponding notes.由于我们对线性代数的知识了解不深，特意重新学习一次线代，记录下相应笔记。 课程顺序是按照麻省理工公开课的 Linear Algebra 记录的学习笔记。 Contents （目录） 01. 方程组的几何解释 01.01 方程组的几何解释 02. 矩阵消元 02.01 矩阵消元 03. 乘法和逆矩阵 03.01 矩阵乘法和逆矩阵 04. A的LU分解 04.01 A的LU分解 05. 转置-置换-向量空间R 05.01 矩阵转置 05.02 置换 05.03 向量空间 R 06. 列空间和零空间 06.01 列空间 06.02 零空间 07. 求解Ax=0:主变量,特解 07.01 主变量 07.02 特解 08. 求解Ax=b:可解性和解的结构 08.01 可解性 08.02 解的结构 09. 线性相关性、基、维数 09.01 线性相关性 09.02 基 09.03 维数 10. 四个基本子空间 10.01 基本子空间 10.02 四个基本子空间 11. 矩阵空间、秩1矩阵和小世界图 11.01 矩阵空间 11.02 秩1矩阵 11.03 小世界图 12. 图和网络 12.01 图 12.02 网络 13. 复习一 13.01 复习一 14. 正交向量与子空间 14.01 正交向量 14.02 子空间 15. 子空间投影 15.01 子空间投影 16. 投影矩阵和最小二乘 16.01 投影矩阵 16.02 最小二乘 17. 正交矩阵和Gram-Schmidt正交化 17.01 正交矩阵 17.02 Gram-Schmidt正交化 18. 行列式及其性质 18.01 行列式 18.02 行列式性质 19. 行列式公式和代数余子式 19.01 行列式公式 19.02 代数余子式 20. 克拉默法则、逆矩阵、体积 20.01 克拉默法则 20.02 逆矩阵 20.03 体积 21. 特征值和特征向量 21.01 特征值和特征向量 22. 对角化和A的幂 22.01 对角化 22.02 A的幂 23. 微分方程和exp(At) 23.01 微分方程 23.02 exp(AT) 24. 马尔可夫矩阵;傅立叶级数 24.01 马尔可夫矩阵 24.02 傅立叶级数 25. 复习二 25.01 复习二 26. 对称矩阵及正定性 26.01 对称矩阵 26.02 正定性 27. 复数矩阵和快速傅里叶变换 27.01 复数矩阵 27.02 快速傅里叶变换 28. 正定矩阵和最小值 28.01 正定矩阵 28.02 最小值 29. 相似矩阵和若尔当形 29.01 相似矩阵 29.02 若尔当形 30. 奇异值分解 30.01 奇异值分解 31. 线性变换及对应矩阵 31.01 线性变换 31.02 对应矩阵 32. 基变换和图像压缩 32.01 基变换 32.02 图像压缩 33. 复习三 33.01 复习三 34. 左右逆和伪逆 34.01 左右逆 34.02 伪逆 35. 期末复习 35.01 期末复习 对应课程","tags":[{"name":"线性代数","slug":"线性代数","permalink":"http://blog.buerya.cn/tags/线性代数/"}]},{"title":"智能合约语言 Solidity 教程系列10 - 完全理解函数修改器","date":"2018-04-08T16:00:00.000Z","path":"2018/04/09/solidity-modify/","text":"智能合约语言 Solidity 教程系列10 - 完全理解函数修改器Solidity 系列完整的文章列表请查看分类-Solidity。 写在前面Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。 函数修改器(Function Modifiers)函数修改器(Modifiers)可以用来改变一个函数的行为。比如用于在函数执行前检查某种前置条件。 如果熟悉Python的同学，会发现函数修改器的作用和Python的装饰器很相似。 修改器是一种可被继承合约属性，同时还可被继承的合约重写(override)。下面我们来看一段示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546pragma solidity ^0.4.11;contract owned &#123; function owned() public &#123; owner = msg.sender; &#125; address owner; // 定义了一个函数修改器，可被继承 // 修饰时，函数体被插入到 “_;” 处 // 不符合条件时，将抛出异常 modifier onlyOwner &#123; require(msg.sender == owner); _; &#125;&#125;contract mortal is owned &#123; // 使用继承的`onlyOwner` function close() public onlyOwner &#123; selfdestruct(owner); &#125;&#125;contract priced &#123; // 函数修改器可接收参数 modifier costs(uint price) &#123; if (msg.value &gt;= price) &#123; _; &#125; &#125;&#125;contract Register is priced, owned &#123; mapping (address =&gt; bool) registeredAddresses; uint price; function Register(uint initialPrice) public &#123; price = initialPrice; &#125; // 需要提供payable 以接受以太 function register() public payable costs(price) &#123; registeredAddresses[msg.sender] = true; &#125; function changePrice(uint _price) public onlyOwner &#123; price = _price; &#125;&#125; 上面onlyOwner就是定义的一个函数修改器，当用这个修改器区修饰一个函数时，则函数必须满足onlyOwner的条件才能运行，这里的条件是：必须是合约的创建这才能调用函数，否则抛出异常。我们在实现一个可管理、增发、兑换、冻结等高级功能的代币文章中就使用了这个函数修改器。 多个修改器如果同一个函数有多个修改器，他们之间以空格隔开，修饰器会依次检查执行。 在修改器中或函数内的显式的return语句，仅仅跳出当前的修改器或函数。返回的变量会被赋值，但执行流会在前一个修改器后面定义的”_”后继续执行， 如： 12345678910111213141516contract Mutex &#123; bool locked; modifier noReentrancy() &#123; require(!locked); locked = true; _; locked = false; &#125; // 防止递归调用 // return 7 之后，locked = false 依然会执行 function f() public noReentrancy returns (uint) &#123; require(msg.sender.call()); return 7; &#125;&#125; 修改器的参数可以是任意表达式。在此上下文中，所有的函数中引入的符号，在修改器中均可见。但修改器中引入的符号在函数中不可见，因为它们有可能被重写。 深入理解修改器的执行次序再来看一个复杂一点的例子，来深入理解修改器： 12345678910111213141516171819202122232425262728293031323334pragma solidity ^0.4.11;contract modifysample &#123; uint a = 10; modifier mf1 (uint b) &#123; uint c = b; _; c = a; a = 11; &#125; modifier mf2 () &#123; uint c = a; _; &#125; modifier mf3() &#123; a = 12; return ; _; a = 13; &#125; function test1() mf1(a) mf2 mf3 public &#123; a = 1; &#125; function test2() public constant returns (uint) &#123; return a; &#125; &#125; 上面的智能合约运行test1()之后，状态变量a的值是多少， 是1， 11， 12，还是13呢？答案是 11, 大家可以运行下test2获取下a值。 我们来分析一下 test1， 它扩展之后是这样的： 12345678uint c = b; uint c = a; a = 12; return ; _; a = 13;c = a;a = 11; 这个时候就一目了然了，最后a 为11， 注意第5及第6行是不是执行的。 参考文献官方文档-Function Modifiers ``","tags":[{"name":"Solidity手册","slug":"Solidity手册","permalink":"http://blog.buerya.cn/tags/Solidity手册/"}]},{"title":"智能合约语言 Solidity 教程系列9 - 错误处理","date":"2018-04-08T07:58:00.000Z","path":"2018/04/08/solidity-errorhandler/","text":"智能合约语言 Solidity 教程系列9 - 错误处理这是Solidity教程系列文章第9篇介绍Solidity 错误处理。Solidity 系列完整的文章列表请查看分类-Solidity。 写在前面Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。 什么是错误处理错误处理是指在程序发生错误时的处理方式，Solidity处理错误和我们常见的语言不一样，Solidity是通过回退状态的方式来处理错误。发生异常时会撤消当前调用（及其所有子调用）所改变的状态，同时给调用者返回一个错误标识。注意捕捉异常是不可能的 ，因此没有try … catch…。 为什么Solidity处理错误要这样设计呢？我们可以把区块链理解为是全球共享的分布式事务性数据库。全球共享 意味着参与这个网络的每一个人都可以读写其中的记录。如果想修改这个数据库中的内容，就必须创建一个事务，事务 意味着要做的修改（假如我们想同时修改两个值）只能被完全的应用或者一点都没有进行。学习过数据库的同学，应该理解事务的含义，如果你对事务一词不是很理解，建议你搜索一下“数据库事务“。Solidity错误处理就是要保证每次调用都是事务性的。 如何处理Solidity提供了两个函数assert和require来进行条件检查，如果条件不满足则抛出异常。assert函数通常用来检查（测试）内部错误，而require函数来检查输入变量或合同状态变量是否满足条件以及验证调用外部合约返回值。另外，如果我们正确使用assert，有一个Solidity分析工具就可以帮我们分析出智能合约中的错误，帮助我们发现合约中有逻辑错误的bug。 除了可以两个函数assert和require来进行条件检查，另外还有两种方式来触发异常： revert函数可以用来标记错误并回退当前调用 使用throw关键字抛出异常（从0.4.13版本，throw关键字已被弃用，将来会被淘汰。） 当子调用中发生异常时，异常会自动向上“冒泡”。 不过也有一些例外：send，和底层的函数调用call, delegatecall，callcode，当发生异常时，这些函数返回false。 注意：在一个不存在的地址上调用底层的函数call，delegatecall，callcode 也会返回成功，所以我们在进行调用时，应该总是优先进行函数存在性检查。 在下面通过一个示例来说明如何使用require来检查输入条件，以及assert用于内部错误检查： 1234567891011pragma solidity ^0.4.0;contract Sharer &#123; function sendHalf(address addr) public payable returns (uint balance) &#123; require(msg.value % 2 == 0); // 仅允许偶数 uint balanceBeforeTransfer = this.balance; addr.transfer(msg.value / 2); // 如果失败，会抛出异常，下面的代码就不是执行 assert(this.balance == balanceBeforeTransfer - msg.value / 2); return this.balance; &#125;&#125; 我们实际运行下，看看异常是如何发生的： 首先打开Remix，贴入代码，点击创建合约。如下图： 运行测试1：附加1wei (奇数)去调用sendHalf，这时会发生异常，如下图: 运行测试2：附加2wei 去调用sendHalf，运行正常。 运行测试3：附加2wei以及sendHalf参数为当前合约本身，在转账是发生异常，因为合约无法接收转账，错误提示上图类似。 assert类型异常在下述场景中自动产生assert类型的异常: 如果越界，或负的序号值访问数组，如i &gt;= x.length 或 i &lt; 0时访问x[i] 如果序号越界，或负的序号值时访问一个定长的bytesN。 被除数为0， 如5/0 或 23 % 0。 对一个二进制移动一个负的值。如:5&lt;&lt;i; i为-1时。 整数进行可以显式转换为枚举时，如果将过大值，负值转为枚举类型则抛出异常 如果调用未初始化内部函数类型的变量。 如果调用assert的参数为false require类型异常在下述场景中自动产生require类型的异常: 调用throw 如果调用require 的参数为false 如果你通过消息调用一个函数，但在调用的过程中，并没有正确结束(gas不足，没有匹配到对应的函数，或被调用的函数出现异常)。底层操作如call,send,delegatecall或callcode除外，它们不会抛出异常，但它们会通过返回false来表示失败。 如果在使用new创建一个新合约时出现第3条的原因没有正常完成。 如果调用外部函数调用时，被调用的对象不包含代码。 如果合约没有payable修饰符的public的函数在接收以太币时（包括构造函数，和回退函数）。 如果合约通过一个public的getter函数（public getter funciton）接收以太币。 如果.transfer() 执行失败 当发生require类型的异常时，Solidity会执行一个回退操作（指令0xfd）。当发生assert类型的异常时，Solidity会执行一个无效操作（指令0xfe）。在上述的两种情况下，EVM都会撤回所有的状态改变。是因为期望的结果没有发生，就没法继续安全执行。必须保证交易的原子性（一致性，要么全部执行，要么一点改变都没有，不能只改变一部分），所以需要撤销所有操作，让整个交易没有任何影响。 注意assert类型的异常会消耗掉所有的gas, 而require从大都会版本（Metropolis， 即目前主网所在的版本）起不会消耗gas。 参考文献 Solidity错误处理","tags":[{"name":"Solidity手册","slug":"Solidity手册","permalink":"http://blog.buerya.cn/tags/Solidity手册/"}]},{"title":"剖析非同质化代币ERC721-全面解析ERC721标准","date":"2018-03-23T04:02:22.000Z","path":"2018/03/23/token-erc721/","text":"什么是ERC-721？现在我们看到的各种加密猫猫狗狗都是基于ERC-721创造出来的，每只都是一个独一无二的ERC-721代币，不过ERC-721在区块链世界远不止猫猫狗狗，它更大的想象空间在于将物理世界的资产映射到区块链上。本文就来剖析下什么是ERC721. ERC721是什么在创建代币一篇，我们讲到过ERC20代币，和ERC20一样，ERC721同样是一个代币标准，ERC721官方简要解释是Non-Fungible Tokens，简写为NFTs，多翻译为非同质代币。 ERC721 是由Dieter Shirley 在2017年9月提出。Dieter Shirley 正是谜恋猫CryptoKitties背后的公司Axiom Zen的技术总监。因此谜恋猫也是第一个实现了ERC721 标准的去中心化应用。ERC721号提议已经被以太坊作为标准接受，但该标准仍处于草稿阶段。本文介绍的ERC721标准基于最新(2018/03/23官方提议。 那怎么理解非同质 代币呢? 非同质代表独一无二，谜恋猫为例，每只猫都被赋予拥有基因，是独一无二的（一只猫就是一个NFTs），猫之间是不能置换的。这种独特性使得某些稀有猫具有收藏价值，也因此受到追捧。 ERC20代币是可置换的，且可细分为N份（1 = 10 * 0.1）, 而ERC721的Token最小的单位为1，无法再分割。 如果同一个集合的两个物品具有不同的特征，这两个物品是非同质的，而同质是某个部分或数量可以被另一个同等部分或数量所代替。 非同质性其实广泛存在于我们的生活中，如图书馆的每一本，宠物商店的每一只宠物，歌手所演唱的歌曲，花店里不同的花等等，因此ERC721合约必定有广泛的应用场景。通过这样一个标准，也可建立跨功能的NFTs管理和销售平台（就像有支持ERC20的交易所和钱包一样），使生态更加强大。 ERC721标准ERC721最为一个合约标准，提供了在实现ERC721代币时必须要遵守的协议，要求每个ERC721标准合约需要实现ERC721及ERC165接口，接口定义如下： 1234567891011121314151617181920pragma solidity ^0.4.20;interface ERC721 /* is ERC165 */ &#123; event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); function balanceOf(address _owner) external view returns (uint256); function ownerOf(uint256 _tokenId) external view returns (address); function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable; function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable; function transferFrom(address _from, address _to, uint256 _tokenId) external payable; function approve(address _approved, uint256 _tokenId) external payable; function setApprovalForAll(address _operator, bool _approved) external; function getApproved(uint256 _tokenId) external view returns (address); function isApprovedForAll(address _owner, address _operator) external view returns (bool);&#125; 接口说明： balanceOf(): 返回由_owner 持有的NFTs的数量。 ownerOf(): 返回tokenId代币持有者的地址。 approve(): 授予地址_to具有_tokenId的控制权，方法成功后需触发Approval 事件。 setApprovalForAll(): 授予地址_operator具有所有NFTs的控制权，成功后需触发ApprovalForAll事件。 getApproved()、isApprovedForAll(): 用来查询授权。 safeTransferFrom(): 转移NFT所有权，一次成功的转移操作必须发起 Transer 事件。函数的实现需要做一下几种检查： 调用者msg.sender应该是当前tokenId的所有者或被授权的地址 _from 必须是 _tokenId的所有者 _tokenId 应该是当前合约正在监测的NFTs 中的任何一个 _to 地址不应该为 0 如果_to 是一个合约应该调用其onERC721Received方法, 并且检查其返回值，如果返回值不为bytes4(keccak256(&quot;onERC721Received(address,uint256,bytes)&quot;))抛出异常。 一个可接收NFT的合约必须实现ERC721TokenReceiver接口： 1234interface ERC721TokenReceiver &#123;/// @return `bytes4(keccak256(&quot;onERC721Received(address,uint256,bytes)&quot;))` function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);&#125; transferFrom(): 用来转移NFTs, 方法成功后需触发Transfer事件。调用者自己确认_to地址能正常接收NFT，否则将丢失此NFT。此函数实现时需要检查上面条件的前4条。 ERC165标准ERC721标准同时要求必须符合ERC165标准 ，其接口如下： 123interface ERC165 &#123; function supportsInterface(bytes4 interfaceID) external view returns (bool);&#125; ERC165同样是一个合约标准，这个标准要求合约提供其实现了哪些接口，这样再与合约进行交互的时候可以先调用此接口进行查询。interfaceID为函数选择器，计算方式有两种，如：bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;));或ERC165.supportsInterface.selector，多个函数的接口ID为函数选择器的异或值。关于ERC165，这里不深入介绍，有兴趣的同学可以阅读官方提案。 可选实现接口：ERC721MetadataERC721Metadata 接口用于提供合约的元数据：name , symbol 及 URI（NFT所对应的资源）。其接口定义如下： 12345interface ERC721Metadata /* is ERC721 */ &#123; function name() external pure returns (string _name); function symbol() external pure returns (string _symbol); function tokenURI(uint256 _tokenId) external view returns (string);&#125; 接口说明: name(): 返回合约的名字，尽管是可选，但强烈建议实现，即便是返回空字符串。 symbol(): 返回合约代币符号，尽管是可选，但强烈建议实现，即便是返回空字符串。 tokenURI(): 返回_tokenId所对应的外部资源文件的URI(通常是IPFS或HTTP(S)路径)。外部资源文件需要包含名字、描述、图片，其格式的要求如下： 123456789101112131415161718&#123;\"title\": \"Asset Metadata\",\"type\": \"object\",\"properties\": &#123; \"name\": &#123; \"type\": \"string\", \"description\": \"Identifies the asset to which this NFT represents\", &#125;, \"description\": &#123; \"type\": \"string\", \"description\": \"Describes the asset to which this NFT represents\", &#125;, \"image\": &#123; \"type\": \"string\", \"description\": \"A URI pointing to a resource with mime type image/* representing the asset to which this NFT represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.\", &#125; &#125;&#125; tokenURI通常是被web3调用，以便在应用层做相应的查询和展示。 可选实现接口：ERC721EnumerableERC721Enumerable的主要目的是提高合约中NTF的可访问性，其接口定义如下： 12345interface ERC721Enumerable /* is ERC721 */ &#123; function totalSupply() external view returns (uint256); function tokenByIndex(uint256 _index) external view returns (uint256); function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);&#125; 接口说明: totalSupply(): 返回NFT总量 tokenByIndex(): 通过索引返回对应的tokenId。 tokenOfOwnerByIndex(): 所有者可以一次拥有多个的NFT, 此函数返回_owner拥有的NFT列表中对应索引的tokenId。 补充说明NTF IDsNTF ID，即tokenId，在合约中用唯一的uint265进行标识，每个NFT的ID在智能合约的生命周期内不允许改变。推荐的实现方式有： 从0开始，每新加一个NFT，NTF ID加1 使用sha3后uuid转换为NTF ID 与ERC-20的兼容性ERC721标准尽可能遵循 ERC-20 的语义，但由于同质代币与非同质代币之间的根本差异，并不能完全兼容ERC-20。 交易、挖矿、销毁在实现transter相关接口时除了满足上面的的条件外，我们可以根据需要添加自己的逻辑，如加入黑名单等。同时挖矿、销毁尽管不是标准的一部分，我们可以根据需要实现。 参考文献 EIPS-165 EIPS-721","tags":[{"name":"智能合约","slug":"智能合约","permalink":"http://blog.buerya.cn/tags/智能合约/"},{"name":"Token","slug":"Token","permalink":"http://blog.buerya.cn/tags/Token/"},{"name":"ERC721","slug":"ERC721","permalink":"http://blog.buerya.cn/tags/ERC721/"}]},{"title":"如何搭建以太坊私有链","date":"2018-03-17T16:00:00.000Z","path":"2018/03/18/create_private_blockchain/","text":"在开发以太坊时，很多时候需要搭建一条以太坊私有链，通过本文一起看看如何在Mac上进行搭建。 写在前面阅读本文前，你应该对以太坊语言有所了解，如果你还不了解，建议你先看以太坊是什么 go-ethereum客户端安装Go-ethereum客户端通常被称为Geth，它是个命令行界面，执行在Go上实现的完整以太坊节点。Geth得益于Go语言的多平台特性，支持在多个平台上使用(比如Windows、Linux、Mac)。Geth是以太坊协议的具体落地实现，通过Geth，你可以实现以太坊的各种功能，如账户的新建编辑删除，开启挖矿，ether币的转移，智能合约的部署和执行等等。所以，我们选择geth工具来进行开发。由于本人是mac，所以优先使用mac进行开发啦。mac中geth安装如下： 12brew tap ethereum/ethereumbrew install ethereum 检查是否安装成功 1geth --help 如果输出一些帮助提示命令，则说明安装成功。其他平台可参考Geth 安装 搭建私有链以太坊支持自定义创世区块，要运行私有链，我们就需要定义自己的创世区块，创世区块信息写在一个json格式的配置文件中。首先将下面的内容保存到一个json文件中，例如genesis.json。json文件内容如下: 1234567891011121314151617&#123; \"config\": &#123; \"chainId\": 10, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 &#125;, \"alloc\" : &#123;&#125;, \"coinbase\" : \"0x0000000000000000000000000000000000000000\", \"difficulty\" : \"0x20000\", \"extraData\" : \"\", \"gasLimit\" : \"0x2fefd8\", \"nonce\" : \"0x0000000000000042\", \"mixhash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"timestamp\" : \"0x00\"&#125; 初始化:写入创世区块准备好创世区块json配置文件后，需要初始化区块链，将上面的创世区块信息写入到区块链中。首先要新建一个目录data0用来存放区块链数据(其实，这个目录data0就相当于一个根节点。当我们基于genesis.json生成根节点后，其他人就可以来连接此根节点，从而能进行交易)。data0目录结构如图所示： 接下来进入privatechain目录中，执行初始化命令： 12cd privatechaingeth --datadir data0 init genesis.json 上面的命令的主体是 geth init，表示初始化区块链，命令可以带有选项和参数，其中–datadir选项后面跟一个目录名，这里为 data0，表示指定数据存放目录为 data0， genesis.json是init命令的参数。 运行上面的命令，会读取genesis.json文件，根据其中的内容，将创世区块写入到区块链中。如果看到log信息中含有Successfully wrote genesis state 字样，说明初始化成功。 初始化成功后的目录如下： 其中geth/chaindata中存放的是区块数据，keystore中存放的是账户数据。 启动私有链节点初始化完成后，就有了一条自己的私有链，之后就可以启动自己的私有链节点并做一些操作，在终端中输入以下命令即可启动节点： 1geth --datadir data0 --networkid 1108 console 上面命令的主体是geth console，表示启动节点并进入交互式控制台，–datadir选项指定使用data0作为数据目录，–networkid选项后面跟一个数字，这里是1108，表示指定这个私有链的网络id为1108。网络id在连接到其他节点的时候会用到，以太坊公网的网络id是1，为了不与公有链网络冲突，运行私有链节点的时候要指定自己的网络id(上面命令可能会运行失败，我直接重启mac，再进入到privateChain目录中，简单粗暴)。 运行上面的命令后，就启动了区块链节点并进入了Javascript Console： 这是一个交互式的Javascript执行环境，在这里面可以执行Javascript代码，其中&gt;是命令提示符。在这个环境里也内置了一些用来操作以太坊的Javascript对象，可以直接使用这些对象。这些对象主要包括： eth ：包含一些跟操作区块链相关的方法net ：包含以下查看p2p网络状态的方法admin ：包含一些与管理节点相关的方法miner ：包含启动&amp;停止挖矿的一些方法personal ：主要包含一些管理账户的方法txpool ：包含一些查看交易内存池的方法web3 ：包含了以上对象，还包含一些单位换算的方法 玩转Javascript Console进入以太坊Javascript Console后，就可以使用里面的内置对象做一些操作，这些内置对象提供的功能很丰富，比如查看区块和交易、创建账户、挖矿、发送交易、部署智能合约等。接下来介绍几个常用功能，下面的操作中，前面带&gt;的表示在Javascript Console中执行的命令。 创建账户前面只是搭建了私有链，并没有自己的账户，可以在js console中输入eth.accounts来验证： 12&gt; eth.accounts[] 此时没有账户，接下来使用personal对象来创建一个账户： 1234&gt; personal.newAccount()&gt; Passphrase:&gt; Repeat passphrase:&quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot; Passphrase其实就是密码的意思，输入两次密码后，就创建了一个账户。再次执行命令: 1234&gt; personal.newAccount()&gt; Passphrase:&gt; Repeat passphrase:&quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot; 这时候再去看账户，就有两个了。 12&gt; eth.accounts[&quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;, &quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot;] 账户默认会保存在数据目录的keystore文件夹中。查看目录结构，发现data0/keystore中多了两个文件，这两个文件就对应刚才创建的两个账户，这是json格式的文本文件，可以打开查看，里面存的是私钥经过密码加密后的信息。 json文件中信息格式如下： 123456789101112131415161718192021&#123; \"address\": \"4a3b0216e1644c1bbabda527a6da7fc5d178b58f\", \"crypto\": &#123; \"cipher\": \"aes-128-ctr\", \"ciphertext\": \"238d6d48126b762c8f13e84622b1bbb7713f7244c2f24555c99b76396fae8355\", \"cipherparams\": &#123; \"iv\": \"d0f5a3d3e6c1eeec77bf631bc938725d\" &#125;, \"kdf\": \"scrypt\", \"kdfparams\": &#123; \"dklen\": 32, \"n\": 262144, \"p\": 1, \"r\": 8, \"salt\": \"70dc72c4eb63bea50f7637d9ff85bb53f6ca8ace17f4245feae9c0bc9abaad82\" &#125;, \"mac\": \"bd7fc0c937c39f1cbbf1ca654c33b53d7f9c644c6dacfeefe1641d2f3decea04\" &#125;, \"id\": \"57803d82-0cd4-4a78-9c29-9f9252fdcf60\", \"version\": 3&#125; 查看账户余额eth对象提供了查看账户余额的方法： 1234&gt; eth.getBalance(eth.accounts[0])0&gt; eth.getBalance(eth.accounts[1])0 目前两个账户的以太币余额都是0，要使账户有余额，可以从其他账户转账过来，或者通过挖矿来获得以太币奖励。 启动＆停止挖矿通过miner.start()来启动挖矿： 1&gt; miner.start(10) 其中start的参数表示挖矿使用的线程数。第一次启动挖矿会先生成挖矿所需的DAG文件，这个过程有点慢，等进度达到100%后，就会开始挖矿，此时屏幕会被挖矿信息刷屏。 如果想停止挖矿，并且进度已经达到100%之后，可以在js console中输入 1miner.stop()： 注意：输入的字符会被挖矿刷屏信息冲掉，没有关系，只要输入完整的miner.stop()之后回车，即可停止挖矿。 挖到一个区块会奖励5个以太币，挖矿所得的奖励会进入矿工的账户，这个账户叫做coinbase，默认情况下coinbase是本地账户中的第一个账户： 12&gt; eth.coinbase&quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot; 现在的coinbase是账户0，要想使挖矿奖励进入其他账户，通过miner.setEtherbase()将其他账户设置成coinbase即可： 1234&gt; miner.setEtherbase(eth.accounts[1])true&gt; eth.coinbase&quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot; 挖到区块以后，账户0里面应该就有余额了： 12&gt; eth.getBalance(eth.accounts[0])2.31e+21 getBalance()返回值的单位是wei，wei是以太币的最小单位，1个以太币=10的18次方个wei。要查看有多少个以太币，可以用web3.fromWei()将返回值换算成以太币： 12&gt; web3.fromWei(eth.getBalance(eth.accounts[0]),&apos;ether&apos;)2310 发送交易截止目前，账户一的余额还是0： 12&gt; eth.getBalance(eth.accounts[1])0 可以通过发送一笔交易，从账户0转移10个以太币到账户1： 12345678&gt; amount = web3.toWei(10,&apos;ether&apos;)&quot;10000000000000000000&quot;&gt; eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amount&#125;)Error: authentication needed: password or unlock at web3.js:3143:20 at web3.js:6347:15 at web3.js:5081:36 at &lt;anonymous&gt;:1:1 这里报错了，原因是账户每隔一段时间就会被锁住，要发送交易，必须先解锁账户，由于我们要从账户0发送交易，所以要解锁账户0： 1234&gt; personal.unlockAccount(eth.accounts[0])Unlock account 0x4a3b0216e1644c1bbabda527a6da7fc5d178b58fPassphrase:true 输入创建账户时设置的密码，就可以成功解锁账户。然后再发送交易： 12345&gt; amount = web3.toWei(10,&apos;ether&apos;)&quot;10000000000000000000&quot;&gt; eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:amount&#125;)INFO [03-07|11:13:11] Submitted transaction fullhash=0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6 recipient=0x46B24d04105551498587e3C6CE2c3341d5988938&quot;0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6&quot; 我们去查看账户1中的余额： 12&gt; eth.getBalance(eth.accounts[1])0 发现还没转过去，此时交易已经提交到区块链，但还未被处理，这可以通过查看txpool来验证： 12345&gt; txpool.status&#123; pending: 1, queued: 0&#125; 其中有一条pending的交易，pending表示已提交但还未被处理的交易。 要使交易被处理，必须要挖矿。这里我们启动挖矿，然后等待挖到一个区块之后就停止挖矿： 1&gt; miner.start(1);admin.sleepBlocks(1);miner.stop(); 当miner.stop()返回true后，txpool中pending的交易数量应该为0了，说明交易已经被处理了，而账户1应该收到币了： 12&gt; web3.fromWei(eth.getBalance(eth.accounts[1]),&apos;ether&apos;)10 查看交易和区块eth对象封装了查看交易和区块信息的方法。 查看当前区块总数： 12&gt; eth.blockNumber463 通过区块号查看区块： 1234567891011121314151617181920212223&gt; eth.getBlock(66)&#123; difficulty: 135266, extraData: &quot;0xd783010802846765746886676f312e31308664617277696e&quot;, gasLimit: 3350537, gasUsed: 0, hash: &quot;0x265dfcc0649bf6240812256b2b9b4e3ae48d51fd8e43e25329ac111556eacdc8&quot;, logsBloom: &quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;, miner: &quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;, mixHash: &quot;0xaf755722f62cac9b483d3437dbc795f2d3a02e28ec03d39d8ecbb6012906263c&quot;, nonce: &quot;0x3cd80f6ec5c2f3e9&quot;, number: 66, parentHash: &quot;0x099776a52223b892d13266bb3aec3cc04c455dc797185f0b3300d39f9fc0a8ec&quot;, receiptsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, sha3Uncles: &quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;, size: 535, stateRoot: &quot;0x0c9feec5a201c8c98618331aecbfd2d4d93da1c6064abd0c41ae649fc08d8d06&quot;, timestamp: 1520391527, totalDifficulty: 8919666, transactions: [], transactionsRoot: &quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;, uncles: []&#125; 通过交易hash查看交易： 1234567891011121314151617&gt; eth.getTransaction(&quot;0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6&quot;)&#123; blockHash: &quot;0x1cb368a27cc23c786ff5cdf7cd4351d48f4c8e8aea2e084a5e9d7c480449c79a&quot;, blockNumber: 463, from: &quot;0x4a3b0216e1644c1bbabda527a6da7fc5d178b58f&quot;, gas: 90000, gasPrice: 18000000000, hash: &quot;0x1b21bba16dd79b659c83594b0c41de42debb2738b447f6b24e133d51149ae2a6&quot;, input: &quot;0x&quot;, nonce: 0, r: &quot;0x31d22686e0d408a16497becf6d47fbfdffe6692d91727e5b7ed3d73ede9e66ea&quot;, s: &quot;0x7ff7c14a20991e2dfdb813c2237b08a5611c8c8cb3c2dcb03a55ed282ce4d9c3&quot;, to: &quot;0x46b24d04105551498587e3c6ce2c3341d5988938&quot;, transactionIndex: 0, v: &quot;0x38&quot;, value: 10000000000000000000&#125;","tags":[{"name":"以太坊","slug":"以太坊","permalink":"http://blog.buerya.cn/tags/以太坊/"},{"name":"私有链","slug":"私有链","permalink":"http://blog.buerya.cn/tags/私有链/"}]},{"title":"智能合约语言 Solidity 教程系列8 - Solidity API","date":"2018-03-15T07:40:22.000Z","path":"2018/03/15/solidity-api/","text":"智能合约语言 Solidity 教程系列8 - Solidity API这是Solidity教程系列文章第8篇介绍Solidity API，它们主要表现为内置的特殊的变量及函数，存在于全局命名空间里。Solidity 系列完整的文章列表请查看分类-Solidity。 写在前面Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。 Solidity API 主要表现为Solidity 内置的特殊的变量及函数，他们存在于全局命名空间里，主要分为以下几类： 有关区块和交易的属性 有关错误处理 有关数学及加密功能 地址相关 合约相关 下面详细讲解下 区块和交易的属性（Block And Transaction Properties）用来提供一些区块链当前的信息。 block.blockhash(uint blockNumber) returns (bytes32)：返回给定区块号的哈希值，只支持最近256个区块，且不包含当前区块。 block.coinbase (address): 当前块矿工的地址。 block.difficulty (uint):当前块的难度。 block.gaslimit (uint):当前块的gaslimit。 block.number (uint):当前区块的块号。 block.timestamp (uint): 当前块的Unix时间戳（从1970/1/1 00:00:00 UTC开始所经过的秒数） msg.data (bytes): 完整的调用数据（calldata）。 msg.gas (uint): 当前还剩的gas。 msg.sender (address): 当前调用发起人的地址。 msg.sig (bytes4):调用数据(calldata)的前四个字节（例如为：函数标识符）。 msg.value (uint): 这个消息所附带的以太币，单位为wei。 now (uint): 当前块的时间戳(block.timestamp的别名) tx.gasprice (uint) : 交易的gas价格。 tx.origin (address): 交易的发送者（全调用链） 注意： msg的所有成员值，如msg.sender,msg.value的值可以因为每一次外部函数调用，或库函数调用发生变化（因为msg就是和调用相关的全局变量）。 不应该依据 block.timestamp, now 和 block.blockhash来产生一个随机数（除非你确实需要这样做），这几个值在一定程度上被矿工影响（比如在赌博合约里，不诚实的矿工可能会重试去选择一个对自己有利的hash）。 对于同一个链上连续的区块来说，当前区块的时间戳（timestamp）总是会大于上一个区块的时间戳。 为了可扩展性的原因，你只能查最近256个块，所有其它的将返回0. 错误处理 assert(bool condition)用于判断内部错误，条件不满足时抛出异常 require(bool condition):用于判断输入或外部组件错误，条件不满足时抛出异常 revert():终止执行并还原改变的状态 数学及加密功能 addmod(uint x, uint y, uint k) returns (uint):计算(x + y) % k，加法支持任意的精度且不会在2**256处溢出，从0.5.0版本开始断言k != 0。 mulmod(uint x, uint y, uint k) returns (uint):计算 (x y) % k， 乘法支持任意的精度且不会在2*256处溢出， 从0.5.0版本开始断言k != 0。 keccak256(…) returns (bytes32):使用以太坊的（Keccak-256）计算HASH值。紧密打包参数。 sha256(…) returns (bytes32):使用SHA-256计算hash值，紧密打包参数。 sha3(…) returns (bytes32):keccak256的别名 ripemd160(…) returns (bytes20):使用RIPEMD-160计算HASH值。紧密打包参数。 ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address):通过椭圆曲线签名来恢复与公钥关联的地址，或者在错误时返回零。可用于签名数据的校验，如果返回结果是签名者的公匙地址，那么说明数据是正确的。 ecrecover函数需要四个参数，需要被签名数据的哈希结果值，r，s，v分别来自签名结果串。r = signature[0:64]s = signature[64:128]v = signature[128:130]其中v取出来的值或者是00或01。要使用时，我们先要将其转为整型，再加上27，所以我们将得到27或28。在调用函数时v将填入27或28。 用javascript表达如下: 1234567var msg = '0x8CbaC5e4d803bE2A3A5cd3DbE7174504c6DD0c1C'var hash = web3.sha3(msg)var sig = web3.eth.sign(address, h).slice(2)var r = `0x$&#123;sig.slice(0, 64)&#125;`var s = `0x$&#123;sig.slice(64, 128)&#125;`var v = web3.toDecimal(sig.slice(128, 130)) + 27 紧密打包参数（tightly packed）意思是说参数不会补位，是直接连接在一起的，下面几个是相等的。 123456keccak256(&quot;ab&quot;, &quot;c&quot;)keccak256(&quot;abc&quot;)keccak256(0x616263) // hexkeccak256(6382179)keccak256(97, 98, 99) //ascii 如果需要填充，可以使用显式类型转换：keccak256(“\\x00\\x12”) 与keccak256(uint16(0x12))相同。 注意，常量将使用存储它们所需的最少字节数来打包，例如keccak256(0) == keccak256(uint8(0))和keccak256(0x12345678) == keccak256(uint32(0x12345678)) 在私链(private blockchain)上运行sha256,ripemd160或ecrecover可能会出现Out-Of-Gas报错。因为私链实现了一种预编译合约，合约要在收到第一个消息后才会真正存在（虽然他们的合约代码是硬编码的）。而向一个不存在的合约发送消息，所以才会导致Out-Of-Gas的问题。一种解决办法（workaround）是每个在你真正使用它们之前先发送1 wei到这些合约上来完成初始化。在官方和测试链上没有这个问题。 地址相关 .balance (uint256):Address的余额，以wei为单位。 .transfer(uint256 amount):发送给定数量的ether到某个地址，以wei为单位。失败时抛出异常。 .send(uint256 amount) returns (bool):发送给定数量的ether到某个地址，以wei为单位, 失败时返回false。 .call(…) returns (bool):发起底层的call调用。失败时返回false。 .callcode(…) returns (bool):发起底层的callcode调用，失败时返回false。不鼓励使用，未来可能会移除。 .delegatecall(…) returns (bool):发起底层的delegatecall调用，失败时返回false 警告：send() 执行有一些风险：如果调用栈的深度超过1024或gas耗光，交易都会失败。因此，为了保证安全，必须检查send的返回值，如果交易失败，会回退以太币。如果用transfer会更好。 合约相关 this（当前合约的类型）:表示当前合约，可以显式的转换为Address selfdestruct(address recipient):销毁当前合约，并把它所有资金发送到给定的地址。 suicide(address recipient):selfdestruct的别名 另外，当前合约里的所有函数均可支持调用，包括当前函数本身。 参考文档Special Variables and Functions","tags":[{"name":"Solidity手册","slug":"Solidity手册","permalink":"http://blog.buerya.cn/tags/Solidity手册/"}]},{"title":"智能合约语言 Solidity 教程系列7 - 以太单位及时间单位","date":"2018-03-14T16:00:00.000Z","path":"2018/03/15/solidity-unit/","text":"智能合约语言 Solidity 教程系列7 - 以太单位及时间单位这是Solidity教程系列文章第7篇介绍以太单位及时间单位，系列带你全面深入理解Solidity语言。Solidity 系列完整的文章列表请查看分类-Solidity。 写在前面Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。 货币单位(Ether Units)一个数字常量（字面量）后面跟随一个后缀wei, finney,szabo或ether，这个后缀就是货币单位。不同的单位可以转换。不含任何后缀的默认单位是wei。不同的以太币单位转换关系如下： 1 ether == 10^3 finney == 1000 finney 1 ether == 10^6 szabo 1 ether == 10^18 wei 插曲：以太币单位其实是密码学家的名字，是以太坊创始人为了纪念他们在数字货币的领域的贡献。他们分别是：wei: Wei Dai 戴伟 密码学家 ，发表 B-moneyfinney: Hal Finney 芬尼 密码学家、工作量证明机制（POW）提出szabo: Nick Szabo 尼克萨博 密码学家、智能合约的提出者 我们可以使用一下代码验证一个转换关系： 123456789101112131415161718192021222324pragma solidity ^0.4.16;contract testUnit &#123; function tf() public pure returns (bool) &#123; if (1 ether == 1000 finney)&#123; return true; &#125; return false; &#125; function ts() public pure returns (bool) &#123; if (1 ether == 1000000 szabo)&#123; return true; &#125; return false; &#125; function tgw() public pure returns (bool) &#123; if (1 ether == 1000000000000000000 wei)&#123; return true; &#125; return false; &#125;&#125; 时间单位(Time Units)时间单位: seconds, minutes, hours, days, weeks, years均可做为后缀，并进行相互转换，规则如下： 1 == 1 seconds (默认是seconds为单位) 1 minutes == 60 seconds 1 hours == 60 minutes 1 days == 24 hours 1 weeks = 7 days 1 years = 365 days 使用这些单位进行日期计算需要特别小心，因为不是每年都是365天，且并不是每天都有24小时，因为还有闰秒。由于无法预测闰秒，必须由外部的预言（oracle）来更新从而得到一个精确的日历库。 这些后缀不能用于变量。如果想对输入的变量说明其不同的单位，可以使用下面的方式： 1234567891011121314pragma solidity ^0.4.16;contract testTUnit &#123; function currTimeInSeconds() public pure returns (uint256)&#123; return now; &#125; function f(uint start, uint daysAfter) public &#123; if (now &gt;= start + daysAfter * 1 days) &#123; // ... &#125; &#125;&#125; 参考文档units","tags":[{"name":"Solidity手册","slug":"Solidity手册","permalink":"http://blog.buerya.cn/tags/Solidity手册/"}]},{"title":"如何通过以太坊智能合约来进行众筹（ICO）","date":"2018-03-14T04:02:22.000Z","path":"2018/03/14/ico-crowdsale/","text":"前面我们有两遍文章写了如何发行代币，今天我们讲一下如何使用代币来公开募资，即编写一个募资合约。 写在前面本文所讲的代币是使用以太坊智能合约创建，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 众筹先简单说下众筹的概念：一般是这样的，我一个非常好的想法，但是我没有钱来做这事，于是我把这个想法发给大家看，说：我做这件事需要5百万，大家有没有兴趣投些钱，如果大家在30天内投够了5百万我就开始做，到时大家都是原始股东，如果募资额不到5百万，大家投的钱就还给大家。 现在ICO众筹已经被各路大佬拿来割韭菜而被玩坏了（不管有无达标，都把钱卷走）。 其实区块链技术本事非常适合解决众筹的信任问题，借助于智能合约，可以实现当募资额完成时，募资款自动打到指定账户，当募资额未完成时，可退款。这个过程不需要看众筹大佬的人品，不用依靠第三方平台信用担保。 代币传统的众筹在参与之后通常不容易交易（参与之后无法转给其他人），而通过用代币来参与众筹，则很容易进行交易，众筹的参与人可随时进行买卖，待众筹项目实施完成的时候，完全根据代币持有量进行回馈。 举个例子说明下，大家会更容易理解，有这一个众筹：A有技术做一个能监测健康的指环，为此向公众募资200百万，募资时100块对应一个代币，约定在指环上市之后，代币的持有人可以用一个代币来兑换一个指环。而指环的研发周期是一年，因此在指环还未上市的一年里，众筹的参与人可以随时交易所持有的代币。 众筹智能合约代码接下来就看看如何实现一个众筹智能合约： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103pragma solidity ^0.4.16;interface token &#123; function transfer(address receiver, uint amount);&#125;contract Crowdsale &#123; address public beneficiary; // 募资成功后的收款方 uint public fundingGoal; // 募资额度 uint public amountRaised; // 参与数量 uint public deadline; // 募资截止期 uint public price; // token 与以太坊的汇率 , token卖多少钱 token public tokenReward; // 要卖的token mapping(address =&gt; uint256) public balanceOf; bool fundingGoalReached = false; // 众筹是否达到目标 bool crowdsaleClosed = false; // 众筹是否结束 /** * 事件可以用来跟踪信息 **/ event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); /** * 构造函数, 设置相关属性 */ function Crowdsale( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint durationInMinutes, uint finneyCostOfEachToken, address addressOfTokenUsedAsReward) &#123; beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; deadline = now + durationInMinutes * 1 minutes; price = finneyCostOfEachToken * 1 finney; tokenReward = token(addressOfTokenUsedAsReward); // 传入已发布的 token 合约的地址来创建实例 &#125; /** * 无函数名的Fallback函数， * 在向合约转账时，这个函数会被调用 */ function () payable &#123; require(!crowdsaleClosed); uint amount = msg.value; balanceOf[msg.sender] += amount; amountRaised += amount; tokenReward.transfer(msg.sender, amount / price); FundTransfer(msg.sender, amount, true); &#125; /** * 定义函数修改器modifier（作用和Python的装饰器很相似） * 用于在函数执行前检查某种前置条件（判断通过之后才会继续执行该方法） * _ 表示继续执行之后的代码 **/ modifier afterDeadline() &#123; if (now &gt;= deadline) _; &#125; /** * 判断众筹是否完成融资目标， 这个方法使用了afterDeadline函数修改器 * */ function checkGoalReached() afterDeadline &#123; if (amountRaised &gt;= fundingGoal) &#123; fundingGoalReached = true; GoalReached(beneficiary, amountRaised); &#125; crowdsaleClosed = true; &#125; /** * 完成融资目标时，融资款发送到收款方 * 未完成融资目标时，执行退款 * */ function safeWithdrawal() afterDeadline &#123; if (!fundingGoalReached) &#123; uint amount = balanceOf[msg.sender]; balanceOf[msg.sender] = 0; if (amount &gt; 0) &#123; if (msg.sender.send(amount)) &#123; FundTransfer(msg.sender, amount, false); &#125; else &#123; balanceOf[msg.sender] = amount; &#125; &#125; &#125; if (fundingGoalReached &amp;&amp; beneficiary == msg.sender) &#123; if (beneficiary.send(amountRaised)) &#123; FundTransfer(beneficiary, amountRaised, false); &#125; else &#123; //If we fail to send the funds to beneficiary, unlock funders balance fundingGoalReached = false; &#125; &#125; &#125;&#125; 部署及说明在部署这个合约之前，我们需要先部署一个代币合约，请参考一步步教你创建自己的数字货币。 创建众筹合约我们需要提供一下几个参数：ifSuccessfulSendTo： 募资成功后的收款方（其实这里可以默认为合约创建者）fundingGoalInEthers： 募资额度， 为了方便我们仅募3个etherdurationInMinutes： 募资时间finneyCostOfEachToken 每个代币的价格, 这里为了方便使用了单位finney及值为：1 （1 ether = 1000 finney）addressOfTokenUsedAsReward： 代币合约地址。如： 本文使用的参数为： 1&quot;0xc6f9ea59d424733e8e1902c7837ea75e20abfb49&quot;,3, 100, 1,&quot;0xad8972e2b583f580fc52f737b98327eb65d08f8c&quot; 参与人投资的时候实际购买众筹合约代币，所有需要先向合约预存代币，代币的数量为：募资额度 / 代币的价格 ， 这里为：3 * 1000/1 = 3000 （当能也可以大于3000）。向合约预存代币可以使用myetherwallet钱包，或在remix中重新加载代币合约，执行代币合约tranfer()函数进行代币转账。如使用myetherwallet转账如图： 参参与人投资行为即是向买众筹合约转账，转账时，会执行Fallback回退函数（即无名函数）向其账户打回相应的代币。 safeWithdrawl() 可以被参与人或收益人执行，如果融资不达标参与人可收回之前投资款，如果融资达标收益人可以拿到所有的融资款。 参考文档 Create a crowdsale","tags":[{"name":"智能合约","slug":"智能合约","permalink":"http://blog.buerya.cn/tags/智能合约/"},{"name":"Token","slug":"Token","permalink":"http://blog.buerya.cn/tags/Token/"},{"name":"ICO","slug":"ICO","permalink":"http://blog.buerya.cn/tags/ICO/"}]},{"title":"智能合约语言 Solidity 教程系列6 - 结构体与映射","date":"2018-03-13T05:50:23.000Z","path":"2018/03/13/solidity-structs/","text":"Solidity 教程系列第6篇 - Solidity 结构体与映射。Solidity 系列完整的文章列表请查看分类-Solidity。 写在前面Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。 结构体(Structs)Solidity提供struct 来定义自定义类型，自定义的类型是引用类型。我们看看下面的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344pragma solidity ^0.4.11;contract CrowdFunding &#123; // 定义一个包含两个成员的新类型 struct Funder &#123; address addr; uint amount; &#125; struct Campaign &#123; address beneficiary; uint fundingGoal; uint numFunders; uint amount; mapping (uint =&gt; Funder) funders; &#125; uint numCampaigns; mapping (uint =&gt; Campaign) campaigns; function newCampaign(address beneficiary, uint goal) public returns (uint campaignID) &#123; campaignID = numCampaigns++; // campaignID 作为一个变量返回 // 创建一个结构体实例，存储在storage ，放入mapping里 campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0); &#125; function contribute(uint campaignID) public payable &#123; Campaign storage c = campaigns[campaignID]; // 用mapping对应项创建一个结构体引用 // 也可以用 Funder(msg.sender, msg.value) 来初始化. c.funders[c.numFunders++] = Funder(&#123;addr: msg.sender, amount: msg.value&#125;); c.amount += msg.value; &#125; function checkGoalReached(uint campaignID) public returns (bool reached) &#123; Campaign storage c = campaigns[campaignID]; if (c.amount &lt; c.fundingGoal) return false; uint amount = c.amount; c.amount = 0; c.beneficiary.transfer(amount); return true; &#125;&#125; 上面是一个简化版的众筹合约，但它可以让我们理解structs 的基础概念，struct 可以用于映射和数组中作为元素。其本身也可以包含映射和数组等类型。 不能声明一个struct 同时将自身struct 作为成员，这个限制是基于结构体的大小必须是有限的。但struct 可以作为mapping 的值类型成员。 注意在函数中，将一个struct 赋值给一个局部变量（默认是storage 类型），实际是拷贝的引用，所以修改局部变量值的同时，会影响到原变量。 当然，也可以直接通过访问成员修改值，而不用一定赋值给一个局部变量，如campaigns[campaignID].amount = 0 映射(Mappings)映射类型，一种键值对的映射关系存储结构。定义方式为mapping(_KeyType =&gt; _KeyValue)。键类型允许除映射、变长数组、合约、枚举、结构体外的几乎所有类型（）。值类型没有任何限制，可以为任何类型包括映射类型。 映射 可以被视作为一个哈希表，所有可能的键会被虚拟化的创建，映射到一个类型的默认值（二进制的全零表示）。在映射表中，并不存储键的数据，仅仅存储它的keccak256哈希值，这个哈希值在查找值时需要用到。正因为此，映射 是没有长度的，也没有键集合或值集合的概念。 映射类型 ，仅能用来作为状态变量，或在内部函数中作为storage 类型的引用。 可以通过将映射标记为public，来让Solidity创建一个访问器。通过提供一个键值做为参数来访问它，将返回对应的值。映射的值类型也可以是映射，使用访问器访问时，要提供这个映射值所对应的键，不断重复这个过程。来看一个例子： 1234567891011121314151617pragma solidity ^0.4.0;contract MappingExample &#123; mapping(address =&gt; uint) public balances; function update(uint newBalance) public &#123; balances[msg.sender] = newBalance; &#125;&#125;contract MappingUser &#123; function f() public returns (uint) &#123; MappingExample m = new MappingExample(); m.update(100); return m.balances(this); &#125;&#125; 注意：映射并未提供迭代输出的方法，可以自行实现一个这样的数据结构。参考iterable mapping 参考文档Solidity官方文档","tags":[{"name":"Solidity手册","slug":"Solidity手册","permalink":"http://blog.buerya.cn/tags/Solidity手册/"}]},{"title":"智能合约语言 Solidity 教程系列5 - 数组介绍","date":"2018-03-12T16:00:00.000Z","path":"2018/03/13/solidity-arrays/","text":"Solidity 教程系列第5篇 - Solidity 数组介绍。Solidity 系列完整的文章列表请查看分类-Solidity。 写在前面Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。 数组（Arrays）数组可以声明时指定长度，也可以是动态变长。对storage存储的数组来说，元素类型可以是任意的，类型可以是数组，映射类型，结构体等。但对于memory的数组来说。如果作为public函数的参数，它不能是映射类型的数组，只能是支持ABI的类型。 一个元素类型为T ，固定长度为k 的数组，可以声明为T[k] ，而一个动态大小（变长）的数组则声明为T[] 。还可以声明一个多维数组，如声明一个类型为uint的数组长度为5的变长数组（5个元素都是变长数组），可以声明为uint[][5]。（注意，相比非区块链语言，多维数组的长度声明是反的。） 要访问第三个动态数组的第二个元素，使用x[2][1]。数组的序号是从0开始的，序号顺序与定义相反。 bytes 和string 是一种特殊的数组。bytes 类似byte[] ，但在外部函数作为参数调用中，bytes 会进行压缩打包。string 类似bytes ，但不提供长度和按序号的访问方式（目前）。所以应该尽量使用bytes 而不是byte[] 。 可以将字符串s通过bytes(s)转为一个bytes，可以通过bytes(s).length获取长度，bytes(s)[n]获取对应的UTF-8编码。通过下标访问获取到的不是对应字符，而是UTF-8编码，比如中文编码是多字节，变长的，所以下标访问到的只是其中的一个编码。类型为数组的状态变量，可以标记为public，从而让Solidity创建一个访问器，如果要访问数组的某个元素，指定数字下标就好了。（稍后代码示例） 创建内存数组可使用new关键字创建一个memory的数组。与stroage数组不同的是，你不能通过.length的长度来修改数组大小属性。我们来看看下面的例子： 123456789101112pragma solidity ^0.4.16;contract C &#123; function f(uint len) public pure &#123; uint[] memory a = new uint[](7); //a.length = 100; // 错误 bytes memory b = new bytes(len); // Here we have a.length == 7 and b.length == len a[6] = 8; &#125;&#125; 数组常量以及内联数组数组常量，是一个数组表达式（还没有赋值到变量）。下面是一个简单的例子： 12345678910pragma solidity ^0.4.16;contract C &#123; function f() public pure &#123; g([uint(1), 2, 3]); &#125; function g(uint[3] _data) public pure &#123; // ... &#125;&#125; 通过数组常量，创建的数组是memory的，同时还是定长的。元素类型则是使用刚好能存储的元素的能用类型，比如[1, 2, 3]，只需要uint8即可存储，它的类型是uint8[3] memory 。 由于g()方法的参数需要的是uint（默认的uint表示的其实是uint256），所以需要对第一个元素进行类型转换，使用uint(1)来进行这个转换。 还需注意的一点是，定长数组，不能与变长数组相互赋值，我们来看下面的代码： 12345678910// 无法编译pragma solidity ^0.4.0;contract C &#123; function f() public &#123; // The next line creates a type error because uint[3] memory // cannot be converted to uint[] memory. uint[] x = [uint(1), 3, 4]; &#125;&#125; 已经计划在未来移除这样的限制。当前因为ABI传递数组还有些问题。 成员length属性数组有一个.length属性，表示当前的数组长度。storage的变长数组，可以通过给.length赋值调整数组长度。memory的变长数组不支持。不能通过访问超出当前数组的长度的方式，来自动实现改变数组长度。memory数组虽然可以通过参数，灵活指定大小，但一旦创建，大小不可调整。 push方法storage的变长数组和bytes都有一个push方法（string没有），用于附加新元素到数据末端，返回值为新的长度。 限制情况当前在external函数中，不能使用多维数组。 另外，基于EVM的限制，不能通过外部函数返回动态的内容。 123contract C &#123; function f() returns (uint[]) &#123; ... &#125; &#125; 在这个的例子中，如果通过web.js调用能返回数据，但从Solidity中调用不能返回数据。一种绕过这个问题的办法是使用一个非常大的静态数组。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556pragma solidity ^0.4.16;contract ArrayContract &#123; uint[2**20] m_aLotOfIntegers; // 这里不是两个动态数组的数组，而是一个动态数组里，每个元素是长度为二的数组。 bool[2][] m_pairsOfFlags; // newPairs 存在 memory里，因为是函数参数 function setAllFlagPairs(bool[2][] newPairs) public &#123; m_pairsOfFlags = newPairs; &#125; function setFlagPair(uint index, bool flagA, bool flagB) public &#123; // 访问不存在的index会抛出异常 m_pairsOfFlags[index][0] = flagA; m_pairsOfFlags[index][1] = flagB; &#125; function changeFlagArraySize(uint newSize) public &#123; // 如果新size更小, 移除的元素会被销毁 m_pairsOfFlags.length = newSize; &#125; function clear() public &#123; // 销毁 delete m_pairsOfFlags; delete m_aLotOfIntegers; // 同销毁一样的效果 m_pairsOfFlags.length = 0; &#125; bytes m_byteData; function byteArrays(bytes data) public &#123; // byte arrays (&quot;bytes&quot;) are different as they are stored without padding, // but can be treated identical to &quot;uint8[]&quot; m_byteData = data; m_byteData.length += 7; m_byteData[3] = byte(8); delete m_byteData[2]; &#125; function addFlag(bool[2] flag) public returns (uint) &#123; return m_pairsOfFlags.push(flag); &#125; function createMemoryArray(uint size) public pure returns (bytes) &#123; // Dynamic memory arrays are created using `new`: uint[2][] memory arrayOfPairs = new uint[2][](size); // Create a dynamic byte array: bytes memory b = new bytes(200); for (uint i = 0; i &lt; b.length; i++) b[i] = byte(i); return b; &#125;&#125; 参考文档Solidity官方文档-数组","tags":[{"name":"Solidity手册","slug":"Solidity手册","permalink":"http://blog.buerya.cn/tags/Solidity手册/"}]},{"title":"智能合约语言 Solidity 教程系列4 - 数据存储位置分析","date":"2018-03-11T16:00:00.000Z","path":"2018/03/12/solidity_reftype_datalocation/","text":"Solidity教程系列第4篇 - Solidity数据位置分析。Solidity 系列完整的文章列表请查看分类-Solidity。 写在前面Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。 数据位置(Data location)在系列第一篇，我们提到 Solidity 类型分为两类：值类型(Value Type) 及 引用类型(Reference Types)，前面我们已经介绍完了值类型，接下来会介绍引用类型。 引用类型是一个复杂类型，占用的空间通常超过256位， 拷贝时开销很大，因此我们需要考虑将它们存储在什么位置，是memory（内存中，数据不是永久存在）还是storage（永久存储在区块链中）所有的复杂类型如数组(arrays)和结构体(struct)有一个额外的属性：数据的存储位置（data location）。可为memory和storage。 根据上下文的不同，大多数时候数据位置有默认值，也通过指定关键字storage和memory修改它。 函数参数（包含返回的参数）默认是memory。局部复杂类型变量（local variables）和 状态变量（state variables） 默认是storage。 局部变量：局部作用域（越过作用域即不可被访问，等待被回收）的变量，如函数内的变量。状态变量：合约内声明的公有变量 还有一个存储位置是：calldata，用来存储函数参数，是只读的，不会永久存储的一个数据位置。外部函数的参数（不包括返回参数）被强制指定为calldata。效果与memory差不多。 数据位置指定非常重要，因为他们影响着赋值行为。在memory和storage之间或与状态变量之间相互赋值，总是会创建一个完全独立的拷贝。而将一个storage的状态变量，赋值给一个storage的局部变量，是通过引用传递。所以对于局部变量的修改，同时修改关联的状态变量。另一方面，将一个memory的引用类型赋值给另一个memory的引用，不会创建拷贝（即：memory之间是引用传递）。 注意：不能将memory赋值给局部变量。 对于值类型，总是会进行拷贝。 下面看一段代码： 1234567891011121314151617181920212223242526pragma solidity ^0.4.0;contract C &#123; uint[] x; // x的存储位置是storage // memoryArray的存储位置是 memory function f(uint[] memoryArray) public &#123; x = memoryArray; // 从 memory 复制到 storage var y = x; // storage 引用传递局部变量y（y 是一个 storage 引用） y[7]; // 返回第8个元素 y.length = 2; // x同样会被修改 delete x; // y同样会被修改 // 错误， 不能将memory赋值给局部变量 // y = memoryArray; // 错误，不能通过引用销毁storage // delete y; g(x); // 引用传递， g可以改变x的内容 h(x); // 拷贝到memory， h无法改变x的内容 &#125; function g(uint[] storage storageArray) internal &#123;&#125; function h(uint[] memoryArray) public &#123;&#125;&#125; 总结强制的数据位置(Forced data location) 外部函数(External function)的参数(不包括返回参数)强制为：calldata 状态变量(State variables)强制为: storage 默认数据位置（Default data location） 函数参数及返回参数：memory 复杂类型的局部变量：storage 深入分析storage 存储结构是在合约创建的时候就确定好了的，它取决于合约所声明状态变量。但是内容可以被（交易）调用改变。 Solidity 称这个为状态改变，这也是合约级变量称为状态变量的原因。也可以更好的理解为什么状态变量都是storage存储。 memory 只能用于函数内部，memory 声明用来告知EVM在运行时创建一块（固定大小）内存区域给变量使用。 storage 在区块链中是用key/value的形式存储，而memory则表现为字节数组 关于栈EVM是一个基于栈的语言，栈实际是在内存(memory)的一个数据结构，每个栈元素占为256位，栈最大长度为1024。值类型的局部变量是存储在栈上。 不同存储的消耗（gas消耗） storage 会永久保存合约状态变量，开销最大 memory 仅保存临时变量，函数调用之后释放，开销很小 stack 保存很小的局部变量，几乎免费使用，但有数量限制。 参考资料Solidity官方文档-类型","tags":[{"name":"Solidity手册","slug":"Solidity手册","permalink":"http://blog.buerya.cn/tags/Solidity手册/"}]},{"title":"实现一个可管理、增发、兑换、冻结等高级功能的代币","date":"2018-03-10T09:02:22.000Z","path":"2018/03/10/create-token2/","text":"本文主要介绍代币高级功能的实现: 代币管理、代币增发、代币兑换、资产冻结、Gas自动补充。 写在前面在上一篇：一步步教你创建自己的数字货币（代币）进行ICO中我们实现一个最基本功能的代币，本文将在上一遍文章的基础上，讲解如果添加更多的高级功能。 实现代币的管理者虽然区块链是去中心化的，但是实现对代币（合约）的管理，也在许多应用中有需求，为了对代币进行管理，首先需要给合约添加一个管理者。 我们来看看如果实现，先创建一个owned 合约。 1234567891011121314151617contract owned &#123; address public owner; function owned() &#123; owner = msg.sender; &#125; modifier onlyOwner &#123; require(msg.sender == owner); _; &#125; // 实现所有权转移 function transferOwnership(address newOwner) onlyOwner &#123; owner = newOwner; &#125;&#125; 这个合约重要的是加入了一个函数修改器（Function Modifiers）onlyOwner，函数修改器是一个合约属性，可以被继承，还能被重写。它用于在函数执行前检查某种前置条件。 1234567891011contract MyToken is owned &#123; function MyToken( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, address centralMinter ) &#123; if(centralMinter != 0 ) owner = centralMinter; &#125;&#125; 代币增发实现代币增发，代币增发就如同央行印钞票一样，想必很多人都需要这样的功能。 给合约添加以下的方法： 123456function mintToken(address target, uint256 mintedAmount) onlyOwner &#123; balanceOf[target] += mintedAmount; totalSupply += mintedAmount; Transfer(0, owner, mintedAmount); Transfer(owner, target, mintedAmount); &#125; 注意onlyOwner修改器添加在函数末尾，这表示只有ower才能调用这用函数。他的功能很简单，就是给指定的账户增加代币，同时增加总供应量。 资产冻结有时为了监管的需要，需要实现冻结某些账户，冻结后，其资产仍在账户，但是不允许交易，之道解除冻结。给合约添加以下的变量和方法（可以添加到合约的任何地方，但是建议把mapping加到和其他mapping一起，event也是如此）： 1234567mapping (address =&gt; bool) public frozenAccount;event FrozenFunds(address target, bool frozen);function freezeAccount(address target, bool freeze) onlyOwner &#123; frozenAccount[target] = freeze; FrozenFunds(target, freeze);&#125; 单单以上的代码还无法冻结，需要把他加入到transfer函数中才能真正生效，因此修改transfer函数 1234function transfer(address _to, uint256 _value) &#123; require(!frozenAccount[msg.sender]); ...&#125; 这样在转账前，对发起交易的账号做一次检查，只有不是被冻结的账号才能转账。 代币买卖（兑换）可以自己的货币中实现代币与其他数字货币（ether 或其他tokens）的兑换机制。有了这个功能，我们的合约就可以在一买一卖中赚利润了。 先来设置下买卖价格 1234567uint256 public sellPrice;uint256 public buyPrice;function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner &#123; sellPrice = newSellPrice; buyPrice = newBuyPrice;&#125; setPrices()添加了onlyOwner修改器，注意买卖的价格单位是wei（最小的货币单位： 1 eth = 1000000000000000000 wei) 现在来添加买卖函数： 123456789101112131415161718function buy() payable returns (uint amount)&#123; amount = msg.value / buyPrice; // calculates the amount require(balanceOf[this] &gt;= amount); // checks if it has enough to sell balanceOf[msg.sender] += amount; // adds the amount to buyer&apos;s balance balanceOf[this] -= amount; // subtracts amount from seller&apos;s balance Transfer(this, msg.sender, amount); // execute an event reflecting the change return amount; // ends function and returns&#125;function sell(uint amount) returns (uint revenue)&#123; require(balanceOf[msg.sender] &gt;= amount); // checks if the sender has enough to sell balanceOf[this] += amount; // adds the amount to owner&apos;s balance balanceOf[msg.sender] -= amount; // subtracts the amount from seller&apos;s balance revenue = amount * sellPrice; msg.sender.transfer(revenue); // sends ether to the seller: it&apos;s important to do this last to prevent recursion attacks Transfer(msg.sender, this, amount); // executes an event reflecting on the change return revenue; // ends function and returns&#125; 加入了买卖功能后，要求我们在创建合约时发送足够的以太币，以便合约有能力回购市面上的代币，否则合约将破产，用户没法先合约卖代币。 实现Gas的自动补充以太坊中的交易时需要gas（支付给矿工的费用，费用以ether来支付）。而如果用户没有以太币，只有代币的情况（或者我们想向用户隐藏以太坊的细节），就需要自动补充gas的功能。这个功能将使我们代币更加好用。 自动补充的逻辑是这样了，在执行交易之前，我们判断用户的余额（用来支付矿工的费用），如果用户的余额非常少（低于某个阈值时）可能影响到交易进行，合约自动售出一部分代币来补充余额，以帮助用户顺利完成交易。 先来设定余额阈值： 12345uint minBalanceForAccounts; function setMinBalance(uint minimumBalanceInFinney) onlyOwner &#123; minBalanceForAccounts = minimumBalanceInFinney * 1 finney; &#125; finney 是货币单位1 finney = 0.001eth然后交易中加入对用户的余额的判断。 1234567function transfer(address _to, uint256 _value) &#123; ... if(msg.sender.balance &lt; minBalanceForAccounts) sell((minBalanceForAccounts - msg.sender.balance) / sellPrice); if(_to.balance&lt;minBalanceForAccounts) // 可选，让接受者也补充余额，以便接受者使用代币。 _to.send(sell((minBalanceForAccounts - _to.balance) / sellPrice));&#125; 代码部署项目的完整的部署方法参考上一篇，不同的是创建合约时需要预存余额，如图： 参考文档","tags":[{"name":"智能合约","slug":"智能合约","permalink":"http://blog.buerya.cn/tags/智能合约/"},{"name":"Token","slug":"Token","permalink":"http://blog.buerya.cn/tags/Token/"}]},{"title":"智能合约语言 Solidity 教程系列3 - 类型介绍","date":"2018-03-08T16:00:00.000Z","path":"2018/03/09/solidity_func/","text":"Solidity 教程系列第三篇 - Solidity 函数类型介绍。Solidity 系列完整的文章列表请查看分类-Solidity。 写在前面Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。 函数类型(Function Types)函数也是一种类型，且属于值类型。可以将一个函数赋值给一个函数类型的变量。还可以将一个函数作为参数进行传递。也可以在函数调用中返回一个函数。函数类型有两类:内部(internal)和外部(external)函数 内部(internal) 函数只能在当前合约内被调用（在当前的代码块内，包括内部库函数，和继承的函数中）。外部(external) 函数由地址和函数方法签名两部分组成，可作为外部函数调用的参数，或返回值。 函数类型定义如下： 1function (&lt;parameter types&gt;) &#123;internal|external&#125; [pure|constant|view|payable] [returns (&lt;return types&gt;)] 如果函数不需要返回，则省去returns ()函数类型默认是internal， 因此internal可以省去。但以此相反，合约中函数本身默认是public的， 仅仅是当作类型名使用时默认是internal的。 有两个方式访问函数，一种是直接用函数名f, 一种是this.f， 前者用于内部函数，后者用于外部函数。 如果一个函数变量没有初始化，直接调用它将会产生异常。如果delete了一个函数后调用，也会发生同样的异常。 如果外部函数类型在Solidity的上下文环境以外的地方使用，他们会被视为function类型。它会编码为20字节的函数所在地址，和在它之前的4字节的函数方法签名一起作为bytes24类型。合约中的public的函数，可以使用internal和external两种方式来调用。internal访问形式为f, external访问形式为this.f 成员：属性 selectorpublic (或 external) 函数有一个特殊的成员selector, 它对应一个ABI 函数选择器。 1234567pragma solidity ^0.4.16;contract Selector &#123; function f() public view returns (bytes4) &#123; return this.f.selector; &#125;&#125; 下面的代码显示内部（internal）函数类型的使用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748pragma solidity ^0.4.16;library ArrayUtils &#123; // internal functions can be used in internal library functions because // they will be part of the same code context function map(uint[] memory self, function (uint) pure returns (uint) f) internal pure returns (uint[] memory r) &#123; r = new uint[](self.length); for (uint i = 0; i &lt; self.length; i++) &#123; r[i] = f(self[i]); &#125; &#125; function reduce( uint[] memory self, function (uint, uint) pure returns (uint) f ) internal pure returns (uint r) &#123; r = self[0]; for (uint i = 1; i &lt; self.length; i++) &#123; r = f(r, self[i]); &#125; &#125; function range(uint length) internal pure returns (uint[] memory r) &#123; r = new uint[](length); for (uint i = 0; i &lt; r.length; i++) &#123; r[i] = i; &#125; &#125;&#125;contract Pyramid &#123; using ArrayUtils for *; function pyramid(uint l) public pure returns (uint) &#123; return ArrayUtils.range(l).map(square).reduce(sum); &#125; function square(uint x) internal pure returns (uint) &#123; return x * x; &#125; function sum(uint x, uint y) internal pure returns (uint) &#123; return x + y; &#125;&#125; 下面的代码显示外部（external）函数类型的使用： 1234567891011121314151617181920212223242526272829pragma solidity ^0.4.11;contract Oracle &#123; struct Request &#123; bytes data; function(bytes memory) external callback; &#125; Request[] requests; event NewRequest(uint); function query(bytes data, function(bytes memory) external callback) public &#123; requests.push(Request(data, callback)); NewRequest(requests.length - 1); &#125; function reply(uint requestID, bytes response) public &#123; // Here goes the check that the reply comes from a trusted source requests[requestID].callback(response); &#125;&#125;contract OracleUser &#123; Oracle constant oracle = Oracle(0x1234567); // known contract function buySomething() &#123; oracle.query(&quot;USD&quot;, this.oracleResponse); &#125; function oracleResponse(bytes response) public &#123; require(msg.sender == address(oracle)); // Use the data &#125;&#125; 函数可见性分析 public - 任意访问 private - 仅当前合约内 internal - 仅当前合约及所继承的合约 external - 仅外部访问（在内部也只能用外部访问方式访问） 参考文档Solidity官方文档-类型","tags":[{"name":"Solidity手册","slug":"Solidity手册","permalink":"http://blog.buerya.cn/tags/Solidity手册/"}]},{"title":"一步步教你创建自己的数字货币（代币）进行ICO","date":"2018-03-08T07:02:22.000Z","path":"2018/03/08/create_token/","text":"本文从技术角度详细介绍如何基于以太坊ERC20创建代币的流程. 写在前面本文所讲的代币是使用以太坊智能合约创建，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 代币Token如果不那么追求精确的定义，代币就是数字货币，比特币、以太币就是一个代币。利用以太坊的智能合约可以轻松编写出属于自己的代币，代币可以代表任何可以交易的东西，如：积分、财产、证书等等。因此不管是出于商业，还是学习很多人想创建一个自己的代币，先贴一个图看看创建的代币是什么样子。 今天我们就来详细讲一讲怎样创建一个这样的代币。 ERC20 Token也许你经常看到ERC20和代币一同出现， ERC20是以太坊定义的一个代币标准。要求我们在实现代币的时候必须要遵守的协议，如指定代币名称、总量、实现代币交易函数等，只有支持了协议才能被以太坊钱包支持。其接口如下： 12345678910111213141516contract ERC20Interface &#123; string public constant name = &quot;Token Name&quot;; string public constant symbol = &quot;SYM&quot;; uint8 public constant decimals = 18; // 18 is the most common number of decimal places function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens);&#125; 简单说明一下：name ： 代币名称symbol： 代币符号decimals： 代币小数点位数，代币的最小单位， 18表示我们可以拥有 .0000000000000000001单位个代币。totalSupply() : 发行代币总量。balanceOf(): 查看对应账号的代币余额。transfer(): 实现代币交易，用于给用户发送代币（从我们的账户里）。transferFrom(): 实现代币用户之间的交易。allowance(): 控制代币的交易，如可交易账号及资产。approve(): 允许用户可花费的代币数。 编写代币合约代码代币合约代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980pragma solidity ^0.4.16;interface tokenRecipient &#123; function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; &#125;contract TokenERC20 &#123; string public name; string public symbol; uint8 public decimals = 18; // 18 是建议的默认值 uint256 public totalSupply; mapping (address =&gt; uint256) public balanceOf; // mapping (address =&gt; mapping (address =&gt; uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public &#123; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; &#125; function _transfer(address _from, address _to, uint _value) internal &#123; require(_to != 0x0); require(balanceOf[_from] &gt;= _value); require(balanceOf[_to] + _value &gt; balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); &#125; function transfer(address _to, uint256 _value) public &#123; _transfer(msg.sender, _to, _value); &#125; function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) &#123; require(_value &lt;= allowance[_from][msg.sender]); // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; &#125; function approve(address _spender, uint256 _value) public returns (bool success) &#123; allowance[msg.sender][_spender] = _value; return true; &#125; function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) &#123; tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) &#123; spender.receiveApproval(msg.sender, _value, this, _extraData); return true; &#125; &#125; function burn(uint256 _value) public returns (bool success) &#123; require(balanceOf[msg.sender] &gt;= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; &#125; function burnFrom(address _from, uint256 _value) public returns (bool success) &#123; require(balanceOf[_from] &gt;= _value); require(_value &lt;= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; &#125;&#125; 部署在开发测试智能合约时，MetaMask和Remix Solidity IDE是两个非常好用的工具，今天就用他们来完成部署。 安装和配置MetaMask请参考开发、部署第一个去中心化应用，不同的上本文选择了以太坊的测试网络Ropsten，如果你没有余额请点击购买buy，进入的网站可以送一些测试以太币给你，配置好之后，界面应该如下： 浏览器打开Remix Solidity IDE，\b复制以上源码粘贴上，在右侧选项参考如图的设置： 注意Environment和Account和MetaMask保持一致，然后选择合约TokenERC20，填入你想要的发行量，名称及代号，就可以创建合约了。这时MetaMask会弹出一个交易确认框，点SUBMIT。待合约部署交易确认之后，复制合约地址。 打开Metamask界面，切换到TOKENS，点添加合约，出现如下对话框： 填入刚刚复制的地址，点击ADD，这时你就可以看到你创建的代币了，如图： 哈哈，你已经完成了代币的创建和部署(正式网络和测试网络部署方法一样)，可以在Etherscan查询到我们刚刚部署的代币。可以用它进行ICO了，从此走上人生巅峰（玩笑话，不鼓励大家发行无意义的代币）。 代币交易由于MetaMask插件没有提供代币交易功能，同时考虑到很多人并没有以太坊钱包或是被以太坊钱包网络同步问题折磨，今天我用网页钱包来讲解代币交易。 进入网页钱包地址，第一次进入有一些安全提示需要用户确认。 进入之后，按照下图进行设置： 连接上之后，如图 需要添加代币，填入代币合约地址 进行代币转账交易 接下来的交易确认也点击确认即可。 交易完成后，可以看到MetaMask中代币余额减少了，如图： 代币交易是不是很简单，只要明白了交易流程，使用其他的钱包也是一样的道理。 参考文档 代币标准 Create your own crypto-currency with ethereum","tags":[{"name":"智能合约","slug":"智能合约","permalink":"http://blog.buerya.cn/tags/智能合约/"},{"name":"Token","slug":"Token","permalink":"http://blog.buerya.cn/tags/Token/"}]},{"title":"智能合约语言 Solidity 教程系列2 - 类型介绍","date":"2018-03-04T16:00:00.000Z","path":"2018/03/05/solidity2/","text":"Solidity教程系列第二篇 - Solidity地址类型介绍.Solidity 系列完整的文章列表请查看分类-Solidity。 写在前面Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么 本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。 地址类型（Address）地址类型address是一个值类型， 地址 ： 20字节（一个以太坊地址的长度），地址类型也有成员，地址是所有合约的基础支持的运算符： &lt;=, &lt;, ==, !=, &gt;= 和 &gt; &gt; 注意：从0.5.0开始，合约不再继承自地址类型，但仍然可以显式转换为地址。 地址类型的成员 balance 属性及transfer() 函数这里是地址类型相关成员的快速索引balance用来查询账户余额，transfer()用来发送以太币（以wei为单位）。如： 123address x = 0x123;address myAddress = this;if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10); 注解 ：如果x是合约地址，合约的回退函数（fallback 函数）会随transfer调用一起执行（这个是EVM特性），如果因gas耗光或其他原因失败，转移交易会还原并且合约会抛异常停止。 关于回退函数（fallback 函数），简单来说它是合约中无函数名函数，下面代码事例中，进进一步讲解回退函数（fallback） 的使用。 send() 函数send 与transfer对应，但更底层。如果执行失败，transfer不会因异常停止，而send会返回false。 警告 ：send() 执行有一些风险：如果调用栈的深度超过1024或gas耗光，交易都会失败。因此，为了保证安全，必须检查send的返回值，如果交易失败，会回退以太币。如果用transfer会更好。 call(), callcode() 和 delegatecall() 函数为了和非ABI协议的合约进行交互，可以使用call() 函数, 它用来向另一个合约发送原始数据，支持任何类型任意数量的参数，每个参数会按规则(ABI协议)打包成32字节并一一拼接到一起。一个例外是：如果第一个参数恰好4个字节，在这种情况下，会被认为根据ABI协议定义的函数器指定的函数签名而直接使用。如果仅想发送消息体，需要避免第一个参数是4个字节。如下面的例子： 123address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;nameReg.call(&quot;register&quot;, &quot;MyName&quot;);nameReg.call(bytes4(keccak256(&quot;fun(uint256)&quot;)), a); call函数返回一个bool值，以表明执行成功与否。正常结束返回true，异常终止返回false。但无法获取到结果数据，因为需要提前知道返回的数据的编码和数据大小（因不知道对方使用的协议格式，所以也不会知道返回的结果如何解析）。还可以提供.gas()修饰器进行调用： 1namReg.call.gas(1000000)(&quot;register&quot;, &quot;MyName&quot;); 类似还可以提供附带以太币： 1nameReg.call.value(1 ether)(&quot;register&quot;, &quot;MyName&quot;); 修饰器可以混合使用，修饰器调用顺序无所谓。 1nameReg.call.gas(1000000).value(1 ether)(&quot;register&quot;, &quot;MyName&quot;); 注解：目前还不能在重载函数上使用gas或value修饰符，A workaround is to introduce a special case for gas and value and just re-check whether they are present at the point of overload resolution.（这句我怕翻译的不准确，引用原文） 同样我们也可以使用delegatecall()，它与call方法的区别在于，仅仅是代码会执行，而其它方面，如（存储，余额等）都是用的当前的合约的数据。delegatecall()方法的目的是用来执行另一个合约中的库代码。所以开发者需要保证两个合约中的存储变量能兼容，来保证delegatecall()能顺利执行。在homestead阶段之前，仅有一个受限的callcode()方法可用，但callcode未提供对msg.sender，msg.value的访问权限。 上面的这三个方法call()，delegatecall()，callcode()都是底层的消息传递调用，最好仅在万不得已才进行使用，因为他们破坏了Solidity的类型安全。.gas() 在call(), callcode() 和 delegatecall() 函数下都可以使用， delegatecall()不支持.value() 注解：所有合约都继承了address的成员，因此可以使用this.balance查询余额。callcode不鼓励使用，以后会移除。 警告：上述的函数都是底层的函数，使用时要异常小心。当调用一个未知的，可能是恶意的合约时，当你把控制权交给它，它可能回调回你的合约，所以要准备好在调用返回时，应对你的状态变量可能被恶意篡改的情况。 地址常量（Address Literals）一个能通过地址合法性检查（address checksum test）十六进制常量就会被认为是地址，如0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF。而不能通过地址合法性检查的39到41位长的十六进制常量，会提示一个警告，被视为普通的有理数常量。 地址合法性检查定义在EIP-55 合约事例讲解合约事例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445pragma solidity ^0.4.0;contract AddrTest&#123; event logdata(bytes data); function() payable &#123; logdata(msg.data); &#125; function getBalance() returns (uint) &#123; return this.balance; &#125; uint score = 0; function setScore(uint s) public &#123; score = s; &#125; function getScore() returns ( uint)&#123; return score; &#125;&#125;contract CallTest&#123; function deposit() payable &#123; &#125; event logSendEvent(address to, uint value); function transferEther(address towho) payable &#123; towho.transfer(10); logSendEvent(towho, 10); &#125; function callNoFunc(address addr) returns (bool)&#123; return addr.call(&quot;tinyxiong&quot;, 1234); &#125; function callfunc(address addr) returns (bool)&#123; bytes4 methodId = bytes4(keccak256(&quot;setScore(uint256)&quot;)); return addr.call(methodId, 100); &#125; function getBalance() returns (uint) &#123; return this.balance; &#125; &#125; 代码运行及讲解代码运行及讲解，请订阅区块链技术查看 参考文档Solidity官方文档-类型 s","tags":[{"name":"Solidity手册","slug":"Solidity手册","permalink":"http://blog.buerya.cn/tags/Solidity手册/"}]},{"title":"比特币如何达成共识 - 最长链的选择","date":"2018-03-02T16:00:00.000Z","path":"2018/03/03/bitcoin-sonsensus/","text":"比特币没有中心机构，几乎所有的完整节点都有一份公共总帐本，那么大家如何达成共识：确认哪一份才是公认权威的总账本呢？ 为什么要遵守协议这其实是一个经济问题，在经济活动中的每个人都是自私自利的，追求的是利益的最大化，一个节点工作量只有在其他的节点认同其是有效的（打包的新区块，其他的节点只有验证通过才会加入到区块链中，并在网络上传播），才能够过得收益，而只有遵守规则才会得到其他的节点认同。因此，基于逐利，节点就会自发的遵守协议。共识就是数以万计的独立节点遵守了简单的规则（通过异步交互）自发形成的。 共识：共同遵守的协议规范 去中心化共识在工作量证明一篇，我们了解通过工作量证明来竞争记账，权威的总帐本是怎么达到共识的，没有完全说清楚，今天补上，实际上，比特币的共识由所有节点的4个独立过程 相互作用而产生： 每个节点（挖矿节点）依据标准对每个交易进行独立验证 挖矿节点通过完成工作量证明，将交易记录独立打包进新区块 每个节点独立的对新区块进行校验并组装进区块链 每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链 共识最终目的是保证比特币不停的在工作量最大的区块链上运转，工作量最大的区块链就是权威的公共总帐本。 第1 2 3步在比特币如何挖矿-工作量证明一篇有提到过，下面着重讲第4步。 最长链的选择先来一个定义，把累计了最多难度的区块链。在一般情况下，也是包含最多区块的那个链称为主链每一个（挖矿）节点总是选择并尝试延长主链。 分叉当有两名矿工在几乎在相同的时间内，各自都算得了工作量证明解，便立即传播自己的“获胜”区块到网络中，先是传播给邻近的节点而后传播到整个网络。每个收到有效区块的节点都会将其并入并延长区块链。当这个两个区块传播时，一些节点首先收到#3458A, 一些节点首先收到#3458B，这两个候选区块（通常这两个候选区块会包含几乎相同的交易）都是主链的延伸，分叉就会产生，这时分叉出有竞争关系的两条链，如图： 两个块都收到的节点，会把其中有更多工作量的一条会继续作为主链，另一条作为备用链 保存（保存是因为备用链将来可能会超过主链难度称为新主链）。 分叉解决收到#3458A的（挖矿）节点，会立刻以这个区块为父区块来产生新的候选区块，并尝试寻找这个候选区块的工作量证明解。同样地，接受#3458B区块的节点会以这个区块为链的顶点开始生成新块，延长这个链（下面称为B链）。这时总会有一方抢先发现工作量证明解并将其传播出去，假设以#3458B为父区块的工作量证明首先解出，如图： 当原本以#3458A为父区块求解的节点在收到#3458B, #3459B之后，会立刻将B链作为主链（因为#3458A为顶点的链已经不是最长链了）继续挖矿。 节点也有可能先收到#3459B，再收到#3458B，收到#3459B时，会被认为是“孤块“（因为还找不到#3459B的父块#3458B）保存在孤块池中，一旦收到父块#3458B时，节点就会将孤块从孤块池中取出，并且连接到它的父区块，让它作为区块链的一部分。 比特币将区块间隔设计为10分钟，是在更快速的交易确认和更低的分叉概率间作出的妥协。更短的区块产生间隔会让交易确认更快地完成，也会导致更加频繁地区块链分叉。与之相对地，长的间隔会减少分叉数量，却会导致更长的确认时间。","tags":[{"name":"比特币","slug":"比特币","permalink":"http://blog.buerya.cn/tags/比特币/"},{"name":"共识协议","slug":"共识协议","permalink":"http://blog.buerya.cn/tags/共识协议/"}]},{"title":"智能合约语言 Solidity 教程系列1 - 类型介绍","date":"2018-02-28T16:00:00.000Z","path":"2018/03/01/solidity1/","text":"写在前面Solidity是以太坊智能合约编程语言，阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么Solidity教程会是一系列文章，本文是第一篇：介绍Solidity的变量类型。Solidity 系列完整的文章列表请查看分类-Solidity。 本文前半部分是参考Solidity官方文档（当前最新版本：0.4.20）进行翻译，后半部分是结合实际合约代码实例说明类型的使用（仅针对专栏订阅用户）。 类型Solidity是一种静态类型语言，意味着每个变量（本地或状态变量）需要在编译时指定变量的类型（或至少可以推倒出类型）。Solidity提供了一些基本类型可以用来组合成复杂类型。 Solidity类型分为两类： 值类型(Value Type) - 变量在赋值或传参时，总是进行值拷贝。 引用类型(Reference Types) 值类型(Value Type)值类型包含: 布尔类型(Booleans) 整型(Integers) 定长浮点型(Fixed Point Numbers) 定长字节数组(Fixed-size byte arrays) 有理数和整型常量(Rational and Integer Literals) 字符串常量（String literals） 十六进制常量（Hexadecimal literals） 枚举(Enums) 函数类型(Function Types) 地址类型(Address) 地址常量(Address Literals) 函数类型及地址类型(Address)有单独的博文，请点击查看。 布尔类型(Boolean)布尔(bool):可能的取值为常量值true和false。 布尔类型支持的运算符有： ！逻辑非 &amp;&amp; 逻辑与 || 逻辑或 == 等于 != 不等于 注意：运算符&amp;&amp;和||是短路运算符，如f(x)||g(y)，当f(x)为真时，则不会继续执行g(y)。 整型(Integers)int/uint: 表示有符号和无符号不同位数整数。支持关键字uint8 到 uint256 (以8步进)，uint 和 int 默认对应的是 uint256 和 int256。 支持的运算符： 比较运算符： &lt;=, &lt; , ==, !=, &gt;=, &gt; (返回布尔值：true 或 false) 位操作符： &amp;，|，^(异或)，~（位取反） 算术操作符：+，-，一元运算-，一元运算+，，/, %(取余数), **（幂）, &lt;&lt; (左移位), &gt;&gt; (右移位) 说明： 整数除法总是截断的，但如果运算符是字面量（字面量稍后讲)，则不会截断。 整数除0会抛异常。 移位运算的结果的正负取决于操作符左边的数。x &lt;&lt; y 和 x 2**y 是相等， x &gt;&gt; y 和 x / 2**y 是相等的。 不能进行负移位，即操作符右边的数不可以为负数，否则会抛出运行时异常。 注意：Solidity中，右移位是和除等价的，因此右移位一个负数，向下取整时会为0，而不像其他语言里为无限负小数。 定长浮点型（Fixed Point Numbers）fixed/ufixed: 表示有符号和无符号的固定位浮点数。关键字为ufixedMxN 和 ufixedMxN。M表示这个类型要占用的位数，以8步进，可为8到256位。N表示小数点的个数，可为0到80之前 支持的运算符： 比较运算符： &lt;=, &lt; , ==, !=, &gt;=, &gt; (返回布尔值：true 或 false) 算术操作符：+，-，一元运算-，一元运算+，，/, %(取余数)注意：它和大多数语言的float和double不一样，*M是表示整个数占用的固定位数，包含整数部分和小数部分。因此用一个小位数（M较小）来表示一个浮点数时，小数部分会几乎占用整个空间。 定长字节数组(Fixed-size byte arrays)关键字有：bytes1, bytes2, bytes3, …, bytes32。（以步长1递增）byte代表bytes1。 支持的运算符： 比较符: &lt;=, &lt;, ==, !=, &gt;=, &gt; (返回bool） 位操作符: &amp;, |, ^ (按位异或)，~（按位取反）, &lt;&lt; (左移位), &gt;&gt; (右移位) 索引（下标）访问: 如果x是bytesI，当0 &lt;= k &lt; I ，则x[k]返回第k个字节（只读）。 移位运算和整数类似，移位运算的结果的正负取决于操作符左边的数，且不能进行负移位。如可以-5&lt;&lt;1, 不可以5&lt;&lt;-1 成员变量：.length：表示这个字节数组的长度（只读）。 变长（动态分配大小）字节数组（Dynamically-sized byte array） bytes:动态分配大小字节数组, 参见Arrays,不是值类型! string:动态分配大小UTF8编码的字符类型,参看Arrays。不是值类型! 根据经验：bytes用来存储任意长度的字节数据，string用来存储任意长度的(UTF-8编码)的字符串数据。如果长度可以确定，尽量使用定长的如byte1到byte32中的一个，因为这样更省空间。 有理数和整型常量(Rational and Integer Literals) 也有人把Literals翻译为字面量 整型常量是有一系列0-9的数字组成，10进制表示，比如：8进制是不存在的，前置0在Solidity中是无效的。 10进制小数常量（Decimal fraction literals）带了一个.， 在.的两边至少有一个数字，有效的表示如:1., .1 和 1.3. 科学符号也支持，基数可以是小数，指数必须是整数， 有效的表示如: 2e10, -2e10, 2e-10, 2.5e1。 数字常量表达式本身支持任意精度，也就是可以不会运算溢出，或除法截断。但当它被转换成对应的非常量类型，或者将他们与非常量进行运算，则不能保证精度了。如：(2800 + 1) - 2800的结果为1（uint8整类) ，尽管中间结果已经超过计算机字长。另外：.5 * 8的结果是4，尽管有非整形参与了运算。 只要操作数是整形，整型支持的运算符都适用于整型常量表达式。如果两个操作数是小数，则不允许进行位运算，指数也不能是小数。 注意：Solidity对每一个有理数都有一个数值常量类型。整数常量和有理数常量从属于数字常量。所有的数字常表达式的结果都属于数字常量。所以1 + 2和2 + 1都属于同样的有理数的数字常量3 警告：整数常量除法，在早期的版本中是被截断的，但现在可以被转为有理数了，如5/2的值为 2.5 注意：数字常量表达式，一旦其中含有常量表达式，它就会被转为一个非常量类型。下面代码中表达式的结果将会被认为是一个有理数： 12uint128 a = 1;uint128 b = 2.5 + a + 0.5; 上述代码编译不能通过，因为b会被编译器认为是小数型。 字符串常量字符串常量是指由单引号，或双引号引起来的字符串 (“foo” or ‘bar’)。字符串并不像C语言，包含结束符，”foo”这个字符串大小仅为三个字节。和整数常量一样，字符串的长度类型可以是变长的。字符串可以隐式的转换为byte1,…byte32 如果适合，也会转为bytes或string。 字符串常量支持转义字符，比如\\n，\\xNN，\\uNNNN。其中\\xNN表示16进制值，最终转换合适的字节。而\\uNNNN表示Unicode编码值，最终会转换为UTF8的序列。 十六进制常量（Hexadecimal literals）十六进制常量，以关键字hex打头，后面紧跟用单或双引号包裹的字符串，内容是十六进制字符串，如hex”001122ff”。它的值会用二进制来表示。 十六进制常量和字符串常量类似，也可以转换为字节数组。 枚举（Enums）在Solidity中，枚举可以用来自定义类型。它可以显示的转换与整数进行转换，但不能进行隐式转换。显示的转换会在运行时检查数值范围，如果不匹配，将会引起异常。枚举类型应至少有一名成员。下面是一个枚举的例子： 123456789101112131415161718192021222324pragma solidity ^0.4.0;contract test &#123; enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125; ActionChoices choice; ActionChoices constant defaultChoice = ActionChoices.GoStraight; function setGoStraight() &#123; choice = ActionChoices.GoStraight; &#125; // Since enum types are not part of the ABI, the signature of &quot;getChoice&quot; // will automatically be changed to &quot;getChoice() returns (uint8)&quot; // for all matters external to Solidity. The integer type used is just // large enough to hold all enum values, i.e. if you have more values, // `uint16` will be used and so on. function getChoice() returns (ActionChoices) &#123; return choice; &#125; function getDefaultChoice() returns (uint) &#123; return uint(defaultChoice); &#125;&#125; 代码实例通过合约代码实例说明类型的使用，请订阅区块链技术查看。 参考文档Solidity官方文档-类型","tags":[{"name":"Solidity手册","slug":"Solidity手册","permalink":"http://blog.buerya.cn/tags/Solidity手册/"}]},{"title":"Geth 控制台使用及 Web3.js 使用实战","date":"2018-02-25T05:02:22.000Z","path":"2018/02/25/geth_cmd_short/","text":"在开发以太坊去中心化应用，免不了和以太坊进行交互，那就离不开Web3。Geth 控制台（REPL）实现了所有的web3 API及Admin API，使用好 Geth 就是必修课。结合Geth命令用法阅读效果更佳。 写在前面阅读本文之前，你需要对以太坊（区块链）有初步的了解，如果你不知道以太坊是什么，请先阅读以太坊是什么。如果你在我的小专栏之外的地方阅读到本文，你可能只能阅读本文的节选，阅读完整全文请订阅小专栏区块链技术 geth控制带初探-启动、退出安装参考智能合约开发环境搭建最简单启动方式如下： 1$ geth console geth控制台启动成功之后，可以看到&gt;提示符。退出输入exit geth日志控制重定向日志到文件使用geth console启动时，会在当前交互界面下时不时出现日志。可以使用以下方式把日志输出到文件。 1$ geth console 2&gt;&gt;geth.log 可以新开一个命令行终端输入以下命令查看日志: 1$ tail -f geth.log 重定向另一个终端也可以把日志重定向到另一个终端，先在想要看日志的终端输入 1$ tty 就可以获取到终端编号，如: /dev/ttys003然后另一个终端使用: 1$ geth console 2&gt;&gt; /dev/ttys003 启动geth,这时日志就输出到另一个终端。如果不想看到日志还可以重定向到空终端： 1$ geth console 2&gt;&gt; /dev/null 日志级别控制使用–verbosity 可以控制日志级别，如不想看到日志还可以使用： 1$ geth --verbosity 0 console 启动一个开发模式测试节点1geth --datadir /home/xxx/testNet --dev console 技巧：如果我们经常使用一个方式来启动，可以把命令存为一个bash脚本。~/bin你可以放一些常用的脚本，并把~/bin加入到环境变量PATH里。 连接geth节点另外一个启动geth的方法是连接到一个geth节点： 123$ geth attach ipc:/some/custom/path$ geth attach http://191.168.1.1:8545$ geth attach ws://191.168.1.1:8546 如连接刚刚打开的开发模式节点使用： 1geth attach ipc:testNet/geth.ipc 更多内容请前往区块链技术小专栏查看全部链接。 a","tags":[{"name":"Geth使用","slug":"Geth使用","permalink":"http://blog.buerya.cn/tags/Geth使用/"},{"name":"Web3.js","slug":"Web3-js","permalink":"http://blog.buerya.cn/tags/Web3-js/"}]},{"title":"一步步教你开发、部署第一个去中心化应用(Dapp) - 宠物商店","date":"2018-02-25T05:02:22.000Z","path":"2018/02/25/first-dapp/","text":"今天我们来编写一个完整的去中心化（区块链）应用（Dapps）, 本文可以和编写智能合约结合起来看。 写在前面阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看以太坊是什么除此之外，你最好还了解一些HTML及JavaScript知识。 本文通过实例教大家来开发去中心化应用，应用效果如图： 从本文，你可以学习到： 搭建智能合约开发环境 创建Truffle项目 编写智能合约 编译和部署智能合约到区块链 如何通过Web3和智能合约交互 MetaMask的使用 项目背景Pete有一个宠物店，有16只宠物，他想开发一个去中心化应用，让大家来领养宠物。在truffle box中，已经提供了pet-shop的网站部分代码，我们只需要编写合约及交互部分。 环境搭建 安装Node 安装Truffle: npm install -g truffle 安装Ganache Ganache(或Ganache CLI) 已经取代了testrpc 创建项目 创建项目目录并进入 12&gt; mkdir pet-shop-tutorial&gt; cd pet-shop-tutorial 使用truffle unbox 创建项目 123456789101112 &gt; truffle unbox pet-shop Downloading... Unpacking... Setting up... Unbox successful. Sweet!Commands: Compile: truffle compile Migrate: truffle migrate Test contracts: truffle test Run dev server: npm run dev 这一步需要等待一会 也可以使用truffle init 来创建一个全新的项目。 项目目录结构contracts/ 智能合约的文件夹，所有的智能合约文件都放置在这里，里面包含一个重要的合约Migrations.sol（稍后再讲）migrations/ 用来处理部署（迁移）智能合约 ，迁移是一个额外特别的合约用来保存合约的变化。test/ 智能合约测试用例文件夹truffle.js/ 配置文件 其他代码可以暂时不用管 编写智能合约智能合约承担着分布式应用的后台逻辑和存储。智能合约使用solidity编写，可阅读solidity系列文章 在contracts目录下，添加合约文件Adoption.sol 1234567891011121314151617181920pragma solidity ^0.4.17;contract Adoption &#123; address[16] public adopters; // 保存领养者的地址 // 领养宠物 function adopt(uint petId) public returns (uint) &#123; require(petId &gt;= 0 &amp;&amp; petId &lt;= 15); // 确保id在数组长度内 adopters[petId] = msg.sender; // 保存调用这地址 return petId; &#125; // 返回领养者 function getAdopters() public view returns (address[16]) &#123; return adopters; &#125;&#125; 编译部署智能合约Truffle集成了一个开发者控制台，可用来生成一个开发链用来测试和部署智能合约。 编译Solidity是编译型语言，需要把可读的Solidity代码编译为EVM字节码才能运行。dapp的根目录pet-shop-tutorial下， 1&gt; truffle compile 输出 12Compiling ./contracts/Adoption.sol...Writing artifacts to ./build/contracts 部署编译之后，就可以部署到区块链上。在migrations文件夹下已经有一个1_initial_migration.js部署脚本，用来部署Migrations.sol合约。Migrations.sol 用来确保不会部署相同的合约。 现在我们来创建一个自己的部署脚本2_deploy_contracts.js 12345var Adoption = artifacts.require(&quot;Adoption&quot;);module.exports = function(deployer) &#123; deployer.deploy(Adoption);&#125;; 在执行部署之前，需要确保有一个区块链运行, 可以使用Ganache来开启一个私链来进行开发测试，默认会在7545端口上运行一个开发链。Ganache 启动之后是这样： 接下来执行部署命令: 1&gt; truffle migrate 执行后，有以下类似输出： 12345678910111213141516Using network &apos;develop&apos;.Running migration: 1_initial_migration.js Deploying Migrations... ... 0x3076b7dac65afc44ec51508bf6f2b6894f833f0f9560ecad2d6d41ed98a4679f Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0Saving successful migration to network... ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956Saving artifacts...Running migration: 2_deploy_contracts.js Deploying Adoption... ... 0x2c6ab4471c225b5473f2079ee42ca1356007e51d5bb57eb80bfeb406acc35cd4 Adoption: 0x345ca3e014aaf5dca488057592ee47305d9b3e10Saving successful migration to network... ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0Saving artifacts... 在打开的Ganache里可以看到区块链状态的变化，现在产生了4个区块。 这时说明已经智能合约已经部署好了。 测试现在我们来测试一下智能合约，测试用例可以用 JavaScript or Solidity来编写，这里使用Solidity。 在test目录下新建一个TestAdoption.sol，编写测试合约 12345678910111213141516171819202122232425262728293031323334pragma solidity ^0.4.17;import &quot;truffle/Assert.sol&quot;; // 引入的断言import &quot;truffle/DeployedAddresses.sol&quot;; // 用来获取被测试合约的地址import &quot;../contracts/Adoption.sol&quot;; // 被测试合约contract TestAdoption &#123; Adoption adoption = Adoption(DeployedAddresses.Adoption()); // 领养测试用例 function testUserCanAdoptPet() public &#123; uint returnedId = adoption.adopt(8); uint expected = 8; Assert.equal(returnedId, expected, &quot;Adoption of pet ID 8 should be recorded.&quot;); &#125; // 宠物所有者测试用例 function testGetAdopterAddressByPetId() public &#123; // 期望领养者的地址就是本合约地址，因为交易是由测试合约发起交易， address expected = this; address adopter = adoption.adopters(8); Assert.equal(adopter, expected, &quot;Owner of pet ID 8 should be recorded.&quot;); &#125; // 测试所有领养者 function testGetAdopterAddressByPetIdInArray() public &#123; // 领养者的地址就是本合约地址 address expected = this; address[16] memory adopters = adoption.getAdopters(); Assert.equal(adopters[8], expected, &quot;Owner of pet ID 8 should be recorded.&quot;); &#125;&#125; Assert.sol 及 DeployedAddresses.sol是Truffle框架提供，在test目录下并不提供truffle目录。 TestAdoption合约中添加adopt的测试用例 运行测试用例在终端中，执行 1truffle test 如果测试通过，则终端输出： 123456789101112131415Using network &apos;develop&apos;.Compiling ./contracts/Adoption.sol...Compiling ./test/TestAdoption.sol...Compiling truffle/Assert.sol...Compiling truffle/DeployedAddresses.sol... TestAdoption ✓ testUserCanAdoptPet (62ms) ✓ testGetAdopterAddressByPetId (53ms) ✓ testGetAdopterAddressByPetIdInArray (73ms) 3 passing (554ms) 创建用户接口和智能合约交互我们已经编写和部署及测试好了我们的合约，接下我们为合约编写UI，让合约真正可以用起来。 在Truffle Box pet-shop里，已经包含了应用的前端代码，代码在src/文件夹下。 在编辑器中打开src/js/app.js可以看到用来管理整个应用的App对象，init函数加载宠物信息，就初始化web3.web3是一个实现了与以太坊节点通信的库，我们利用web3来和合约进行交互。 初始化web3接下来，我们来编辑app.js修改initWeb3():删除注释，修改为： 123456789101112initWeb3: function() &#123; // Is there an injected web3 instance? if (typeof web3 !== &apos;undefined&apos;) &#123; App.web3Provider = web3.currentProvider; &#125; else &#123; // If no injected web3 instance is detected, fall back to Ganache App.web3Provider = new Web3.providers.HttpProvider(&apos;http://localhost:7545&apos;); &#125; web3 = new Web3(App.web3Provider); return App.initContract();&#125; 代码中优先使用Mist或MetaMask提供的web3实例，如果没有则从本地环境创建一个。 实例化合约使用truffle-contract会帮我们保存合约部署的信息，就不需要我们手动修改合约地址，修改initContract()代码如下： 123456789101112131415initContract: function() &#123; // 加载Adoption.json，保存了Adoption的ABI（接口说明）信息及部署后的网络(地址)信息，它在编译合约的时候生成ABI，在部署的时候追加网络信息 $.getJSON(&apos;Adoption.json&apos;, function(data) &#123; // 用Adoption.json数据创建一个可交互的TruffleContract合约实例。 var AdoptionArtifact = data; App.contracts.Adoption = TruffleContract(AdoptionArtifact); // Set the provider for our contract App.contracts.Adoption.setProvider(App.web3Provider); // Use our contract to retrieve and mark the adopted pets return App.markAdopted(); &#125;); return App.bindEvents();&#125; 处理领养修改markAdopted()代码： 123456789101112131415161718markAdopted: function(adopters, account) &#123; var adoptionInstance; App.contracts.Adoption.deployed().then(function(instance) &#123; adoptionInstance = instance; // 调用合约的getAdopters(), 用call读取信息不用消耗gas return adoptionInstance.getAdopters.call(); &#125;).then(function(adopters) &#123; for (i = 0; i &lt; adopters.length; i++) &#123; if (adopters[i] !== &apos;0x0000000000000000000000000000000000000000&apos;) &#123; $(&apos;.panel-pet&apos;).eq(i).find(&apos;button&apos;).text(&apos;Success&apos;).attr(&apos;disabled&apos;, true); &#125; &#125; &#125;).catch(function(err) &#123; console.log(err.message); &#125;);&#125; 修改handleAdopt()代码： 123456789101112131415161718192021222324252627handleAdopt: function(event) &#123; event.preventDefault(); var petId = parseInt($(event.target).data(&apos;id&apos;)); var adoptionInstance; // 获取用户账号 web3.eth.getAccounts(function(error, accounts) &#123; if (error) &#123; console.log(error); &#125; var account = accounts[0]; App.contracts.Adoption.deployed().then(function(instance) &#123; adoptionInstance = instance; // 发送交易领养宠物 return adoptionInstance.adopt(petId, &#123;from: account&#125;); &#125;).then(function(result) &#123; return App.markAdopted(); &#125;).catch(function(err) &#123; console.log(err.message); &#125;); &#125;);&#125; 在浏览器里运行安装 MetaMaskMetaMask 是一款插件形式的以太坊轻客户端，开发过程中使用MetaMask和我们的dapp进行交互是个很好的选择，通过此链接安装，安装完成后，浏览器工具条会显示一个小狐狸图标。 配置钱包在接受隐私说明后，会出现页面如下： 这里我们通过还原一个Ganache为我们创建好的钱包，作为我们的开发测试钱包。点击页面的Import Existing DEN ，输入Ganache显示的助记词。 1candy maple cake sugar pudding cream honey rich smooth crumble sweet treat 然后自己想要的密码，点击OK。如图： 链接开发区块链网络默认连接的是以太坊主网（左上角显示），选择Custom RPC，添加一个网络：http://127.0.0.1:7545 ，点返回后，显示如下： 这是左上角显示为Private Network ，账号是Ganache中默认的第一个账号。 至此MetaMask的安装，配置已经完成。 安装和配置lite-server接下来需要本地的web 服务器提供服务的访问， Truffle Box pet-shop里提供了一个lite-server可以直接使用，我们看看它是如何工作的。bs-config.json指示了lite-server的工作目录。 12345&#123; \"server\": &#123; \"baseDir\": [\"./src\", \"./build/contracts\"] &#125;&#125; ./src 是网站文件目录./build/contracts 是合约输出目录 以此同时，在package.json文件的scripts中添加了dev命令： 1234\"scripts\": &#123; \"dev\": \"lite-server\", \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"&#125;, 当运行npm run dev的时候，就会启动lite-server 启动服务1&gt; npm run dev 会自动打开浏览器显示我们的dapp，如本文的第一张图。现在领养一直宠物看看，当我们点击Adopt时，MetaMask 会提示我们交易的确认，如图： 点击Submit确认后，就可以看到成功领养了这次宠物。 在MetaMask中，也可以看到交易的清单： 好了，恭喜你，即将成为一名去中心化式应用开发者的你已经成为迈出了坚实的一步。 参考文档Truffle手册","tags":[{"name":"Dapp入门","slug":"Dapp入门","permalink":"http://blog.buerya.cn/tags/Dapp入门/"},{"name":"以太坊概念","slug":"以太坊概念","permalink":"http://blog.buerya.cn/tags/以太坊概念/"}]},{"title":"以太坊客户端Geth命令用法-参数详解","date":"2018-02-23T16:00:00.000Z","path":"2018/02/24/geth_cmd_options/","text":"Geth在以太坊智能合约开发中最常用的工具（必备开发工具），一个多用途的命令行工具。熟悉Geth可以让我们有更好的效率，大家可收藏起来作为Geth命令用法手册。 本文主要是对geth help的翻译，基于最新的geth 1.7.3-stable版本。 如果你还不知道geth是什么，请先阅读入门篇：以太坊是什么。更多geth实战使用方法请参考Geth控制台使用实战及Web3.js使用以下开始正文。 命令用法1geth [选项] 命令 [命令选项] [参数…] 版本11.7.3-stable 命令12345678910111213141516171819account 管理账户attach 启动交互式JavaScript环境（连接到节点）bug 上报bug Issuesconsole 启动交互式JavaScript环境copydb 从文件夹创建本地链dump Dump（分析）一个特定的块存储dumpconfig 显示配置值export 导出区块链到文件import 导入一个区块链文件init 启动并初始化一个新的创世纪块js 执行指定的JavaScript文件(多个)license 显示许可信息makecache 生成ethash验证缓存(用于测试)makedag 生成ethash 挖矿DAG(用于测试)monitor 监控和可视化节点指标removedb 删除区块链和状态数据库version 打印版本号wallet 管理Ethereum预售钱包help,h 显示一个命令或帮助一个命令列表 ETHEREUM选项:12345678910111213--config value TOML 配置文件--datadir “xxx” 数据库和keystore密钥的数据目录--keystore keystore存放目录(默认在datadir内)--nousb 禁用监控和管理USB硬件钱包--networkid value 网络标识符(整型, 1=Frontier, 2=Morden (弃用), 3=Ropsten, 4=Rinkeby) (默认: 1)--testnet Ropsten网络:预先配置的POW(proof-of-work)测试网络--rinkeby Rinkeby网络: 预先配置的POA(proof-of-authority)测试网络--syncmode &quot;fast&quot; 同步模式 (&quot;fast&quot;, &quot;full&quot;, or &quot;light&quot;)--ethstats value 上报ethstats service URL (nodename:secret@host:port)--identity value 自定义节点名--lightserv value 允许LES请求时间最大百分比(0 – 90)(默认值:0)--lightpeers value 最大LES client peers数量(默认值:20)--lightkdf 在KDF强度消费时降低key-derivation RAM&amp;CPU使用 开发者（模式）选项:12--dev 使用POA共识网络，默认预分配一个开发者账户并且会自动开启挖矿。--dev.period value 开发者模式下挖矿周期 (0 = 仅在交易时) (默认: 0) ETHASH选项123456--ethash.cachedir ethash验证缓存目录(默认 = datadir目录内)--ethash.cachesinmem value 在内存保存的最近的ethash缓存个数 (每个缓存16MB ) (默认: 2)--ethash.cachesondisk value 在磁盘保存的最近的ethash缓存个数 (每个缓存16MB) (默认: 3)--ethash.dagdir &quot;&quot; 存ethash DAGs目录 (默认 = 用户hom目录)--ethash.dagsinmem value 在内存保存的最近的ethash DAGs 个数 (每个1GB以上) (默认: 1)--ethash.dagsondisk value 在磁盘保存的最近的ethash DAGs 个数 (每个1GB以上) (默认: 2) 交易池选项12345678910--txpool.nolocals 为本地提交交易禁用价格豁免--txpool.journal value 本地交易的磁盘日志：用于节点重启 (默认: &quot;transactions.rlp&quot;)--txpool.rejournal value 重新生成本地交易日志的时间间隔 (默认: 1小时)--txpool.pricelimit value 加入交易池的最小的gas价格限制(默认: 1)--txpool.pricebump value 价格波动百分比（相对之前已有交易） (默认: 10)--txpool.accountslots value 每个帐户保证可执行的最少交易槽数量 (默认: 16)--txpool.globalslots value 所有帐户可执行的最大交易槽数量 (默认: 4096)--txpool.accountqueue value 每个帐户允许的最多非可执行交易槽数量 (默认: 64)--txpool.globalqueue value 所有帐户非可执行交易最大槽数量 (默认: 1024)--txpool.lifetime value 非可执行交易最大入队时间(默认: 3小时) 性能调优选项12--cache value 分配给内部缓存的内存MB数量，缓存值(最低16 mb /数据库强制要求)(默认:128)--trie-cache-gens value 保持在内存中产生的trie node数量(默认:120) 帐户选项12--unlock value 需解锁账户用逗号分隔--password value 用于非交互式密码输入的密码文件 API和控制台选项:123456789101112131415--rpc 启用HTTP-RPC服务器--rpcaddr value HTTP-RPC服务器接口地址(默认值:“localhost”)--rpcport value HTTP-RPC服务器监听端口(默认值:8545)--rpcapi value 基于HTTP-RPC接口提供的API--ws 启用WS-RPC服务器--wsaddr value WS-RPC服务器监听接口地址(默认值:“localhost”)--wsport value WS-RPC服务器监听端口(默认值:8546)--wsapi value 基于WS-RPC的接口提供的API--wsorigins value websockets请求允许的源--ipcdisable 禁用IPC-RPC服务器--ipcpath 包含在datadir里的IPC socket/pipe文件名(转义过的显式路径)--rpccorsdomain value 允许跨域请求的域名列表(逗号分隔)(浏览器强制)--jspath loadScript JavaScript加载脚本的根路径(默认值:“.”)--exec value 执行JavaScript语句(只能结合console/attach使用)--preload value 预加载到控制台的JavaScript文件列表(逗号分隔) 网络选项1234567891011--bootnodes value 用于P2P发现引导的enode urls(逗号分隔)(对于light servers用v4+v5代替)--bootnodesv4 value 用于P2P v4发现引导的enode urls(逗号分隔) (light server, 全节点)--bootnodesv5 value 用于P2P v5发现引导的enode urls(逗号分隔) (light server, 轻节点)--port value 网卡监听端口(默认值:30303)--maxpeers value 最大的网络节点数量(如果设置为0，网络将被禁用)(默认值:25)--maxpendpeers value 最大尝试连接的数量(如果设置为0，则将使用默认值)(默认值:0)--nat value NAT端口映射机制 (any|none|upnp|pmp|extip:&lt;IP&gt;) (默认: “any”)--nodiscover 禁用节点发现机制(手动添加节点)--v5disc 启用实验性的RLPx V5(Topic发现)机制--nodekey value P2P节点密钥文件--nodekeyhex value 十六进制的P2P节点密钥(用于测试) 矿工选项123456--mine 打开挖矿--minerthreads value 挖矿使用的CPU线程数量(默认值:8)--etherbase value 挖矿奖励地址(默认=第一个创建的帐户)(默认值:“0”)--targetgaslimit value 目标gas限制：设置最低gas限制（低于这个不会被挖？） (默认值:“4712388”)--gasprice value 挖矿接受交易的最低gas价格--extradata value 矿工设置的额外块数据(默认=client version) GAS价格选项12--gpoblocks value 用于检查gas价格的最近块的个数 (默认: 10)--gpopercentile value 建议gas价参考最近交易的gas价的百分位数，(默认: 50) 虚拟机选项1--vmdebug 记录VM及合约调试信息 日志和调试选项12345678910111213--metrics 启用metrics收集和报告--fakepow 禁用proof-of-work验证--verbosity value 日志详细度:0=silent, 1=error, 2=warn, 3=info, 4=debug, 5=detail (default: 3)--vmodule value 每个模块详细度:以 &lt;pattern&gt;=&lt;level&gt;的逗号分隔列表 (比如 eth/*=6,p2p=5)--backtrace value 请求特定日志记录堆栈跟踪 (比如 “block.go:271”)--debug 突出显示调用位置日志(文件名及行号)--pprof 启用pprof HTTP服务器--pprofaddr value pprof HTTP服务器监听接口(默认值:127.0.0.1)--pprofport value pprof HTTP服务器监听端口(默认值:6060)--memprofilerate value 按指定频率打开memory profiling (默认:524288)--blockprofilerate value 按指定频率打开block profiling (默认值:0)--cpuprofile value 将CPU profile写入指定文件--trace value 将execution trace写入指定文件 WHISPER实验选项123--shh 启用Whisper--shh.maxmessagesize value 可接受的最大的消息大小 (默认值: 1048576)--shh.pow value 可接受的最小的POW (默认值: 0.2) 弃用选项12--fast 开启快速同步--light 启用轻客户端模式 其他选项1–help, -h 显示帮助 版权1Copyright 2013-2017 The go-ethereum Authors 翻译说明有些参数翻译可能有不准确的地方，请大家指正。","tags":[{"name":"Geth命令用法","slug":"Geth命令用法","permalink":"http://blog.buerya.cn/tags/Geth命令用法/"},{"name":"Geth命令参数详解","slug":"Geth命令参数详解","permalink":"http://blog.buerya.cn/tags/Geth命令参数详解/"},{"name":"Geth手册","slug":"Geth手册","permalink":"http://blog.buerya.cn/tags/Geth手册/"}]},{"title":"智能合约开发环境搭建及Hello World合约","date":"2018-02-23T16:00:00.000Z","path":"2018/02/24/init-env/","text":"如果你对于以太坊智能合约开发还没有概念（本文会假设你已经知道这些概念），建议先阅读入门篇。就先学习任何编程语言一样，入门的第一个程序都是Hello World。今天我们来一步一步从搭建以太坊智能合约开发环境开始，讲解智能合约的Hello World如何编写。 开发环境搭建Solodity安装强烈建议新手使用Browser-Solidity来进行开发。Browser-Solidity是一个基于浏览器的Solidity，就可以不用安装Solidity，本文的Hello World教程也将基于Browser-Solidity来进行。 如果你想自己安装请参考Solidity安装指引。 geth 安装Ubuntu下安装命令如下：其他平台参考：geth官方安装指引 1234sudo apt-get install software-properties-commonsudo add-apt-repository -y ppa:ethereum/ethereumsudo apt-get updatesudo apt-get install ethereum 安装完以后，就是把geth控制台启动。 启动环境在入门篇讲过，geth是一个以太坊客户端，现在利用geth\b启动一个以太坊（开发者）网络节点。 1geth --datadir testNet --dev console 2&gt;&gt; test.log 执行命名后，会进入geth控制台，这时光标停在一个向右的箭头处，像这样： 命令参数说明（更多命令详解可阅读Geth命令用法-参数详解篇）:–dev 启用开发者网络（模式），开发者网络会使用POA共识，默认预分配一个开发者账户并且会自动开启挖矿。–datadir 后面的参数是区块数据及秘钥存放目录。第一次输入命令后，它会放在当前目录下新建一个testNet目录来存放数据。console 进入控制台2&gt;&gt; test.log 表示把控制台日志输出到test.log文件 为了更好的理解，建议新开一个命令行终端，实时显示日志： 1tail -f test.log 准备账户部署智能合约需要一个外部账户，我们先来看看分配的开发者账户，在控制台使用以下命令查看账户： 1&gt; eth.accounts 回车后，返回一个账户数组，里面有一个默认账户，如： 也可以使用personal.listAccounts查看账户， 再来看一下账户里的余额，使用一下命令： 1&gt; eth.getBalance(eth.accounts[0]) eth.accounts[0] 表示账户列表第一个账户回车后，可以看到大量的余额，如：1.15792089237316195423570985008687907853269… e+77 开发者账户因余额太多，如果用这个账户来部署合约时会无法看到余额变化，为了更好的体验完整的过程，这里选择创建一个新的账户。 创建账户使用以下命令创建账户： 1&gt; personal.newAccount(&quot;Juan&quot;) Juan为新账户的密码，回车后，返回一个新账户。 这时我们查看账户列表： 1&gt; eth.accounts 可以看到账户数组你包含两个账户，新账户在第二个（索引为1）位置。 现在看看账户的余额： 12&gt; eth.getBalance(eth.accounts[1])0 回车后，返回的是0，新账户是0。结果如： 给新账户转账我们知道没有余额的账户是没法部署合约的，那我们就从默认账户转1以太币给新账户，使用以下命令（请使用你自己eth.accounts对应输出的账户）： 1eth.sendTransaction(&#123;from: &apos;0xb0ebe17ef0e96b5c525709c0a1ede347c66bd391&apos;, to: &apos;0xf280facfd60d61f6fd3f88c9dee4fb90d0e11dfc&apos;, value: web3.toWei(1, &quot;ether&quot;)&#125;) 在打开的tail -f test.log日志终端里，可以同时看到挖矿记录再次查看新账户余额，可以新账户有1个以太币 解锁账户在部署合约前需要先解锁账户（就像银行转账要输入密码一样），使用以下命令： 1personal.unlockAccount(eth.accounts[1],&quot;Juan&quot;); “Juan”是之前创建账户时的密码。解锁成功后，账户就准备完毕啦，接下来就是编写合约代码。 编写合约代码现在我们来开始编写第一个智能合约代码，solidity代码如下： 123456789101112pragma solidity ^0.4.18;contract hello &#123; string greeting; function hello(string _greeting) public &#123; greeting = _greeting; &#125; function say() constant public returns (string) &#123; return greeting; &#125;&#125; 简单解释下，我们定义了一个名为hello的合约，在合约初始化时保存了一个字符串（我们会传入hello world），每次调用say返回字符串。把这段代码写(拷贝)到Browser-Solidity，如果没有错误，点击Details获取部署代码，如： 在弹出的对话框中找到WEB3DEPLOY部分，点拷贝，粘贴到编辑器后，修改初始化字符串为hello world。 solidity版本之间有可能不能兼容，这是你可以在Browser-Solidity的Settings里选择对应的编译器版本。Browser-Solidity也不停的更新中，截图可能和你看到的界面不一样。 部署合约Browser-Solidity生成的代码，拷贝到编辑器里修改后的代码如下： 1234567891011121314var _greeting = &quot;Hello World&quot; ;var helloContract = web3.eth.contract([&#123;&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;say&quot;,&quot;outputs&quot;:[&#123;&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;string&quot;&#125;],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[&#123;&quot;name&quot;:&quot;_greeting&quot;,&quot;type&quot;:&quot;string&quot;&#125;],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;constructor&quot;&#125;]);var hello = helloContract.new( _greeting, &#123; from: web3.eth.accounts[1], data: &apos;0x6060604052341561000f57600080fd5b6040516102b83803806102b8833981016040528080518201919050508060009080519060200190610041929190610048565b50506100ed565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061008957805160ff19168380011785556100b7565b828001600101855582156100b7579182015b828111156100b657825182559160200191906001019061009b565b5b5090506100c491906100c8565b5090565b6100ea91905b808211156100e65760008160009055506001016100ce565b5090565b90565b6101bc806100fc6000396000f300606060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063954ab4b214610046575b600080fd5b341561005157600080fd5b6100596100d4565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561009957808201518184015260208101905061007e565b50505050905090810190601f1680156100c65780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6100dc61017c565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156101725780601f1061014757610100808354040283529160200191610172565b820191906000526020600020905b81548152906001019060200180831161015557829003601f168201915b5050505050905090565b6020604051908101604052806000815250905600a165627a7a723058204a5577bb3ad30e02f7a3bdd90eedcc682700d67fc8ed6604d38bb739c0655df90029&apos;, gas: &apos;4700000&apos; &#125;, function (e, contract)&#123; console.log(e, contract); if (typeof contract.address !== &apos;undefined&apos;) &#123; console.log(&apos;Contract mined! address: &apos; + contract.address + &apos; transactionHash: &apos; + contract.transactionHash); &#125; &#125;); 第1行：修改字符串为Hello World第2行：修改合约变量名第3行：修改合约实例变量名，之后可以直接用实例调用函数。第6行：修改部署账户为新账户索引，即使用新账户来部署合约。第8行：准备付的gas费用，IDE已经帮我们预估好了。第9行：设置部署回调函数。 拷贝回geth控制台里，回车后，看到输出如： 1Contract mined! address: 0x79544078dcd9d560ec3f6eff0af42a9fc84c7d19 transactionHash: 0xe2caab22102e93434888a0b8013a7ae7e804b132e4a8bfd2318356f6cf0480b3 说明合约已经部署成功。 在打开的 tail -f test.log 日志终端里，可以同时看到挖矿记录 现在我们查看下新账户的余额： 1&gt; eth.getBalance(eth.accounts[1]) 运行合约12&gt; hello.say()&quot;Hello World&quot; 输出Hello World，我们第一个合约Hello World，成功运行了。 运行截图如下： 本文会随geth，solidity语言版本升级保持更新，查看本文原始链接：https://learnblockchain.cn/2017/11/24/init-env/ 第一个合约的意义更重要的是体验智能合约开发流程，对于初学者一些可以选择先放弃一些细节，开发流程打通之后，可以增强信心进行下一步的学习。","tags":[{"name":"环境","slug":"环境","permalink":"http://blog.buerya.cn/tags/环境/"},{"name":"geth安装","slug":"geth安装","permalink":"http://blog.buerya.cn/tags/geth安装/"},{"name":"第一个智能合约","slug":"第一个智能合约","permalink":"http://blog.buerya.cn/tags/第一个智能合约/"}]},{"title":"以太坊是什么 - 以太坊开发入门指南","date":"2018-02-22T05:02:22.000Z","path":"2018/02/22/whatiseth/","text":"很多同学已经跃跃欲试投入到区块链开发队伍当中来，可是又感觉无从下手，本文将基于以太坊平台，以通俗的方式介绍以太坊开发中涉及的各晦涩的概念，轻松带大家入门。 写在前面的话阅读本文前，你应该大概了解区块链是什么，如果你还不了解，欢迎订阅专栏：区块链技术指引你从头开始学区块链技术。 以太坊是什么以太坊（Ethereum）是一个建立在区块链技术之上， 去中心化应用平台。它允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。 对这句话不理解的同学，姑且可以理解为以太坊是区块链里的Android，它是一个开发平台，让我们就可以像基于Android Framework一样基于区块链技术写应用。 在没有以太坊之前，写区块链应用是这样的：拷贝一份比特币代码，然后去改底层代码如加密算法，共识机制，网络协议等等（很多山寨币就是这样，改改就出来一个新币）。以太坊平台对底层区块链技术进行了封装，让区块链应用开发者可以直接基于以太坊平台进行开发，开发者只要专注于应用本身的开发，从而大大降低了难度。 目前围绕以太坊已经形成了一个较为完善的开发生态圈：有社区的支持，有很多开发框架、工具可以选择。 智能合约什么是智能合约以太坊上的程序称之为智能合约， 它是代码和数据(状态)的集合。 智能合约可以理解为在区块链上可以自动执行的（由消息驱动的）、以代码形式编写的合同（特殊的交易）。 智能合约英文是Smart Contract，和人工智能（ AI:Artificial Intelligence ）的智能没有关系，最早尼克萨博在95年就提出智能合约的概念，它的概念很简单，就是将法律条文写成可执行代码。当时并没有区块链，不过智能合约与区块链最配，我们知道合同都是要一式两份、三或四份，不能控制在某一方手中，这也就是去中心化。 在比特币脚本中，我们讲到过比特币的交易是可以编程的，但是比特币脚本有很多的限制，能够编写的程序也有限，而以太坊则更加完备（在计算机科学术语中，称它为是“图灵完备的”），让我们就像使用任何高级语言一样来编写几乎可以做任何事情的程序（智能合约）。 智能合约非常适合对信任、安全和持久性要求较高的应用场景，比如：数字货币、数字资产、投票、保险、金融应用、预测市场、产权所有权管理、物联网、点对点交易等等。目前除数字货币之外，真正落地的应用还不多（就像移动平台刚开始出来一样），相信1到3年内，各种杀手级会慢慢出现。 编程语言：Solidity智能合约的官方推荐的编程语言是Solidity，文件扩展名以.sol结尾。Solidity语言和JavaScript很相似，用它来开发合约并编译成以太坊虚拟机字节代码。 还有Viper，Serpent，LLL及Bamboo，建议大家还是使用Solidity。更新：Serpent官方已经不再推荐，建议Serpent的用户转换到Viper，他们都是类Python语言。 Browser-Solidity是一个浏览器的Solidity IDE, 大家可以点进去看看，以后我们更多文章介绍Solidity这个语言。 运行环境：EVMEVM（Ethereum Virtual Machine）以太坊虚拟机是以太坊中智能合约的运行环境。 Solidity之于EVM，就像之于跟JVM的关系一样，这样大家就容易理解了。以太坊虚拟机是一个隔离的环境，外部无法接触到在EVM内部运行的代码。 而EVM运行在以太坊节点上，当我们把合约部署到以太坊网络上之后，合约就可以在以太坊网络中运行了。 合约的编译以太坊虚拟机上运行的是合约的字节码形式，需要我们在部署之前先对合约进行编译，可以选择Browser-Solidity Web IDE或solc编译器。 合约的部署在以太坊上开发应用时，常常要使用到以太坊客户端（钱包）。平时我们在开发中，一般不接触到客户端或钱包的概念，它是什么呢？ 以太坊客户端（钱包）以太坊客户端，其实我们可以把它理解为一个开发者工具，它提供账户管理、挖矿、转账、智能合约的部署和执行等等功能。 EVM是由以太坊客户端提供的 Geth 是典型的开发以太坊时使用的客户端，基于Go语言开发。 Geth提供了一个交互式命令控制台，通过命令控制台中包含了以太坊的各种功能（API）。Geth的使用我们之后会有文章介绍，这里大家先有个概念。 Geth控制台和Chrome浏览器开发者工具里的面的控制台是类似的，不过Geth控制台是跑在终端里。相对于Geth，Mist则是图形化操作界面的以太坊客户端。 如何部署智能合约的部署是指把合约字节码发布到区块链上，并使用一个特定的地址来标示这个合约，这个地址称为合约账户。 以太坊中有两类账户： 外部账户该类账户被私钥控制（由人控制），没有关联任何代码。 合约账户该类账户被它们的合约代码控制且有代码与之关联。 和比特币使用UTXO的设计不一样，以太坊使用更为简单的账户概念。两类账户对于EVM来说是一样的。外部账户与合约账户的区别和关系是这样的：一个外部账户可以通过创建和用自己的私钥来对交易进行签名，来发送消息给另一个外部账户或合约账户。在两个外部账户之间传送消息是价值转移的过程。但从外部账户到合约账户的消息会激活合约账户的代码，允许它执行各种动作（比如转移代币，写入内部存储，挖出一个新代币，执行一些运算，创建一个新的合约等等）。只有当外部账户发出指令时，合同账户才会执行相应的操作。 合约部署就是将编译好的合约字节码通过外部账号发送交易的形式部署到以太坊区块链上（由实际矿工出块之后，才真正部署成功）。 运行合约部署之后，当需要调用这个智能合约的方法时只需要向这个合约账户发送消息（交易）即可，通过消息触发后智能合约的代码就会在EVM中执行了。 Gas和云计算相似，占用区块链的资源（不管是简单的转账交易，还是合约的部署和执行）同样需要付出相应的费用（天下没有免费的午餐对不对!）。以太坊上用Gas机制来计费，Gas也可以认为是一个工作量单位，智能合约越复杂（计算步骤的数量和类型，占用的内存等），用来完成运行就需要越多Gas。任何特定的合约所需的运行合约的Gas数量是固定的，由合约的复杂度决定。而Gas价格由运行合约的人在提交运行合约请求的时候规定，以确定他愿意为这次交易愿意付出的费用：Gas价格（用以太币计价） * Gas数量。 Gas的目的是限制执行交易所需的工作量，同时为执行支付费用。当EVM执行交易时，Gas将按照特定规则被逐渐消耗，无论执行到什么位置，一旦Gas被耗尽，将会触发异常。当前调用帧所做的所有状态修改都将被回滚， 如果执行结束还有Gas剩余，这些Gas将被返还给发送账户。 如果没有这个限制，就会有人写出无法停止（如：死循环）的合约来阻塞网络。 因此实际上（把前面的内容串起来），我们需要一个有以太币余额的外部账户，来发起一个交易（普通交易或部署、运行一个合约），运行时，矿工收取相应的工作量费用。 以太坊网络有些着急的同学要问了，没有以太币，要怎么进行智能合约的开发？可以选择以下方式： 选择以太坊官网测试网络Testnet测试网络中，我们可以很容易获得免费的以太币，缺点是需要发很长时间初始化节点。 使用私有链创建自己的以太币私有测试网络，通常也称为私有链，我们可以用它来作为一个测试环境来开发、调试和测试智能合约。通过上面提到的Geth很容易就可以创建一个属于自己的测试网络，以太币想挖多少挖多少，也免去了同步正式网络的整个区块链数据。 使用开发者网络(模式)相比私有链，开发者网络(模式)下，会自动分配一个有大量余额的开发者账户给我们使用。 使用模拟环境另一个创建测试网络的方法是使用testrpc，testrpc是在本地使用内存模拟的一个以太坊环境，对于开发调试来说，更方便快捷。而且testrpc可以在启动时帮我们创建10个存有资金的测试账户。进行合约开发时，可以在testrpc中测试通过后，再部署到Geth节点中去。 更新：testrpc 现在已经并入到Truffle 开发框架中，现在名字是Ganache CLI。 Dapp:去中心化的应用程序以太坊社区把基于智能合约的应用称为去中心化的应用程序(Decentralized App)。如果我们把区块链理解为一个不可篡改的数据库，智能合约理解为和数据库打交道的程序，那就很容易理解Dapp了，一个Dapp不单单有智能合约，比如还需要有一个友好的用户界面和其他的东西。 TruffleTruffle是Dapp开发框架，他可以帮我们处理掉大量无关紧要的小事情，让我们可以迅速开始写代码-编译-部署-测试-打包DApp这个流程。 总结我们现在来总结一下，以太坊是平台，它让我们方便的使用区块链技术开发去中心化的应用，在这个应用中，使用Solidity来编写和区块链交互的智能合约，合约编写好后之后，我们需要用以太坊客户端用一个有余额的账户去部署及运行合约（使用Truffle框架可以更好的帮助我们做这些事情了）。为了开发方便，我们可以用Geth或testrpc来搭建一个测试网络。 注：本文中为了方便大家理解，对一些概念做了类比，有些严格来不是准确，不过我也认为对于初学者，也没有必要把每一个概念掌握的很细致和准确，学习是一个逐步深入的过程，很多时候我们会发现，过一段后，我们会对同一个东西有不一样的理解。 本文完，这些概念你都明白了么？现在你可以开始开发了，看看智能合约开发环境搭建及Hello World合约","tags":[{"name":"以太坊概念","slug":"以太坊概念","permalink":"http://blog.buerya.cn/tags/以太坊概念/"},{"name":"ethereum","slug":"ethereum","permalink":"http://blog.buerya.cn/tags/ethereum/"},{"name":"以太坊入门","slug":"以太坊入门","permalink":"http://blog.buerya.cn/tags/以太坊入门/"}]},{"title":"什么是拜占庭将军问题","date":"2018-02-16T16:00:00.000Z","path":"2018/02/17/bitcoin-byzantine/","text":"接触区块链的同学，多少都听说过拜占庭将军问题，经常看到或听到某某区块链使用某某算法解决了拜占庭将军问题，那么究竟什么是拜占庭将军问题呢? 什么是拜占庭将军问题也被称为“拜占庭容错”、“拜占庭将军问题”。拜占庭将军问题是Leslie Lamport（2013年的图灵讲得住）用来为描述分布式系统一致性问题（Distributed Consensus）在论文中抽象出来一个著名的例子。 这个例子大意是这样的： 拜占庭帝国想要进攻一个强大的敌人，为此派出了10支军队去包围这个敌人。这个敌人虽不比拜占庭帝国，但也足以抵御5支常规拜占庭军队的同时袭击。这10支军队在分开的包围状态下同时攻击。他们任一支军队单独进攻都毫无胜算，除非有至少6支军队（一半以上）同时袭击才能攻下敌国。他们分散在敌国的四周，依靠通信兵骑马相互通信来协商进攻意向及进攻时间。困扰这些将军的问题是，他们不确定他们中是否有叛徒，叛徒可能擅自变更进攻意向或者进攻时间。在这种状态下，拜占庭将军们才能保证有多于6支军队在同一时间一起发起进攻，从而赢取战斗？ 拜占庭将军问题中并不去考虑通信兵是否会被截获或无法传达信息等问题，即消息传递的信道绝无问题。Lamport已经证明了在消息可能丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。所以，在研究拜占庭将军问题的时候，已经假定了信道是没有问题的. 问题分析单从上面的说明可能无法理解这个问题的复杂性，我们来简单分析一下： 先看在没有叛徒情况下，假如一个将军A提一个进攻提议（如：明日下午1点进攻，你愿意加入吗？）由通信兵通信分别告诉其他的将军，如果幸运中的幸运，他收到了其他6位将军以上的同意，发起进攻。如果不幸，其他的将军也在此时发出不同的进攻提议（如：明日下午2点、3点进攻，你愿意加入吗？），由于时间上的差异，不同的将军收到（并认可）的进攻提议可能是不一样的，这是可能出现A提议有3个支持者，B提议有4个支持者，C提议有2个支持者等等。 再加一点复杂性，在有叛徒情况下，一个叛徒会向不同的将军发出不同的进攻提议（通知A明日下午1点进攻， 通知B明日下午2点进攻等等），一个叛徒也会可能同意多个进攻提议（即同意下午1点进攻又同意下午2点进攻）。 叛徒发送前后不一致的进攻提议，被称为“拜占庭错误”，而能够处理拜占庭错误的这种容错性称为「Byzantine fault tolerance」，简称为BFT。 相信大家已经可以明白这个问题的复杂性了。 中本聪的解决方案在出现比特币之前，解决分布式系统一致性问题主要是Lamport提出的Paxos算法或其衍生算法。Paxos类算法仅适用于中心化的分布式系统，这样的系统的没有不诚实的节点（不会发送虚假错误消息，但允许出现网络不通或宕机出现的消息延迟）。 中本聪在比特币中创造性的引入了“工作量证明（POW : Proof of Work）”来解决这个问题，有兴趣可进一步阅读工作量证明。通过工作量证明就增加了发送信息的成本，降低节点发送消息速率，这样就以保证在一个时间只有一个节点(或是很少)在进行广播，同时在广播时会附上自己的签名。这个过程就像一位将军A在向其他的将军（B、C、D…）发起一个进攻提议一样，将军B、C、D…看到将军A签过名的进攻提议书，如果是诚实的将军就会立刻同意进攻提议，而不会发起自己新的进攻提议。 以上就是比特币网络中是单个区块（账本）达成共识的方法（取得一致性）。 理解了单个区块取得一致性的方法，那么整个区块链（总账本）如果达成一致也好理解。我们稍微把将军问题改一下：假设攻下一个城堡需要多次的进攻，每次进攻的提议必须基于之前最多次数的胜利进攻下提出的（只有这样敌方已有损失最大，我方进攻胜利的可能性就更大），这样约定之后，将军A在收到进攻提议时，就会检查一下这个提议是不是基于最多的胜利提出的，如果不是（基于最多的胜利）将军A就不会同意这样的提议，如果是的，将军A就会把这次提议记下来。 这就是比特币网络最长链选择。 经济学分析工作量证明其实相当于提高了做叛徒（发布虚假区块）的成本，在工作量证明下，只有第一个完成证明的节点才能广播区块，竞争难度非常大，需要很高的算力，如果不成功其算力就白白的耗费了（算力是需要成本的），如果有这样的算力作为诚实的节点，同样也可以获得很大的收益（这就是矿工所作的工作），这也实际就不会有做叛徒的动机，整个系统也因此而更稳定。 很多人批评工作量证明造成巨大的电力浪费，促使人们去探索新的解决一致性（共识）问题的机制：权益证明机制（POS: Proof of Stake）是一个代表。在拜占庭将军问题的角度来看，它同样提高了做叛徒的成本，因为账户需要首先持有大量余额才能有更多的几率广播区块，POS不是本文重点，以后在讲。 共识算法的核心就是解决拜占庭将军问题（分布式网络一致性问题）。 扩展阅读The Byzantine Generals Problem","tags":[{"name":"比特币","slug":"比特币","permalink":"http://blog.buerya.cn/tags/比特币/"},{"name":"共识协议","slug":"共识协议","permalink":"http://blog.buerya.cn/tags/共识协议/"}]},{"title":"非对称加密技术- RSA算法数学原理分析","date":"2018-02-14T06:22:22.000Z","path":"2018/02/14/asy-encryption/","text":"非对称加密技术，在现在网络中，有非常广泛应用。加密技术更是数字货币的基础。 所谓非对称，就是指该算法需要一对密钥，使用其中一个（公钥）加密，则需要用另一个（私钥）才能解密。但是对于其原理大部分同学应该都是一知半解，今天就来分析下经典的非对称加密算法 - RSA算法。通过本文的分析，可以更好的理解非对称加密原理，可以让我们更好的使用非对称加密技术。 题外话:本博客一直有打算写一系列文章通俗的密码学，昨天给站点上https, 因其中使用了RSA算法，就查了一下，发现现在网上介绍RSA算法的文章都写的太难理解了，反正也准备写密码学，就先写RSA算法吧，下面开始正文。 RSA算法原理RSA算法的基于这样的数学事实：两个大质数相乘得到的大数难以被因式分解。如：有很大质数p跟q，很容易算出N，使得 N = p * q，但给出N, 比较难找p q（没有很好的方式， 只有不停的尝试） 这其实也是单向函数的概念 下面来看看数学演算过程： 1. 选取两个大质数p，q，计算N = p q 及 φ ( N ) = φ (p) φ (q) = (p-1) * (q-1) &gt; 三个数学概念： &gt; 质数(prime numbe)：又称素数，为在大于1的自然数中，除了1和它本身以外不再有其他因数。 &gt; 互质关系：如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系（coprime）。 &gt; φ(N)：叫做欧拉函数，是指任意给定正整数N，在小于等于N的正整数之中，有多少个与N构成互质关系。 &gt; 如果n是质数，则 φ(n)=n-1。 &gt; 如果n可以分解成两个互质的整数之积， φ(n) = φ(p1p2) = φ(p1)φ(p2)。即积的欧拉函数等于各个因子的欧拉函数之积。 2. 选择一个大于1 小于φ(N)的数e，使得 e 和 φ(N)互质 &gt; e其实是1和φ(N)之前的一个质数 3. 计算d，使得de=1 mod φ(N) 等价于方程式 ed-1 = k φ(N) 求一组解。 &gt; d 称为e的模反元素，e 和 φ(N)互质就肯定存在d。 &gt; 模反元素是指如果两个正整数a和n互质，那么一定可以找到整数b，使得ab被n除的余数是1，则b称为a的模反元素。 &gt; 可根据欧拉定理证明模反元素存在，欧拉定理是指若n,a互质，则： &gt; ![](http://qiniu.buerya.cn/static/aes_mod.png) 4. (N, e)封装成公钥，(N, d)封装成私钥。 假设m为明文，加密就是算出密文c: m^e mod N = c (明文m用公钥e加密并和随机数N取余得到密文c) 解密则是： c^d mod N = m (密文c用密钥解密并和随机数N取余得到明文m) &gt; 私钥解密这个是可以证明的，这里不展开了。 加解密步骤具体还是来看看步骤，举个例子，假设Alice和Bob又要相互通信。 Alice 随机取大质数P1=53，P2=59，那N=53*59=3127，φ(N)=3016 取一个e=3，计算出d=2011。 只将N=3127，e=3 作为公钥传给Bob（公钥公开） 假设Bob需要加密的明文m=89，c = 89^3 mod 3127=1394，于是Bob传回c=1394。 （公钥加密过程） Alice使用c^d mod N = 1394^2011 mod 3127，就能得到明文m=89。 （私钥解密过程） 假如攻击者能截取到公钥n=3127，e=3及密文c=1394，是仍然无法不通过d来进行密文解密的。 安全性分析那么，有无可能在已知n和e的情况下，推导出d？ ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。 φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。 n=pq。只有将n因数分解，才能算出p和q。 如果n可以被因数分解，d就可以算出，因此RSA安全性建立在N的因式分解上。大整数的因数分解，是一件非常困难的事情。只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。 补充模运算规则 模运算加减法:(a + b) mod p = (a mod p + b mod p) mod p(a - b) mod p = (a mod p - b mod p) mod p 模运算乘法：(a b) mod p = (a mod p b mod p) mod p 模运算幂a ^ b mod p = ((a mod p)^b) mod p","tags":[{"name":"非对称加密","slug":"非对称加密","permalink":"http://blog.buerya.cn/tags/非对称加密/"},{"name":"数学","slug":"数学","permalink":"http://blog.buerya.cn/tags/数学/"},{"name":"RSA算法","slug":"RSA算法","permalink":"http://blog.buerya.cn/tags/RSA算法/"},{"name":"密码学","slug":"密码学","permalink":"http://blog.buerya.cn/tags/密码学/"}]},{"title":"比特币区块结构Merkle树及简单支付验证分析","date":"2018-02-13T23:13:23.000Z","path":"2018/02/14/merkle/","text":"在比特币网络中，不是每个节点都有能力储存完整的区块链数据，受限于存储空间的的限制，很多节点是以SPV（Simplified Payment Verification简单支付验证）钱包接入比特币网络，通过简单支付验证可以在不必存储完整区块链下对交易进行验证，本文将分析区块结构Merkle树及如何进行交易验证。 区块结构在工作量证明中出现过一个区块信息截图： 细心的同学一定已经在里面发现了很多未讲的其他信息，如：时间戳，版本号，交易次数，二进制哈希树根(Merkle根)等。 我们来看看一个区块结构到底是怎样的： 如上图（下文称：区块结构图）所示：每个数据区块包含区块头和区块体。区块头封装了当前版本号、前一区块哈希值、当前区块PoW要求的随机数(Nonce)、时间戳、以及Merkle根信息。区块体则包括当前区块经过验证的、 区块创建过程中生成的所有交易记录。这些记录通过 Merkle树的哈希过程生成唯一的Merkle根并记入区块头. 区块哈希值实际上并不包含在区块的数据结构里，其实区块打包时只有区块头被用于计算哈希（从网络被接收时由每个节点计算出来），常说的区块哈希值实际是区块头哈希值，它可以用来唯一、明确地标识一个区块。 区块头是80字节，而平均每个交易至少是250字节，而且平均每个区块包含2000个交易。因此，包含完整交易的区块比区块头的4千倍还要大。SPV节点只下载区块头，不下载包含在每个区块中的交易信息。这样的不含交易信息的区块链，大小只有完整区块链的几千分之1，那SPV节点是如何验证交易的呢？ 哈希验证上面先留一个引子，先来回顾下哈希函数，记账原理我们知道原始信息任何微小的变化都会哈希完全不同的哈希值。 简单文件验证我们通常用哈希来检验下载的文件是否完整，我经常看到这样的下载页面： 可以看到下载链接后面提供了一个MD5（MD5也是一种Hash算法），这样我们可以在下载之后对文件计算MD5，如果MD5与提供的MD5相等，说明文件有没有被损坏，这个验证过程相信大家都能理解。 多点文件验证(哈希列表)现在复杂度提高一点，在P2P网络中下载时，会把大文件切成小文件，同时从多个机器上下载数据，这个时候怎么验证数据呢？ 以BT下载为例，在下载真正的数据之前，我们会先下载一个哈希列表的（每个下小块计算出一个哈希），如果有一个小块数据在传输过程中损坏了，那我只要重新下载这一个数据块就行了，这时有一个问题就出现了，那么多的哈希，怎么保证它们本身(哈希列表中的哈希值)都是正确地呢？ 答案是把每个小块数据的哈希值拼到一起，然后对这个长字符串在作一次哈希运算，得到哈希列表的根哈希。只要根哈希校对比一样就说明验哈希列表是正确的，再通过哈希列表校验小数据块，如果所有的小数据块验证通过则说明大文件没有被损坏。 Merkle树验证交易的过程和文件验证很相似，可以人为每个交易是一个小数据块，但比特币使用Merkle\b树的方式进行验证，相对于哈希列表，Merkle树是一种哈希二叉树，它的明显的一个好处是可以单独拿出一个分支来（作为一个小树）对部分数据进行校验，更加高效。 我们回看下上面的区块结构图，区块体就包含这样一个Merkle\b树,Merkle树被用来归纳一个区块中的所有交易。 每个叶子节点是每个交易信息的哈希，往上对相邻的两个哈希合并成字符串再哈希，继续类似的操作直到只剩下顶部的一个节点，即Merkle根，存入区块头。 因为Merkle树是二叉树，所以它需要偶数个叶子节点。如果仅有奇数个交易需要归纳，那最后的交易就会被复制一份以构成偶数个叶子节点，这种偶数个叶子节点的树也被称为平衡树。 简化支付验证SPV节点不保存所有交易也不会下载整个区块，仅仅保存区块头，我们来看看它是如何对交易数据进行验证的。 假如要验证区块结构图中交易6，SPV节点会通过向相邻节点索要（通过Merkleblock消息）包括从交易6哈希值沿Merkle树上溯至区块头根哈希处的哈希序列 (即哈希节点6, 5, 56, 78, 5678, 1234 1~8 - 称为认证路径) 来确认交易的存在性和正确性。（在N个交易组成的区块中确认任一交易只需要计算log2(N)个字节的哈希值，非常快速高效） 你明白了吗？","tags":[{"name":"比特币","slug":"比特币","permalink":"http://blog.buerya.cn/tags/比特币/"},{"name":"区块链","slug":"区块链","permalink":"http://blog.buerya.cn/tags/区块链/"},{"name":"区块链技术","slug":"区块链技术","permalink":"http://blog.buerya.cn/tags/区块链技术/"},{"name":"SPV简单支付验证","slug":"SPV简单支付验证","permalink":"http://blog.buerya.cn/tags/SPV简单支付验证/"},{"name":"区块结构","slug":"区块结构","permalink":"http://blog.buerya.cn/tags/区块结构/"}]},{"title":"比特币脚本及交易分析 - 智能合约雏形","date":"2018-02-13T22:22:43.000Z","path":"2018/02/14/bitcoin-script/","text":"大家都有转过账，每笔交易是这样的：张三账上减￥200，李四账上加￥200。在比特币区块链中，交易不是这么简单，\b\b交易实际是通过脚本来完成，以承载更多的功能个，这也是为什么比特币被称为是一种“可编程的货币”。本文就来分析一下交易是如何实现可编程的。 未花费的交易输出(UTXO)先引入一个概念：未花费的交易输出——UTXO（Unspent Transaction Output） 其实比特币的交易都是基于UTXO上的，即交易的输入是之前交易未花费的输出，这笔交易的输出可以被当做下一笔新交易的输入。 挖矿奖励属于一个特殊的交易（称为coinbase交易），可以没有输入。UTXO是交易的基本单元，不能再分割。在比特币没有余额概念，只有分散到区块链里的UTXO 随着钱从一个地址被移动到另一个地址的同时形成了一条所有权链，像这样： 比特币脚本比特币交易是首先要提供一个用于解锁UTXO（用私钥去匹配锁定脚本）的脚本（常称为解锁脚本：Signature script)，这也叫交易输入，交易的输出则是指向一个脚本（称为锁定脚本：PubKey script），这个脚本表达了：谁的签名（签名是常见形式，\b并不一定必须是签名）能匹配这个输出地址，钱就支付给谁。 每一个比特币节点会通过同时执行这解锁和锁定脚本（不是当前的锁定脚本，是指上一个交易的锁定脚本）来验证一笔交易，脚本组合结果为真，则为有效交易。 当解锁版脚本与锁定版脚本的设定条件相匹配时，执行组合有效脚本时才会显示结果为真 如最为常见类型的比特币交易脚本（支付到公钥哈希：P2PKH（Pay-to-Public-Key-Hash））组合是这样： 常见交易脚本验证过程比特币交易脚本语言是一种基于逆波兰表示法的基于栈的执行语言（不知道逆波兰和栈的同学去翻大学数据结构课本，你也可跳过这个部分）。 比特币脚本语言包含基本算数计算、基本逻辑(比如if…then)、报错以及返回结果和一些加密指令，不支持循环。想了解更多语言细节可参考:比特币脚本 脚本语言通过从左至右地处理每个项目的方式执行脚本。 下面用两个图说明下常见类型的比特币交易脚本验证执行过程： 上图为解锁脚本运行过程（主要是入栈） 上图为锁定脚本运行过程（主要是出栈），最后的结果为真，说明交易有效。 交易分析实际上比特币的交易被设计为可以纳入多个输入和输出。 交易结构我们来看看完整的交易结构 交易的锁定时间定义了能被加到区块链里的最早的交易时间。在大多数交易里，它被设置成0，用来表示立即执行。如果锁定时间不是0并且小于5亿，就被视为区块高度，意指在这个指定的区块高度之前，该交易不会被包含在区块链里。如果锁定时间大于5亿，则它被当作是一个Unix纪元时间戳（从1970年1月1日以来的秒数），并且在这个指定时间之前，该交易不会被包含在区块链里。 交易的数据结构没有交易费的字段，交易费通过所有输入的总和，以及所有输出的总和之间的差来表示，即： 交易费 = 求和（所有输入） - 求和（所有输出） 交易输入结构刚刚我们提过输入需要提供一个解锁脚本，现在来看看一个交易的输入结构： 我们结合整个交易的结构里看输入结构就是这样子： 交易输出结构刚刚我们提过输出是指向一个解锁脚本，具体交易的输出结构为： 我们结合整个交易的结构里看输出结构就是这样子： 交易哈希计算在比特币区块结构Merkle 树及简单支付验证分析讲到区块结构，区块结构包含多个交易的哈希。那么交易哈希是怎么计算的呢？ 交易结构各字段序列化为字节数组 把字节数组拼接为支付串 对支付串计算两次SHA256 得到交易hash了解详情可进一步参考如何计算交易Hash?及如何创建Hash? 现在是不是对完整的交易到区块有了更清晰的认识。 智能合约雏形 - 应用场景说明由于交易是通过脚本来实现，脚本语言可以表达出无数的条件变种。 比特币的脚本目前常用的主要分为两种，一种是常见的P2PKH（支付给公钥哈希），另一种是P2SH（Pay-to-Script-Hash支付脚本哈希）。P2SH支付中，锁定脚本被密码学哈希所取代，当一笔交易试图支付UTXO时，要解锁支付脚本，它必须含有与哈希相匹配的脚本。 这里不展开技术细节，下面说明一些应用场景，以便大家有更直观的认识。 多重签名应用合伙经营中，如只有一半以上的的股东同意签名就可以进行支付，可为公司治理提供管控便利，同时也能有效防范盗窃、挪用和遗失。 用于担保和争端调解，一个买家想和他不认识或不信任的某人交易，在一般情况交易正常进行时，买家不想任何第三方参与。那交易双方可以发起支付，但如果交易出现问题时，那第三方就可以根据裁定，使用自己的签名和裁定认可的一方共同签名来兑现这笔交易。 保证合同保证合同是建造公众商品时的集资办法，公众商品是指一旦建成，任何人都可以免费享受到好处。标准的例子是灯塔，所有人都认同应该建造一个，但是对于个人航海者来说灯塔太贵了，灯塔同时也会方便其他航海者。 一个解决方案是向所有人集资，只有当筹集的资金超过所需的建造成本时，每个人才真正付钱，如果集资款不足，则谁都不用付钱。 依靠预言假如老人想让他孙子继承遗产，继承时间是在他死后或者在孙子年满18岁时（也是一个带锁定时间交易），无论哪个条件先满足，他的孙子都可以得到遗产。 因为比特币节点可依靠预言对死亡条件进行判断，预言是指具有密钥对的服务器，当用户自定义的表达式被证明是真的，它能按照要求对交易签名。 相信随着区块链的普及，会对未来的交易模式和商业结构带来巨大的影响。不过由于比特币的脚本语言不是图灵完备的，交易模式依旧有限，以太坊就是为解决这一问题而出现，后面会有大量介绍以太坊的文章。 参考文献 &amp; 补充阅读 精通比特币 廖雪峰的深入理解比特币交易的脚本 比特币合同","tags":[{"name":"比特币","slug":"比特币","permalink":"http://blog.buerya.cn/tags/比特币/"},{"name":"区块链","slug":"区块链","permalink":"http://blog.buerya.cn/tags/区块链/"},{"name":"区块链技术","slug":"区块链技术","permalink":"http://blog.buerya.cn/tags/区块链技术/"},{"name":"比特币脚本","slug":"比特币脚本","permalink":"http://blog.buerya.cn/tags/比特币脚本/"},{"name":"交易结构","slug":"交易结构","permalink":"http://blog.buerya.cn/tags/交易结构/"}]},{"title":"分析比特币网络：一种去中心化、点对点的网络架构","date":"2018-02-13T07:22:43.000Z","path":"2018/02/13/bitcoin-p2p/","text":"比特币采用了基于互联网的点对点（P2P：peer-to-peer）分布式网络架构。比特币网络可以认为是按照比特币P2P协议运行的一系列节点的集合。本文来分析下比特币网络，了解它跟传统中心化网络的区别，以及比特币网络是如何发现相邻节点的。 中心化网络为了更好的理解P2P网络，我们先来看看传统的中心化模型： 这是一种典型的星型（“中心化”）结构，我们常见B/S及C/S网络架构就是这种模型，C1 、C2 、C3等之间没法直接的连接，C节点如果要连接必须要通过中心化S节点做为桥梁。中心化节点充当服务者、中介作用，比如我们没有办法把资金直接从一个人转移给另一个人，必须通过银行这个中介。 P2P网络P2P网络是指位于同一网络中的每台计算机都彼此对等，各个节点共同提供网络服务，不存在任何“特殊”节点，每个网络节点以扁平（flat）的拓扑结构相互连通。 对比中心化网络，在P2P网络中不存在任何服务端（server）、中央化的服务。P2P网络的节点之间交互连接、协同，每个节点在对外提供服务的同时也使用网络中其他节点所提供的服务，每个节点即是服务端又是客户端。P2P网络模型除应用于比特币网络，使用广泛的BT下载就是基于P2P网络。 P2P网络不仅仅去除了中心化带来的风险（中心化可能作恶），还可以提高传输的效率。（中心化网络当能也有优点） 如何发现节点既然每个网络节点都是平等的（是指在网络层面上节点是平等的，但各节点在功能上可以有不同的分工, 如钱包节点、挖矿节点等），不存在任何“特殊”中心节点，那么当新的网络节点启动后，它是如何跟其他的节点建立连接，从而加入到比特币网络呢？ 在中心化网络中，新加入的节点只要连接“特殊”的中心节点就可以加入网络。 为了能够加入到比特币网络，比特币客户端会做一下几件事情： 节点会记住它最近成功连接的网络节点，当重新启动后它可以迅速与先前的对等节点网络重新建立连接。 节点会在失去已有连接时尝试发现新节点。 当建立一个或多个连接后，节点将一条包含自身IP地址消息发送给其相邻节点。相邻节点再将此消息依次转发给它们各自的相邻节点，从而保证节点信息被多个节点所接收、保证连接更稳定。 新接入的节点可以向它的相邻节点发送获取地址getaddr消息，要求它们返回其已知对等节点的IP地址列表。节点可以找到需连接到的对等节点。 在节点启动时，可以给节点指定一个正活跃节点IP, 如果没有，客户端也维持一个列表，列出了那些长期稳定运行的节点。这样的节点也被称为种子节点（其实和BT下载的种子文件道理是一样的），就可以通过种子节点来快速发现网络中的其他节点。 节点通信简述比特币节点通常采用TCP协议、使用8333端口与相邻节点建立连接, 建立连接时也会有认证“握手”的通信过程，用来确定协议版本，软件版本，节点IP，区块高度等。 当节点连接到相邻节点后，接着就开始跟相邻节点同步区块链数据（轻量级钱包应用其实不会同步所有区块数据），节点们会交换一个getblocks消息，它包含本地区块链最顶端的哈希值。如果某个节点识别出它接收到的哈希值并不属于顶端区块，而是属于一个非顶端区块的旧区块，就说其自身的本地区块链比其他节点的区块链更长，并告诉其他节点需要补充区块，其他节点发送getdata消息来请求区块，验证后更新到本地区块链中。","tags":[{"name":"比特币","slug":"比特币","permalink":"http://blog.buerya.cn/tags/比特币/"},{"name":"区块链","slug":"区块链","permalink":"http://blog.buerya.cn/tags/区块链/"},{"name":"区块链技术","slug":"区块链技术","permalink":"http://blog.buerya.cn/tags/区块链技术/"}]},{"title":"比特币如何挖矿（挖矿原理）-工作量证明","date":"2018-02-13T00:25:43.000Z","path":"2018/02/13/bitcoin-pow/","text":"在区块链记账原理一篇，我们了解到记账是把交易记录、交易时间、账本序号、上一个Hash值等信息计算Hash打包的过程。我们知道所有的计算和存贮是需要消耗计算机资源的，既然要付出成本，那节点为什么还要参与记账呢？在中本聪（比特币之父）的设计里，完成记账的节点可以获得系统给与的一定数量的比特币奖励，这个奖励的过程也就是比特币的发行过程，因此大家形象的把记账称为“挖矿”，本文将详细讨论这个过程。 记账工作由于记账是有奖励的，每次记账都可以给自己凭空增加一定数量的个比特币（当前是12.5比特币，博文写作时每个比特币是5万人民币以上，大家可以算算多少钱），因此就出现大家争相记账，大家一起记账就会引起问题：出现记账不一致的问题，比特币系统引入工作量证明来解决这个问题，规则如下： 一段时间内（10分钟左右，具体时间会与密码学难题难度相互影响）只有一人可以记账成功 通过解决密码学难题（即工作量证明）竞争获得唯一记账权 其他节点复制记账结果 不过在进行工作量证明之前，记账节点会做进行如下准备工作： 收集广播中还没有被记录账本的原始交易信息 检查每个交易信息中付款地址有没有足够的余额 验证交易是否有正确的签名 把验证通过的交易信息进行打包记录 添加一个奖励交易：给自己的地址增加12.5比特币 如果节点争夺记账权成功的话，就可以得到12.5比特币的奖励。 工作量证明区块链记账原理我们了解到，每次记账的时候会把上一个块的Hash值和当前的账页信息一起作为原始信息进行Hash。如果仅仅是这样，显然每个人都可以很轻松的完成记账。为了保证10分钟左右只有一个人可以记账，就必须要提高记账的难度，使得Hash的结果必须以若干个0开头。同是为了满足这个条件，在进行Hash时引入一个随机数变量。 用伪代码表示一下： 12# 没有难度时为：Hash(上一个Hash值，交易记录集) = 456635BCDHash(上一个Hash值，交易记录集，随机数) = 0000aFD635BCD 计算量分析 （这部分可选阅读） 我们简单分析下记账难度有多大，Hash值是由数字和大小写字母构成的字符串，每一位有62种可能性（可能为26个大写字母、26个小写字母，10个数字中任一个），假设任何一个字符出现的概率是均等的，那么第一位为0的概率是1/62（其他位出现什么字符先不管），理论上需要尝试62次Hash运算才会出现一次第一位为0的情况，如果前两2位为0，就得尝试62的平方次Hash运算，以n个0开头就需要尝试62的n次方次运算。我们结合当前实际区块#493050信息来看看： 注：数据来源于https://blockchain.info我们可以看到Hash值以18个0开头，理论上需要尝试62的18次方次，这个数是非常非常巨大的，我已经算不清楚了，应该是亿亿级别以上了。如此大的计算量需要投入大量的计算设备、电力等，目前应该没有单矿工独立参与挖矿了，基本都是由矿工联合起来组成矿池进行挖矿（矿池里的矿工按算力百分比来分收益）。 从经济的角度讲，只有挖矿还有收益（比特币价格不断上涨也让收益变大），就会有新的矿工加入，从而加剧竞争，提高算力难度，挖矿就需要耗费更多的运算和电力，相互作用引起最终成本会接近收益。 题外话：国内由于电力成本较低，相对收益更高，中国的算力占整个网络的一半以上 验证在节点成功找到满足的Hash值之后，会马上对全网进行广播打包区块，网络的节点收到广播打包区块，会立刻对其进行验证。 如果验证通过，则表明已经有节点成功解迷，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争猜谜。网络中只有最快解谜的区块，才会添加的账本中，其他的节点进行复制，这样就保证了整个账本的唯一性。 假如节点有任何的作弊行为，都会导致网络的节点验证不通过，直接丢弃其打包的区块，这个区块就无法记录到总账本中，作弊的节点耗费的成本就白费了，因此在巨大的挖矿成本下，也使得矿工自觉自愿的遵守比特币系统的共识协议，也就确保了整个系统的安全。 进阶阅读比特币区块结构Merkle树及简单支付验证分析，可以详细了解区块结构如何验证交易。 说明矿工的收益其实不仅仅包含新发行的12.5比特币奖励，同时还有交易费收益（本文忽略一些细节是为了让主干更清晰）。 有兴趣的同学可以看看图中区块都包含了那些信息，红箭头标示出的是本文涉及的信息。 本文中有提到共识协议，比特币共识协议主要是由工作量证明和最长链机制 两部分组成，请阅读比特币如何达成共识 - 最长链的选择。","tags":[{"name":"比特币","slug":"比特币","permalink":"http://blog.buerya.cn/tags/比特币/"},{"name":"区块链","slug":"区块链","permalink":"http://blog.buerya.cn/tags/区块链/"},{"name":"区块链技术","slug":"区块链技术","permalink":"http://blog.buerya.cn/tags/区块链技术/"},{"name":"挖矿","slug":"挖矿","permalink":"http://blog.buerya.cn/tags/挖矿/"},{"name":"工作量证明","slug":"工作量证明","permalink":"http://blog.buerya.cn/tags/工作量证明/"},{"name":"共识机制","slug":"共识机制","permalink":"http://blog.buerya.cn/tags/共识机制/"}]},{"title":"比特币所有权及隐私问题-非对称加密应用","date":"2018-02-12T03:55:43.000Z","path":"2018/02/12/bitcoin-own/","text":"比特币系统是如何确定某个账户的比特币是属于谁的？谁可以支付这个账户比特币？如果你对这个问题还不是很明白，那就一起来看看吧。 银行系统我们先来回顾下现实的银行系统： 首先我们需要把我们的个人信息（如身份证）给银行，银行给我们开立相对应的账户，银行在开户的时候确立了对账户的所有权。 进行支付的时候，银行对交易双方完成转账（银行在开户的时候已经知道我们对应的账户）。同时银行会对账户信息进行保密（这点其实不能保证）。 匿名账本那么比特币如何在没有第三方银行的参与下，在确保隐私的同时如何确定账户所有权的呢？ 实际上比特币的账户是用地址来表示，账本上不显示个人信息，转账是把比特币从一个地址转移到另一个地址。转账记录如这样： 12345&#123; \"付款地址\":\"2A39CBa2390FDe\" \"收款地址\":\"AAC9CBa239aFcc\" \"金额\":\"0.2btc\"&#125; 接下来问题就变为了 谁有权用某个地址进行付款。 支付和所有权 实际是同一个问题，如果此比特币只有我可以用来支付，那么说明我拥有所有权 地址与私钥比特币的解决方案是，谁拥有某个地址的私钥(如果完全没有加密概念的人，可以简单的把私钥当作密码)，谁就能用这个地址进行支付。（所以私钥一定保管好，如果私钥泄漏，比特币就可能丢失） 比特币地址和私钥是一个非对称的关系，私钥经过一系列运算（其中有两次Hash）之后，可以得到地址, 但是无法从地址反推得到私钥。 1234地址： 2A39CBa2390FDe私钥： sdgHsdniNIhdsgaKIhkgnakgaihNKHIskdgalHash(Hash(fun(sdgHsdniNIhdsgaKIhkgnakgaihNKHIskdgal))) -&gt; 2A39CBa2390FDe 银行系统银行账号和密码是完全独立的，无法互相推导，转出时需要同时验证账号和密码 还是上面交易的例子： 12345&#123; \"付款地址\"：\"2A39CBa2390FDe\", \"收款地址\"：\"AAC9CBa239aFcc\", \"金额\"：\"0.2btc\"&#125; 只有拥有地址2A39CBa2390FDe的私钥才能进行支付。 非对称加密技术这个时候问题就变为了，如何证明你拥有某个地址的私钥（在不泄漏私钥的情况下）。 对交易信息进行签名实际在签名之前，会先对交易信息进行Hash运算得到摘要信息，然后对摘要信息进行签名。过程大概是这样： 对交易进行hash， 得到一个摘要信息（Hash值） 12345hash(&apos; &#123;&quot;付款地址&quot;：&quot;2A39CBa2390FDe&quot;, &quot;收款地址&quot;：&quot;AAC9CBa239aFcc&quot;, &quot;金额&quot;：&quot;0.2btc&quot; &#125;&apos;) -&gt; 8aDB23CDEA6 用私钥对交易摘要进行签名（付款方在安全的环境下进行，以避免私钥泄密）, 用代码表示大概是这样。 1234#参数1为交易摘要#参数2为私钥#返回签名信息sign(&quot;8aDB23CDEA6&quot;, &quot;J78sknJhidhLIqdngalket&quot;) -&gt; &quot;3cdferdadgadg&quot; 广播在签名运算之后，付款节点就开始在全网进行广播：我支付了0.2btc到AAC9CBa239aFcc,签名信息是3cdferdadgadg，你们来确认一下吧。 广播过程实际上是发信息到相连的其它节点，其它节点在验证通过后再转发到与之相连的节点，这样的扩散过程。 广播的信息包含了交易原始信息和签名信息 验证其它节点在收到广播信息之后，会验证签名信息是不是付款方用私钥对交易原始信息签名产生的，如果验证通过说明确实是付款方本人发出的交易，说明交易有效，才会记录到账本中去。（实际还会验证付款账号有没有足够的余额，我们暂时忽略这点）验证过程实际是签名过程的逆运算，用代码表示大概过程是这样的： 1234#参数1为签名信息#参数2为付款方地址#返回交易摘要verify(&quot;3cdferdadgadg&quot;, &quot;2A39CBa2390FDe&quot;) -&gt; &quot;8aDB23CDEA6&quot; 如果验证输出的信息和原始交易信息的hash一致，则验证通过，记录账本，用代码表示大概是这样： 12345678if(verify(&quot;3cdferdadgadg&quot;, &quot;2A39CBa2390FDe&quot;) == hash(&apos;&#123;&quot;付款地址&quot;：&quot;2A39CBa2390FDe&quot;, &quot;收款地址&quot;：&quot;AAC9CBa239aFcc&quot;, &quot;金额&quot;：&quot;0.2btc&quot;&#125;&apos;)) : # 写入账本 # 广播else: # donothing 大家可以理解为付款地址为公钥，签名过程即为用私钥对交易摘要的加密过程，验证过程为用公钥解密的过程(为方便大家理解，严格来讲是不准确的)。 补充说明上面为了更好的理解，我对一些信息进行了简化。 比特币系统使用了椭圆曲线签名算法，算法的私钥由32个字节随机数组成，通过私钥可以计算出公钥，公钥经过一序列哈希算法和编码算法得到比特币地址，地址也可以理解为公钥的摘要。","tags":[{"name":"比特币","slug":"比特币","permalink":"http://blog.buerya.cn/tags/比特币/"},{"name":"Python","slug":"Python","permalink":"http://blog.buerya.cn/tags/Python/"},{"name":"区块链","slug":"区块链","permalink":"http://blog.buerya.cn/tags/区块链/"},{"name":"区块链技术","slug":"区块链技术","permalink":"http://blog.buerya.cn/tags/区块链技术/"}]},{"title":"用Python从零开始创建区块链","date":"2018-02-09T09:35:23.000Z","path":"2018/02/09/build_blockchain_by_python/","text":"本文主要内容翻译自Learn Blockchains by Building One 作者认为最快的学习区块链的方式是自己创建一个，本文就跟随作者用Python来创建一个区块链。 对数字货币的崛起感到新奇的我们，并且想知道其背后的技术——区块链是怎样实现的。 但是完全搞懂区块链并非易事，我喜欢在实践中学习，通过写代码来学习技术会掌握得更牢固。通过构建一个区块链可以加深对区块链的理解。 准备工作本文要求读者对Python有基本的理解，能读写基本的Python，并且需要对HTTP请求有基本的了解。 我们知道区块链是由区块的记录构成的不可变、有序的链结构，记录可以是交易、文件或任何你想要的数据，重要的是它们是通过哈希值（hashes）链接起来的。 如果你还不是很了解哈希，可以查看这篇文章 环境准备环境准备，确保已经安装Python3.6+, pip , Flask, requests安装方法： 1pip install Flask==0.12.2 requests==2.18.4 同时还需要一个HTTP客户端，比如Postman，cURL或其它客户端。 参考源代码 开始创建Blockchain新建一个文件 blockchain.py，本文所有的代码都写在这一个文件中，可以随时参考源代码 Blockchain类首先创建一个Blockchain类，在构造函数中创建了两个列表，一个用于储存区块链，一个用于储存交易。以下是Blockchain类的框架: 12345678910111213141516171819202122class Blockchain(object): def __init__(self): self.chain = [] self.current_transactions = [] def new_block(self): # Creates a new Block and adds it to the chain pass def new_transaction(self): # Adds a new transaction to the list of transactions pass @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass Blockchain类用来管理链条，它能存储交易，加入新块等，下面我们来进一步完善这些方法。 块结构每个区块包含属性：索引（index），Unix时间戳（timestamp），交易列表（transactions），工作量证明（稍后解释）以及前一个区块的Hash值。 以下是一个区块的结构： 12345678910111213block = &#123; &apos;index&apos;: 1, &apos;timestamp&apos;: 1506057125.900785, &apos;transactions&apos;: [ &#123; &apos;sender&apos;: &quot;8527147fe1f5426f9dd545de4b27ee00&quot;, &apos;recipient&apos;: &quot;a77f5cdfa2934df3954a5c7c7da5df1f&quot;, &apos;amount&apos;: 5, &#125; ], &apos;proof&apos;: 324984774000, &apos;previous_hash&apos;: &quot;2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824&quot;&#125; 到这里，区块链的概念就清楚了，每个新的区块都包含上一个区块的Hash，这是关键的一点，它保障了区块链不可变性。如果攻击者破坏了前面的某个区块，那么后面所有区块的Hash都会变得不正确。不理解的话，慢慢消化，可参考区块链记账原理 加入交易接下来我们需要添加一个交易，来完善下new_transaction方法 12345678910111213141516171819class Blockchain(object): ... def new_transaction(self, sender, recipient, amount): \"\"\" 生成新交易信息，信息将加入到下一个待挖的区块中 :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction \"\"\" self.current_transactions.append(&#123; 'sender': sender, 'recipient': recipient, 'amount': amount, &#125;) return self.last_block['index'] + 1 方法向列表中添加一个交易记录，并返回该记录将被添加到的区块(下一个待挖掘的区块)的索引，等下在用户提交交易时会有用。 创建新块当Blockchain实例化后，我们需要构造一个创世块（没有前区块的第一个区块），并且给它加上一个工作量证明。每个区块都需要经过工作量证明，俗称挖矿，稍后会继续讲解。 为了构造创世块，我们还需要完善new_block(), new_transaction() 和hash() 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import hashlibimport jsonfrom time import timeclass Blockchain(object): def __init__(self): self.current_transactions = [] self.chain = [] # Create the genesis block self.new_block(previous_hash=1, proof=100) def new_block(self, proof, previous_hash=None): \"\"\" 生成新块 :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block :return: &lt;dict&gt; New Block \"\"\" block = &#123; 'index': len(self.chain) + 1, 'timestamp': time(), 'transactions': self.current_transactions, 'proof': proof, 'previous_hash': previous_hash or self.hash(self.chain[-1]), &#125; # Reset the current list of transactions self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): \"\"\" 生成新交易信息，信息将加入到下一个待挖的区块中 :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction \"\"\" self.current_transactions.append(&#123; 'sender': sender, 'recipient': recipient, 'amount': amount, &#125;) return self.last_block['index'] + 1 @property def last_block(self): return self.chain[-1] @staticmethod def hash(block): \"\"\" 生成块的 SHA-256 hash值 :param block: &lt;dict&gt; Block :return: &lt;str&gt; \"\"\" # We must make sure that the Dictionary is Ordered, or we'll have inconsistent hashes block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest() 通过上面的代码和注释可以对区块链有直观的了解，接下来我们看看区块是怎么挖出来的。 理解工作量证明新的区块依赖工作量证明算法（PoW）来构造。PoW的目标是找出一个符合特定条件的数字，这个数字很难计算出来，但容易验证。 这就是工作量证明的核心思想。 为了方便理解，举个例子： 假设一个整数 x 乘以另一个整数 y 的积的 Hash 值必须以 0 结尾，即 hash(x * y) = ac23dc…0。设变量 x = 5，求 y 的值？ 用Python实现如下： 123456from hashlib import sha256x = 5y = 0 # y未知while sha256(f'&#123;x*y&#125;'.encode()).hexdigest()[-1] != \"0\": y += 1print(f'The solution is y = &#123;y&#125;') 结果是y=21. 因为： 1hash(5 * 21) = 1253e9373e...5e3600155e860 在比特币中，使用称为Hashcash的工作量证明算法，它和上面的问题很类似。矿工们为了争夺创建区块的权利而争相计算结果。通常，计算难度与目标字符串需要满足的特定字符的数量成正比，矿工算出结果后，会获得比特币奖励。当然，在网络上非常容易验证这个结果。 实现工作量证明让我们来实现一个相似PoW算法，规则是：寻找一个数 p，使得它与前一个区块的 proof 拼接成的字符串的 Hash 值以 4 个零开头。 12345678910111213141516171819202122232425262728293031323334353637import hashlibimport jsonfrom time import timefrom uuid import uuid4class Blockchain(object): ... def proof_of_work(self, last_proof): \"\"\" 简单的工作量证明: - 查找一个 p' 使得 hash(pp') 以4个0开头 - p 是上一个块的证明, p' 是当前的证明 :param last_proof: &lt;int&gt; :return: &lt;int&gt; \"\"\" proof = 0 while self.valid_proof(last_proof, proof) is False: proof += 1 return proof @staticmethod def valid_proof(last_proof, proof): \"\"\" 验证证明: 是否hash(last_proof, proof)以4个0开头? :param last_proof: &lt;int&gt; Previous Proof :param proof: &lt;int&gt; Current Proof :return: &lt;bool&gt; True if correct, False if not. \"\"\" guess = f'&#123;last_proof&#125;&#123;proof&#125;'.encode() guess_hash = hashlib.sha256(guess).hexdigest() return guess_hash[:4] == \"0000\" 衡量算法复杂度的办法是修改零开头的个数。使用4个来用于演示，你会发现多一个零都会大大增加计算出结果所需的时间。 现在Blockchain类基本已经完成了，接下来使用HTTP requests来进行交互。 Blockchain作为API接口我们将使用Python Flask框架，这是一个轻量Web应用框架，它方便将网络请求映射到 Python函数，现在我们来让Blockchain运行在基于Flask web上。 我们将创建三个接口： /transactions/new 创建一个交易并添加到区块 /mine 告诉服务器去挖掘新的区块 /chain 返回整个区块链 创建节点我们的“Flask服务器”将扮演区块链网络中的一个节点。我们先添加一些框架代码： 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibimport jsonfrom textwrap import dedentfrom time import timefrom uuid import uuid4from flask import Flaskclass Blockchain(object): ...# Instantiate our Nodeapp = Flask(__name__)# Generate a globally unique address for this nodenode_identifier = str(uuid4()).replace('-', '')# Instantiate the Blockchainblockchain = Blockchain()@app.route('/mine', methods=['GET'])def mine(): return \"We'll mine a new Block\"@app.route('/transactions/new', methods=['POST'])def new_transaction(): return \"We'll add a new transaction\"@app.route('/chain', methods=['GET'])def full_chain(): response = &#123; 'chain': blockchain.chain, 'length': len(blockchain.chain), &#125; return jsonify(response), 200if __name__ == '__main__': app.run(host='0.0.0.0', port=5000) 简单的说明一下以上代码：第15行: 创建一个节点.第18行: 为节点创建一个随机的名字.第21行: 实例Blockchain类.第24–26行: 创建/mine GET接口。第28–30行: 创建/transactions/new POST接口,可以给接口发送交易数据.第32–38行: 创建 /chain 接口, 返回整个区块链。第40–41行: 服务运行在端口5000上. 发送交易发送到节点的交易数据结构如下： 12345&#123; &quot;sender&quot;: &quot;my address&quot;, &quot;recipient&quot;: &quot;someone else&apos;s address&quot;, &quot;amount&quot;: 5&#125; 之前已经有添加交易的方法，基于接口来添加交易就很简单了 123456789101112131415161718192021222324import hashlibimport jsonfrom textwrap import dedentfrom time import timefrom uuid import uuid4from flask import Flask, jsonify, request...@app.route('/transactions/new', methods=['POST'])def new_transaction(): values = request.get_json() # Check that the required fields are in the POST'ed data required = ['sender', 'recipient', 'amount'] if not all(k in values for k in required): return 'Missing values', 400 # Create a new Transaction index = blockchain.new_transaction(values['sender'], values['recipient'], values['amount']) response = &#123;'message': f'Transaction will be added to Block &#123;index&#125;'&#125; return jsonify(response), 201 挖矿挖矿正是神奇所在，它很简单，做了一下三件事： 计算工作量证明PoW 通过新增一个交易授予矿工（自己）一个币 构造新区块并将其添加到链中 123456789101112131415161718192021222324252627282930313233343536import hashlibimport jsonfrom time import timefrom uuid import uuid4from flask import Flask, jsonify, request...@app.route('/mine', methods=['GET'])def mine(): # We run the proof of work algorithm to get the next proof... last_block = blockchain.last_block last_proof = last_block['proof'] proof = blockchain.proof_of_work(last_proof) # 给工作量证明的节点提供奖励. # 发送者为 \"0\" 表明是新挖出的币 blockchain.new_transaction( sender=\"0\", recipient=node_identifier, amount=1, ) # Forge the new Block by adding it to the chain block = blockchain.new_block(proof) response = &#123; 'message': \"New Block Forged\", 'index': block['index'], 'transactions': block['transactions'], 'proof': block['proof'], 'previous_hash': block['previous_hash'], &#125; return jsonify(response), 200 注意交易的接收者是我们自己的服务器节点，我们做的大部分工作都只是围绕Blockchain类方法进行交互。到此，我们的区块链就算完成了，我们来实际运行下 运行区块链你可以使用cURL 或Postman 去和API进行交互 启动server: 12$ python blockchain.py* Runing on http://127.0.0.1:5000/ (Press CTRL+C to quit) 让我们通过请求 http://localhost:5000/mine 来进行挖矿 通过post请求，添加一个新交易 如果不是使用Postman，则用一下的cURL语句也是一样的： 12345$ curl -X POST -H &quot;Content-Type: application/json&quot; -d &apos;&#123; &quot;sender&quot;: &quot;d4ee26eee15148ee92c6cd394edd974e&quot;, &quot;recipient&quot;: &quot;someone-other-address&quot;, &quot;amount&quot;: 5&#125;&apos; &quot;http://localhost:5000/transactions/new&quot; 在挖了两次矿之后，就有3个块了，通过请求 http://localhost:5000/chain 可以得到所有的块信息。 1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;chain&quot;: [ &#123; &quot;index&quot;: 1, &quot;previous_hash&quot;: 1, &quot;proof&quot;: 100, &quot;timestamp&quot;: 1506280650.770839, &quot;transactions&quot;: [] &#125;, &#123; &quot;index&quot;: 2, &quot;previous_hash&quot;: &quot;c099bc...bfb7&quot;, &quot;proof&quot;: 35293, &quot;timestamp&quot;: 1506280664.717925, &quot;transactions&quot;: [ &#123; &quot;amount&quot;: 1, &quot;recipient&quot;: &quot;8bbcb347e0634905b0cac7955bae152b&quot;, &quot;sender&quot;: &quot;0&quot; &#125; ] &#125;, &#123; &quot;index&quot;: 3, &quot;previous_hash&quot;: &quot;eff91a...10f2&quot;, &quot;proof&quot;: 35089, &quot;timestamp&quot;: 1506280666.1086972, &quot;transactions&quot;: [ &#123; &quot;amount&quot;: 1, &quot;recipient&quot;: &quot;8bbcb347e0634905b0cac7955bae152b&quot;, &quot;sender&quot;: &quot;0&quot; &#125; ] &#125; ], &quot;length&quot;: 3&#125; 一致性(共识)我们已经有了一个基本的区块链可以接受交易和挖矿。但是区块链系统应该是分布式的。既然是分布式的，那么我们究竟拿什么保证所有节点有同样的链呢？这就是一致性问题，我们要想在网络上有多个节点，就必须实现一个一致性的算法。 注册节点在实现一致性算法之前，我们需要找到一种方式让一个节点知道它相邻的节点。每个节点都需要保存一份包含网络中其它节点的记录。因此让我们新增几个接口： /nodes/register 接收URL形式的新节点列表 /nodes/resolve 执行一致性算法，解决任何冲突，确保节点拥有正确的链 我们修改下Blockchain的init函数并提供一个注册节点方法： 1234567891011121314151617181920...from urllib.parse import urlparse...class Blockchain(object): def __init__(self): ... self.nodes = set() ... def register_node(self, address): \"\"\" Add a new node to the list of nodes :param address: &lt;str&gt; Address of node. Eg. 'http://192.168.0.5:5000' :return: None \"\"\" parsed_url = urlparse(address) self.nodes.add(parsed_url.netloc) 我们用 set 来储存节点，这是一种避免重复添加节点的简单方法。 实现共识算法前面提到，冲突是指不同的节点拥有不同的链，为了解决这个问题，规定最长的、有效的链才是最终的链，换句话说，网络中有效最长链才是实际的链。 我们使用一下的算法，来达到网络中的共识 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667...import requestsclass Blockchain(object) ... def valid_chain(self, chain): \"\"\" Determine if a given blockchain is valid :param chain: &lt;list&gt; A blockchain :return: &lt;bool&gt; True if valid, False if not \"\"\" last_block = chain[0] current_index = 1 while current_index &lt; len(chain): block = chain[current_index] print(f'&#123;last_block&#125;') print(f'&#123;block&#125;') print(\"\\n-----------\\n\") # Check that the hash of the block is correct if block['previous_hash'] != self.hash(last_block): return False # Check that the Proof of Work is correct if not self.valid_proof(last_block['proof'], block['proof']): return False last_block = block current_index += 1 return True def resolve_conflicts(self): \"\"\" 共识算法解决冲突 使用网络中最长的链. :return: &lt;bool&gt; True 如果链被取代, 否则为False \"\"\" neighbours = self.nodes new_chain = None # We're only looking for chains longer than ours max_length = len(self.chain) # Grab and verify the chains from all the nodes in our network for node in neighbours: response = requests.get(f'http://&#123;node&#125;/chain') if response.status_code == 200: length = response.json()['length'] chain = response.json()['chain'] # Check if the length is longer and the chain is valid if length &gt; max_length and self.valid_chain(chain): max_length = length new_chain = chain # Replace our chain if we discovered a new, valid chain longer than ours if new_chain: self.chain = new_chain return True return False 第一个方法 valid_chain() 用来检查是否是有效链，遍历每个块验证hash和proof. 第2个方法 resolve_conflicts() 用来解决冲突，遍历所有的邻居节点，并用上一个方法检查链的有效性，如果发现有效更长链，就替换掉自己的链 让我们添加两个路由，一个用来注册节点，一个用来解决冲突。 12345678910111213141516171819202122232425262728293031323334@app.route(&apos;/nodes/register&apos;, methods=[&apos;POST&apos;])def register_nodes(): values = request.get_json() nodes = values.get(&apos;nodes&apos;) if nodes is None: return &quot;Error: Please supply a valid list of nodes&quot;, 400 for node in nodes: blockchain.register_node(node) response = &#123; &apos;message&apos;: &apos;New nodes have been added&apos;, &apos;total_nodes&apos;: list(blockchain.nodes), &#125; return jsonify(response), 201@app.route(&apos;/nodes/resolve&apos;, methods=[&apos;GET&apos;])def consensus(): replaced = blockchain.resolve_conflicts() if replaced: response = &#123; &apos;message&apos;: &apos;Our chain was replaced&apos;, &apos;new_chain&apos;: blockchain.chain &#125; else: response = &#123; &apos;message&apos;: &apos;Our chain is authoritative&apos;, &apos;chain&apos;: blockchain.chain &#125; return jsonify(response), 200 你可以在不同的机器运行节点，或在一台机机开启不同的网络端口来模拟多节点的网络，这里在同一台机器开启不同的端口演示，在不同的终端运行一下命令，就启动了两个节点：http://localhost:5000 和 http://localhost:5001 12pipenv run python blockchain.pypipenv run python blockchain.py -p 5001 然后在节点2上挖两个块，确保是更长的链，然后在节点1上访问接口/nodes/resolve ,这时节点1的链会通过共识算法被节点2的链取代。 好啦，你可以邀请朋友们一起来测试你的区块链","tags":[{"name":"比特币","slug":"比特币","permalink":"http://blog.buerya.cn/tags/比特币/"},{"name":"Python","slug":"Python","permalink":"http://blog.buerya.cn/tags/Python/"},{"name":"区块链","slug":"区块链","permalink":"http://blog.buerya.cn/tags/区块链/"},{"name":"区块链技术","slug":"区块链技术","permalink":"http://blog.buerya.cn/tags/区块链技术/"}]},{"title":"区块链记账原理","date":"2018-02-08T07:22:53.000Z","path":"2018/02/08/whatbc/","text":"区块链(1.0)是一个基于密码学安全的分布式账本，是一个方便验证，不可篡改的账本。通常认为与智能合约相结合的区块链为区块链2.0, 如以太坊是典型的区块链2.0很多人只了解过比特币，不知道区块链，比特币实际是一个使用了区块链技术的应用，只是比特币当前太热，把区块链技术的光芒给掩盖了。区块链才是未来，期望各位开发人员少关心币价，多关心技术。本文将讲解区块链1.0技术是如何实现的。 哈希函数在讲区块链记账之前，先说明一下哈希函数。哈希函数：Hash(原始信息) = 摘要信息原始信息可以是任意的信息, hash之后会得到一个简短的摘要信息 哈希函数有几个特点: 同样的原始信息用同一个哈希函数总能得到相同的摘要信息 原始信息任何微小的变化都会哈希出面目全非的摘要信息 从摘要信息无法逆向推算出原始信息 举例说明：Hash(张三借给李四100万，利息1%，1年后还本息 …..) = AC4635D34DEF账本上记录了AC4635D34DEF这样一条记录。 可以看出哈希函数有4个作用： 简化信息很好理解，哈希后的信息变短了。 标识信息可以使用AC4635D34DEF来标识原始信息，摘要信息也称为原始信息的id。 隐匿信息账本是AC4635D34DEF这样一条记录，原始信息被隐匿。 验证信息假如李四在还款时欺骗说，张三只借给李四10万，双方可以用AC4635D34DEF来验证原始信息 哈希函数的这4个作用在区块链技术里有广泛的运用。（哈希函数是一组函数或算法，以后会发文章专门介绍哈希） 区块链记账方法假设有一个账页序号为0的账页交易记录如下: 账号 入账 出账 余额 备注说明 王二 100 190 收到xxx货款 张三 100 30 xxxx 李四 120 90 170 xxxx 记账时间为：2017-10-22 10:22:02 区块链在记账是会把账页信息（包含序号、记账时间、交易记录）作为原始信息进行Hash, 得到一个Hash值，如：787635ACD, 用函数表示为： 1Hash(序号0、记账时间、交易记录) = 787635ACD 账页信息和Hash值组合在一起就构成了第一个区块。 比特币系统里约10分钟记一次账，即每个区块生成时间大概间隔10分钟 在记第2个账页的时候，会把上一个块的Hash值和当前的账页信息一起作为原始信息进行Hash,即： 1Hash(上一个Hash值、序号1、记账时间、交易记录) = 456635BCD 这样第2个区块不仅包含了本账页信息，还间接的包含了第一个区块的信息。依次按照此方法继续记账，则最新的区块总是间接包含了所有之前的账页信息。 所有这些区块组合起来就形成了区块链，这样的区块链就构成了一个便于验证（只要验证最后一个区块的Hash值就相当于验证了整个账本），不可更改（任何一个交易信息的更改，会让所有之后的区块的Hash值发生变化，这样在验证时就无法通过）的总账本。 记账有成本，想了解节点为什么要记账，请看这篇：在比特币如何挖矿-工作量证明","tags":[{"name":"比特币","slug":"比特币","permalink":"http://blog.buerya.cn/tags/比特币/"},{"name":"区块链","slug":"区块链","permalink":"http://blog.buerya.cn/tags/区块链/"},{"name":"区块链技术","slug":"区块链技术","permalink":"http://blog.buerya.cn/tags/区块链技术/"}]},{"title":"比特币是什么","date":"2018-02-05T07:33:53.000Z","path":"2018/02/05/whatisbitcoin/","text":"对于比特币也许一千个人有一千种理解。本文作为入门篇（写给完全没有了解过比特币概念的新手，老手可忽略），我尽量用简单易懂的语言来介绍比特币。到底什么是比特币，它到底是怎么运行的呢。 比特币是什么 比特币是一种基于分布式网络的数字货币。比特币系统（广义的比特币）则是用来构建这种数字货币的网络系统，是一个分布式的点对点网络系统。 本文主要讲解狭义的比特币概念。 数字货币是什么凯恩斯在《货币论》上讲，货币可以承载债务，价格的一般等价物。货币的本质是等价物，它可以是任何东西，如：一张纸，一个数字，只要人们认可它的价值。人民币，美元等作为国家信用货币，其价值由国家主权背书。而数字货币是一种不依赖信用和实物的新型货币，它的价值由大家的共识决定。比特币就是一种数字货币。（我们在网银，微信，支付宝的金额，准确来讲，它是信用货币的数字化，不是数字货币，不过央行也在研究比特币，准备发行数字货币） 运行原理大家知道，在银行系统的数据库里记录着跟我们身份id对应的财产，下文称这样的记录为账本，如张三的卡10月1日转入1w, 余额10w。比特币系统也同样有这样的账本，不同银行由单一的组织负责记录,比特币的记账由所有运行系统的人（即节点，可以简单理解为一台电脑）共同参与记录，每个节点都保存（同步）一份完整的账本。同时使用简单多数原则，来保证账本的一致性。举个例子：如果有人在自己电脑上把自己的余额从1万改为1百万，他这个账本和大多数人的账本不一致，就会被比特币系统认为是无效的。 比特币使用区块链技术来支撑整个系统的运行，有兴趣的同学，可以详细阅读下这几篇博文： 区块链记账原理 比特币所有权问题 比特币如何挖矿 还可进阶阅读：分析比特币网络：一种去中心化、点对点的网络架构，可以详细了解比特币网络。比特币区块结构Merkle树及简单支付验证分析，可以详细了解区块结构如何验证交易。","tags":[{"name":"比特币","slug":"比特币","permalink":"http://blog.buerya.cn/tags/比特币/"},{"name":"区块链","slug":"区块链","permalink":"http://blog.buerya.cn/tags/区块链/"},{"name":"区块链技术","slug":"区块链技术","permalink":"http://blog.buerya.cn/tags/区块链技术/"}]},{"title":"如何学习区块链","date":"2018-02-02T04:45:53.000Z","path":"2018/02/02/learnblockchain/","text":"区块链未来3到5年应该会出现行业井喷式发展，相应所需的人才必定水涨船高，每一个开发人员都不应该错过这样的机会。区块链涉及的技术很多，很多开发人员看了一些资料后，感觉好像懂了，又好像没懂。如何系统的学习区块链技术，是很多想从事区块链开发的程序员的问题，我们来一起讨论下，希望可以帮助更多的人掌握区块链开发技术。 确定方向从事区块链开发也有很多方向，如:区块链应用开发人员、区块链架构师、底层核心开发、共识算法研究等等。 方向不同，需要学习的内容就不一样，如果做基于区块链应用开发，只需要了解一门编程语言（nodejs, Go, Python, C++ 等）, 大概了解区块链的原理，不一定要深入，当能理解越深入开发应用就越顺。如果做区块链基础开发，就需要了解加密算法，P2P通信，共识算法等等。 投入时间学习-动手实践由于区块链涉及的技术很多，可以相对各个技术有一个概念了解，再逐步深入原理。 当你在学习了解概念的时候，必定会产生很多疑问， 例如我们经常可以看到一句： 比特币的共识机制是通过工作量证明（POW）来实现的。就有了新疑问:什么是工作量证明，进一步了解，它是通过验证的一个特定结果，就能确认参与者完成了相应的工作量（不理解没关系，可以简单为，张三考试考了100分，就确认张三肯定好好学习了）。这时又有了新的疑问，比特币在验证什么样的结果，这时你又需要了解密码学和Hash。 逐步深入的过程也是解答疑问的过程，需要我们善用Google搜索。 如果觉得已进理解一个概念或原理时，可以尝试动手实现它，如在理解挖矿后，可以写代码模拟挖矿过程。 学习是一个长期的过期，没有捷径，必须得多读书，读代码，写代码。 学习资源介绍下面是一些学习资源的介绍，相信对大家有帮助 比特币:一种点对点的电子现金系统-英文 比特币:一种点对点的电子现金系统-中文 以太坊白皮书-英文 以太坊白皮书-中文 区块链技术指南-电子书 区块链开发指南-纸书 比特币 - 官网 以太坊 - github 超级账本Hyperledger ETHFANS - 社区","tags":[{"name":"比特币","slug":"比特币","permalink":"http://blog.buerya.cn/tags/比特币/"},{"name":"Python","slug":"Python","permalink":"http://blog.buerya.cn/tags/Python/"},{"name":"区块链","slug":"区块链","permalink":"http://blog.buerya.cn/tags/区块链/"},{"name":"区块链技术","slug":"区块链技术","permalink":"http://blog.buerya.cn/tags/区块链技术/"}]},{"title":"《机器学习有意思！ 03》- 深度学习与卷积神经网络","date":"2018-01-13T04:11:00.000Z","path":"2018/01/13/funny_machine_learning_3/","text":"《机器学习有意思！ 03》- 深度学习与卷积神经网络 原文：Machine Learning is Fun! Part 3 – Deep Learning and Convolutional Neural Networks 作者：Adam Geitgey 你是否厌倦了每天被深度学习相关的新闻轰炸却不明所以？此诚求变之机。 这一次我们将学习如何用深度学习来写程序识别图像中的物体。也可以说我们是要解释Google图片搜索背后的黑科技：Google可以通过描述搜索图片——即使图片没有事先打上标签！这是如何实现的？ 就像Part 1和Part 2一样，本指南仍然面向所有对机器学习感兴趣却不知如何开始的朋友们。我们的目标是所有人都读得懂——因而势必无法照顾到每个细节。但那又如何呢？只要能让一位读者对ML感兴趣，那就是功德一件了！ 深度学习识别物体 产品：每当一名用户拍了照片，APP应该检测他们是否在国家公园…… 开发：当然了，不过是简单的GIS查询而已，给我几个小时。 产品：……以及拍的是不是一只鸟。 开发：那我需要一个研究小组和五年时间。 旁白：在计算机科学中，有时很难解释“简单”和“根本不可能”之间的区别。 你可能已经在xkcd系列漫画中看到过了。 这里的笑点在于，三岁小孩儿都能认出鸟的照片，但是教会计算机识别物体，已经让最优秀的计算机科学家耗费了50年。 在过去的几年里，我们终于找到了物体识别的好路子，那就是深度卷积神经网络。这听起来像是从威廉·吉布森的科幻小说里捡了几个词拼起来的，不过只要分解开来细看，其原理真的很简单。 开始吧——现在就写一个能认识鸟的程序！ 始于足下在我们学习如何辨别鸟的照片之前，先来学个简单得多的例子——手写数字”8”。 在Part 2中，我们已经学习了神经网络如何链接大量的神经元来解决复杂问题。我们搭建了一个迷你神经网络来基于房间数、面积、周边环境预测房价： 我们还知道了机器学习的思想就是重复利用相同的普适算法，根据不同的数据，解决不同的问题。下面我们修改这个神经网络来识别手写文本，并且进一步简化任务——只识别数字”8”。 机器学习只有当你有数据的时候才好使——数据越多越好，所以我们需要大量的手写”8”来开始。所幸，研究者们为了这一目的已经建立了MNIST手写数字数据集。MNIST提供了60,000张手写数字的图片，每个尺寸都是18x18，以下是数据集里部分的”8”： 其实不过是数字 Part 2里搭建的神经网络只读取3个输入（”3”间卧室,”2000”平方米等）。但是现在我们要用神经网络处理图片，不是数字怎么传入神经网络呢？ 答案无比的简单。神经网络以数字为输入，对于计算机来说，图片也不过只是代表了像素明暗的数字： 只要把18x18像素的图片当作324个数字组成的数组，就可以把图片输入给神经网络了。 要处理324个输入，我们只需让神经网络具有324个输入节点： 注意我们的神经网络现在有两个输出（而非之前的一个）。第一个输出是预测此图为”8”的概率，第二个为不是”8”的概率。每种类型的目标物体有了分别的输出，就可以让神经网络对物体进行分类了。 这次的神经网络比之前要大得多了（从3个输入到324），但是现代的计算机处理几百个节点的神经网络，连眼都不带眨的，甚至连手机都能轻松满足。 剩下的就是用”8”和非”8”的数字去训练神经网络以使其能够区分两者了，当我们输入一个”8”，我们告诉神经网络，此图为”8”的概率是100%，非”8”的概率是0%，反之亦反。 这是我们的训练数据： 现在随便一个笔记本电脑，也能在几分钟之内训练完这样一个网络，训练完之后我们就拥有了能够高精度识别数字”8”的神经网络。欢迎来到（1980年代的）图像识别世界！ 管窥把像素简单地导入神经网络里一训练，就能识别图像了，感觉无比清爽。机器学习真乃魔法……也？ 事情并不简单。 首先，一个好消息是，我们的识8器对于图片正中的数字，效果还是很喜人的： 现在坏消息来了： 当数字不是恰好居中的时候，识8器完全失效了，哪怕一丁点的位置偏差也不行： 这是因为，神经网络只学到了恰好居中”8”的模式，但是对于离心的”8”却一无所知，它知道且仅知道一种模式。 在现实中这就实用价值不大了，因为实际问题不可能总是那么干净简约。所以我们必须让神经网络能够处理离心的”8”。 暴力方法 1. 滑动窗口搜索我们已经有了一个好方法，能够找到图片中心的”8”，那可不可以在图片上扫描寻找子区域里的”8”，直至找到呢？ 这就是滑动窗口法，一种非常暴力的解决方案。在很有限的某些例子中可行，但效率也很低。你必须一遍一遍地寻找不同尺寸的物体，我们可以比这更好。 暴力方法 2. 更多数据，更深网络当我们在训练网络的时候，只用到了完美居中的”8”。如果我们在训练过程中就引入不同位置、不同大小的”8”，那会怎么样呢？ 不需要收集更多的训练数据，我们可以写个脚本生成新的图片，图中的”8”具有不同的位置和大小： 应用这一技术，我们可以轻易创造出无穷多的训练数据。 更多的数据让问题变得更加复杂了，但是我们可以用更大的神经网络，那样就能学习更复杂的模式。为了扩大网络，我们简单地把节点层堆叠起来： 这就是“深度神经网络”，因为比传统神经网络的层数更多。这个想法在1960年代便有了，不过直至最近，训练这么大的神经网络训练还是慢得无法接受。但是自从我们发现了用3d显卡替代传统CPU来加速矩阵计算，大规模神经网络就变得可行了。你用来玩守望先锋的NVIDIA GeForce GTX 1080显卡，也可以用来训练神经网络。 然而即便我们可以用显卡很快地训练出大规模神经网络，这仍然不是解决方案的全部，我们还需要在处理图片上更加机智才行。 在暴力方法2中，把图片顶端的”8”和图片底部的”8”当作完全不同的物体，这其实是没有意义的。应该存在一种方案，让神经网络不经额外训练即知：图片不管哪个位置的”8”都是一个东西。万幸，确实是存在的！ 答案：卷积生而为人，你可以直观地看出照片中含有层次或概念结构。考虑这张照片： 作为一个人类，你立即就能识别出照片里的层次： 地面覆盖了草坪 图里有个小孩儿 小孩儿骑在弹跳小马上 弹跳小马在草坪上 更重要的是，无论小孩在什么样的表面上，我们都能认出那是个小孩儿。我们并不需要重新学习各种表面上的小孩儿。但是目前，神经网络还做不到这些，它会把不同位置的”8”当作完全不同的东西，而并不知道在图片上移动物体不会改变其实质。这意味着网络必须重新学习每个位置上的物体，太悲催了。 我们需要让神经网络明白平移不变形——“8”还是”8”，不论出现在图片的哪里。这一过程可由卷积实现，卷积的想法部分来自计算机科学，还有部分是受生物学启发（比如，疯狂科学家们真的在猫脑子里插管，以研究猫是怎么处理图像的人）。 卷积的作用机理这次我们不再把整个图片当成一个数字网格输入到神经网络，而是利用物体与位置的独立性，做得更聪明些。以下就是卷积的作用机理，一步一步来—— 第1步：把图片分解为重叠碎片 与之前的滑动窗口法类似，这里也用一个窗口在整张原图上滑动截图，并且把截到的每一小部分单独存成一个图片： 如此我们便把一张大图拆成了77张等尺寸的小图。 第2步：把每张小图输入小神经网络 曾经我们把单张图片输入神经网络来判断其是否为”8”，这里再重复一样的工作，不过是针对每一个单独的小图片： 这里还有一大诀窍：我们将相同的神经网络权重应用在每一块小图上。换言之，我们平等地对待所有小图，如果某个小图里出现了我们感兴趣的内容，我们就将其标记为有趣。 第3步：把每块小图的结果存入新的阵列 我们并不想丢失原始小图的排列信息，所以我们要把每个小图的结果按照相同的排列重新构建原图，形式如下： 也可以说，我们从一张大图片开始，到小阵列结束，阵列记录了原图当中哪一部分有我们最关心的内容。 第4步：下采样 第3步的结果是一个阵列，反映了原图的哪一部分是我们最感兴趣的，不过这个阵列仍然很庞大： 为了减小阵列的尺寸，我们用最大池化算法进行下采样。听着很稀奇，其实完全不！ 看阵列中的每个2x2方块，并且只留下最大的数字： 这里的主要思路就是，当我们在组成2x2方块的四个输入小图中的任意一个发现了关心的内容，就只保留我们最感兴趣的信息，这可以减小阵列规模并保留最重要的信息。 最终步：预测 至此，我们已经把一个巨大的图片消减成了相对较小的阵列，阵列就是一串数，所以我们可以把小阵列输入另一个神经网络，最后的这个神经网络会决定图片是否匹配。为了与卷积层相区分，我们称之为“全连接层”。从头到尾，我们的五步流水线如下图所示： 增加更多步骤 我们的图像处理流水线有一系列步骤：卷积，最大池化，全连接网络。 而在解决实际问题的时候，这些步骤可以组合起来并堆叠多次。你可以加两个，三个甚至十个卷积层，也可以在任何时候插入一个最大池化层。总之基本思路就是把一张大图，逐步分解为小图，直至我们能够获得结果。卷积层越多，网络就能学习识别越复杂的特征。 比如说，第一个卷积层可能学会了辨认锐利边缘，第二个卷积层可能根据锐边的知识学会了识别鸟喙，第三个卷积层又基于鸟喙识别出了整只鸟。以下是更贴近实践的深度卷积网络结构（学术论文里常见）： 在这一实例中，他们从224x224像素的图片开始，应用了：卷积，两次最大池化，三次卷积，又是两次最大池化，最后是两个全连接层。最终的结果可以将图片从1000个分类中识别出来。 构建正确的网络 那么我们要怎么知道什么时候该用什么层呢？诚然，你得经过大量的实践和测试才能回答，可能训练100个网络才能找到最佳的结构和参数。机器学习就是包含了大量的尝试和错误！ 构建鸟分类器如今我们已经足以写出一个程序来判断一张图上是不是鸟类。一如既往，我们需要训练数据来开始。免费的CIFAR10数据集包括了60,000张鸟类图片和52,000张非鸟图片。如果要更多的数据，我们还需要加入Caltech-UCSD Birds-200-2011数据集，内含12,000张鸟类图片。 这是组合数据集的一部分鸟图： 以及一部分非鸟图： 这一数据集可以很好地满足我们的需求，不过相对于真实世界的应用而言，72,000张低分辨率图片还是太少，如果你想要达到Google级的水平，你需要上百万张高清无码大图。在机器学习中，数据多总是比算法好更重要。现在你就知道Google为什么那么乐意提供无限照片存储了，他们要的是你的数据啊，数据！ 原作者使用的是TFLearn，译注者改用了国内更流行的Keras。TFLearn代码可见作者原文。 Keras封装了TensorFlow和Theano两个深度学习库并提供了简单易用的API，这使得开发者可以仅用几行就搭建一个卷积神经网络。 以下是定义并训练网络的代码： 导入数据 Keras内置了CIFAR10数据集，但是需要从网络上下载。 Keras导入CIFAR10数据集:123456789101112131415161718192021222324252627# 导入相关库from matplotlib import pyplotfrom scipy.misc import toimageimport numpyfrom keras.models import Sequentialfrom keras.layers import Densefrom keras.layers import Dropoutfrom keras.layers import Flattenfrom keras.constraints import maxnormfrom keras.optimizers import SGDfrom keras.layers.convolutional import Convolution2Dfrom keras.layers.convolutional import MaxPooling2Dfrom keras.utils import np_utilsfrom keras import backend as K# 定义训练集、测试集(X_train, y_train), (X_test, y_test) = cifar10.load_data()print(\"Datasets is ready!\")# 预览部分图片for i in range(9): pyplot.subplot(330 + 1 + i) pyplot.imshow(toimage(X_train[i]))pyplot.show() 搭建神经网络 下面导入其他将会用到的Keras相关模块并对数据进行预处理。Keras搭建神经网络的过程其实非常简单直观，就像搭积木一样。 首先确定网络的基本结构，这里就用最基本Sequential()串型拓扑，并建立网络模型对象model。 之后便是给model中一层层地添加网络，添加的方式也很简单，就是使用model.add()方法，逐个地把卷积层(Convolution2D)、池化层(MaxPooling2D)、全连接层(Dense)等插入到model里，形成整个神经网络。 Keras搭建神经网络1234567891011121314151617181920# 对标签进行独热码编码y_train = np_utils.to_categorical(y_train)y_test = np_utils.to_categorical(y_test)num_classes = y_test.shape[1]# 设置神经网络对象modelmodel = Sequential()model.add(Convolution2D(32,3,3,input_shape=(32,32,3), border_mode='same',activation='relu', W_constraint=maxnorm(3)))model.add(Dropout(0.2))model.add(Convolution2D(32,3,3,activation='relu', border_mode='same',W_constraint=maxnorm(3)))model.add(MaxPooling2D(pool_size=(2,2)))model.add(Flatten())model.add(Dense(512,activation='relu',W_constraint=maxnorm(3)))model.add(Dropout(0.5))model.add(Dense(num_classes,activation='softmax'))print(\"Neural Network built!\") 编译、训练、预测 经过以上过程，我们已经有了一个神经网络的外壳，但也仅仅是外壳，你会注意到上面这个代码模块运行的很快，因为这只是根据神经网络的设置形成了一个容器，内部还是空空如也。还要经过“编译”并且导入数据进行“训练”，我们才真正拥有了“有血有肉”的神经网络。最后通过与测试集的对比，衡量神经网络的表现。 虽然数据量并不大，但是训练神经网络对于普通CPU来说，还是个比较艰巨的任务，因此训练速度可能堪忧。我们的网站后台暂时还未提供GPU接口，所以这里只能先将训练迭代次数设为1，以后我们会争取提供更强大的计算资源。 1234567891011121314151617# 设定训练过程epoches = 1 # 对训练集的迭代次数（这里设为最小的1）lrate = 0.01 # 初始学习率decay = lrate/epoches# 优化器设置与编译sgd = SGD(lr=lrate, momentum=0.9, decay=decay, nesterov=False)model.compile(loss='categorical_crossentropy',optimizer=sgd,metrics=['accuracy'])print(model.summary())# 用训练集数据训练网络model.fit(X_train, y_train, validation_data=(X_test, y_test), nb_epoch=epoches, batch_size=32, verbose=1)# 输出神经网络的表现scores = model.evaluate(X_test, y_test, verbose=0)print(\"Accuracy: %.2f%%\") % (scores[1]*100) 如果你有个不错的显卡和足够的显存（比如Nvidia GeForce GTX 980 Ti或以上），大概一个小时可以训练完，如果用CPU的话可能就要久的多了。 精度随着训练进程儿上升。第一轮过后，我的精度只有75.4%；经过十轮，精度已经提高到91.7%；在50轮以后，精度攀升到95.5%，再训练已经收效甚微了，因此我就此打住。 Congrats!现在我们的程序可以识别图片里的鸟了！ 测试网络有了训练过的神经网络，是骡子是马该拉出来遛遛。这一简单的脚本读取一个图片文件并判断是否是鸟。 为了真正检验我们的神经网络是否有效，需要测试大批的图片。我这里用了15,000张图片作为验证集，当我把这15,000张图传递给神经网络，95%都得到了正确答案。 听起来很好，对吧？其实这可未必！ 95%是多准确？ 我们的神经网络号称有95%的准确度，但是细微之处见真章，面子上95%，里子可能千差万别。比如说，如果我们的训练图片里5%是鸟，而另外95%不是鸟，然后一个程序只输出“不是鸟”就可以达到95%的精度，但这毫无意义。 我们需要进一步细究这个数字，而不是满足于一个含糊的95%。为了判断一个分类系统的作用究竟几何，我们需要考察它是如何失效的，而不是失效的百分比。抛掉单纯的“对／错”标准，我们来把问题细分为四种分别的情况—— 把鸟正确地识别为鸟：True Positives 把不是鸟的正确地排除出去：True Negatives 以为是鸟，结果不是：False Positives（错杀三千） 其实是鸟，以为不是：False Negative（放过一个） 根据我们这15,000张图片，以下为各种情况的统计数据： 为什么要这样细分结果呢？因为并非每种错误都是均等的。想象一下，如果我们在写一个根据MRI图像诊断癌症的程序，这时候宁可引入False Positive也不要带有False Negative。前者只是让患者虚惊一场，后者可就是延误治疗了。 所以出了宽泛的准确度，我们还计算精确率和召回率。精确率和召回率更加清晰地定义了分类起的效用。 由上表可知，当我们给出“是鸟”的猜测时，其中97%是对的。但是我们却只找出了90%的鸟，这意味着我们可能不是所有鸟都认得，但是认鸟却很准！","tags":[{"name":"技术知识","slug":"技术知识","permalink":"http://blog.buerya.cn/tags/技术知识/"},{"name":"人工智能","slug":"人工智能","permalink":"http://blog.buerya.cn/tags/人工智能/"},{"name":"机器学习","slug":"机器学习","permalink":"http://blog.buerya.cn/tags/机器学习/"}]},{"title":"《机器学习有意思！ 02》- 使用机器学习生成超级玛丽关卡","date":"2018-01-12T10:11:00.000Z","path":"2018/01/12/funny_machine_learning_2/","text":"《机器学习有意思！ 02》- 使用机器学习生成超级玛丽关卡 原文：Machine Learning is Fun! Part 2 – Using Machine Learning to generate Super Mario Maker levels 作者：Adam Geitgey 在系列的Part 1中我们已经讲过，机器学习是用普适的算法从数据中挖掘出有趣的东西，而无需针对具体问题写代码。 这次我们将见识一种普适算法的炫酷表现——创造乱真的游戏关卡。我们将建立一个神经网络，导入已有的超级马里奥数据，然后创造新的关卡。 正如Part 1一样，本系列教程适合所有对机器学习感兴趣、但却不知从何开始的读者。希望所有人都能读懂——所以难免会有些粗疏。不过但凡能把一个人带进ML的坑里，也就算没白写。 猜得更机智在Part 1中，我们写了一个简单的算法来根据房产的属性预测价格，数据如下表所示： 预测函数是这样的： 12345678910111213def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood): price = 0 # 加少量配方1 price += num_of_bedrooms * 0.123 # 加大把配方2 price += sqft * 0.41 # 适量的配方3 price += neighborhood * 0.57 return price 也就是说，房价的预测值是由每种属性乘以权重再相加得到的。用图形来表示： 箭头代表函数权重 但是这个算法只对很简单的线性问题有效，如果房价背后的真实规律没有那么简单呢？比如周边环境可能对特别大或特别小的房子影响显著，但对于中间房型则没有什么影响。如何才能捕捉到这些复杂细节呢？ 为了更加的机智，我们可以用不同的权重多次执行算法，每一组权重对应不同的边界情况。 尝试用4种方法解决问题 现在我们有四个价格预测了，然后再把这4个组合成最终结果，并且也是通过加权（只是权重值变了）。 新的超级答案结合了四次求解尝试，所以相比于初始的简单模型，能够模拟更多的情况。 什么是神经网络？把我的四次求解尝试整合到一张大图里： 这就是一个神经网络！那个节点都有一组输入，执行加权计算，产生一个输出值。把这些节点串起来就能够对复杂函数进行建模了。 为了节省篇幅，这里我跳过了很多内容（比如特征缩放和激励函数），但是最重要的部分还是以下几点基本思想： 我们用简单的函数，对输入进行加权获得输出，这个简单函数就叫神经元。 把许多简单的神经元链在一起，就可以对单个神经元描述不了的复杂问题进行建模。 就像乐高一样，单个积木块或许做不出什么，但只要有足够多的积木，就什么都能搭建。 我们的未来会如同塑料玩具一样吗？只有时间知道答案。 让神经网络有记忆给定相同的输入，此前的神经网络也会给出相同的输出，用编程术语叫无状态算法(stateless algorithm)。 在很多实例（比如房价预测）中，这正是我们想要的。但是这类模型无法应对数据中的时变模式。 想象一下，我给了你一个键盘，让写个故事。在开始之前，我要猜你会写哪个字母，那么我该怎么猜呢？ 我可以利用我的英语知识来增加命中率，比如你写的第一个字母往往是一个单词的首字母。如果我看过你的过往文章，还可以进一步根据你的文风收缩范围。如果我有全部数据，我就可以搭建一个神经网络，来计算你写下一个字母的概率。 模型可能是这样： 再来看一个更有挑战的问题，随便在故事里定个位，然后我要猜你的下一个字母，这就更有意思了。 用海明威的《太阳照常升起》作为例子： Robert Cohn was once middleweight boxi 下一个字母是什么？ 你大概会猜’n’——这个词应该是boxing。这样的猜测是基于我们已知的常用英语单词积累。同时，’middleweight’ 也给出了额外的线索指向boxing。 下一个字母好猜，是因为我们纳入了其之前的句子，并结合已有的语言知识。 如果要用神经网络来解决这个问题，我们需要在模型中添加一个状态(state)，每次我们向神经网络询问答案的时候，还会获得一个中间计算，并在下次当作输入的一部分重复利用。如此一来，我们的模型就会根据之前的输入调整预测结果。 跟着状态走，虽然不能猜第一个字母，但却可以根据前面的字母猜下一个。 这就是循环神经网络(Recurrent Neural Network)的基本思路。每次使用，我们都是在更新网络，这就可以基于之前最常见的输入，去更新预测。只要“记忆力”足够，这就可以对数据的时变模式进行建模。 一个字母好干什么？猜测故事里的下一个字母挺起来没有什么卵用，那还提这茬干嘛？ 手机输入法的自动补全就是一个应用： 下一个字母是”t” 往计算情况再想想，如果我们让模型猜完一个再猜一个，如此循环往复——我们就可以让计算机自己来写个故事了！ 生产故事知道了如何猜海明威句子里的下一个字母，让我们试着产生一个完整的海明威风格故事。 我们将使用Andrej Karpathy开发的循环神经网络。Andrej是斯坦福大学的深度学习研究者，并且他写了一个极好的循环神经网络文本生成入门，你可以在GitHub查看完整代码。 模型建立在《太阳照常升起》的文本数据基础上——362,239个字，84个字符（包括标点符号）。相比于实际应用，这一数据量其实小的很。为了真正搭建一个好的海明威文风的模型，至少需要若干倍的样本文字量，不过对于一个入门实例来讲，现在的就足够了。 刚开始训练RNN的时候，预测能力还不太行，这是100次训练迭代后的成果： hjCTCnhoofeoxelif edElobe negnk e iohehasenoldndAmdaI ayio pe e h’e btentmuhgehi bcgdltt. gey heho grpiahe. Ddelnss.eelaishaner” cot AAfhB ht ltny ehbih a”on bhnte ectrsnae abeahngy amo k ns aeo?cdse nh a taei.rairrhelardr er deffijha 可以看见词与词之间已经有空格了。 1000次迭代之后，明显看起来更上道了： hing soor ither. And the caraos, and the crowebel for figttier and ale the room of me? Streat was not to him Bill-stook of the momansbed mig out ust on the bull, out here. I been soms inick stalling that aid. “Hon’t me and acrained on .Hw’s don’t you for the roed,” In’s pair.” “Alough marith him.” 模型已经识别出了基本句型模式，并且知道在句末加句号，给对话加引号，个别单词已经能读懂了，但整篇仍是一派胡言。 又经过几千次迭代之后，现在已经看起来非常好了： He went over to the gate of the café. It was like a country bed. “Do you know it’s been me.” “Damned us,” Bill said. “I was dangerous,” I said. “You were she did it and think I would a fine cape you,” I said. “I can’t look strange in the cab.” “You know I was this is though,” Brett said. “It’s a fights no matter?” “It makes to do it.” “You make it?” “Sit down,” I said. “I wish I wasn’t do a little with the man.” “You found it.” “I don’t know.” “You see, I’m sorry of chatches,” Bill said. “You think it’s a friend off back and make you really drunk.” 至此，算法已经捕捉到了海明威对话短小精悍的特征，有些句子甚至已经能够达意了。 跟书中的真实文本对照一下： There were a few people inside at the bar, and outside, alone, sat Harvey Stone. He had a pile of saucers in front of him, and he needed a shave. “Sit down,” said Harvey, “I’ve been looking for you.” “What’s the matter?” “Nothing. Just looking for you.” “Been out to the races?” “No. Not since Sunday.” “What do you hear from the States?” “Nothing. Absolutely nothing.” “What’s the matter?” 即便是循着单个字母的模式，我们的算法已经模仿得有鼻子有眼了，这好的很呐！ 无需从零开始生成文本，我们可以提供前几个字母作为“种子”，然后让算法自己寻找后面的。 出于娱乐目的，我们来做一本假书，用”Er”,”He”,”The S”作为种子生成新的作者名字和新标题： 左：真书；右：计算机生成的假书 还不赖！ 真正令人振奋的是，这一算法可以从任意数据中识别模式，能够轻易地生成以假乱真的菜谱和假的奥巴马讲话。为什么要局限在人类语言当中呢？我们大可以应用在任何内含模式的数据之中。 你可能玩了假的马里奥2015年，任天堂推出了用于Wii U游戏机的超级马里奥编辑器。 这个游戏让你可以自由设计超级马里奥的关卡，并且上传到网上和朋友们分享。你可以加入老游戏中的所有经典机关和敌人，简直是马里奥时代生人的虚拟乐高。 能不能用生成假海明威文字的模型，来生成假马里奥关卡呢？ 首先需要准备训练数据，从1985年原版超级马里奥兄弟里提取出所有的室外关卡。游戏中共有32关，其中约70%是在室外，所以就从这下手。 为了获取每个关卡的设计，我写了一个程序从游戏中提取出关卡设计，超级马里奥已有三十多年历史，所以网上关于游戏设计的资源非常多。从老游戏中提取数据也是个很有意思的编程练习，你也可以试一试。 凑近了看，游戏关卡其实是由一组物体网格构成的： 我们可以用一组字符来代表这个网格，每个字符就是一个物体： 123456789101112------------------------------------------------------------------------------#??#-----------------------------------------------------------------------------------------------------##------=--=----------==---------==--==--------===--------===--===------====-------====--====----=====-=========================- 每个物体是一个字符： ‘-‘是空白 ‘=’是实心砖 ‘#’是可以打破的砖 ‘?’是硬币砖 字符替换后的效果就是这样： 观察文本文件可以发现，马里奥的关卡如果逐行来看，并没有什么模式： 但是如果逐列来看，模式就很明显了： 逐列看，模式很明显，比如每列都是以’=’结束的 为了让算法能够识别模式，需要逐列输入数据。从输入数据中找出最有效的表征方式（即特征选择）是用好机器学习算法关键。 为了训练模型，我们把文本文件反转90度，这让特征更加显而易见： 12345678910111213141516171819202122-----------=-------#---=-------#---=-------?---=-------#---=-----------=-----------=----------@=----------@=-----------=-----------=-----------=---------PP=---------PP=----------==---------===--------====-------=====------======-----=======---=========---========= 训练模型就像模仿海明威文风的例子一样，模型是越训练越好的。只经过很少量训练的结果，看起来真垃圾： 1234567891011--------------------------LL+&lt;&amp;=------P------------------------------------------T--#--------=--=-=------------=-&amp;--T------------------------------------=------$-=#-=-_--------------=----=&lt;-----------b- 大概摸索出了’-‘和’=’出现的比较多，但仅仅如此，没有真正发现什么模式。 经过几千次迭代，开始有点样子了： 1234567891011-------------=----------=--------PP=--------PP=-----------=-----------=-----------=-------?---=-----------=-----------= 模型已经基本知道了每行的长度应该一致，并且也开始发现了游戏中的一些特点：管子总是两块宽、至少两块长，所以”P”以2X2的小组出现，这很不错！ 在更多的训练之后，模型已经生成了很多有效的数据： 12345678--------PP=--------PP=----------=----------=----------=---PPP=---=---PPP=---=----------= 来看看模型生成的完整关卡（转回横版）： 看起来相当好！有几个亮点值得注意： 开始有一个Lakitu（空中浮游怪）在天上——就像真实的马里奥关卡一样。 空中的管子必须底部有砖块，而不能孤立地飘在半空。 怪物的分布比较合理。 不会出现组织玩家前进的死路。 感觉上确实很像一个真实的关卡。 如果你有超级马里奥编辑器的话，你可以通过bookmarking it online或者查找代码4AC9-0000-0157-F3C3来玩这一关卡。 玩具和真货我们用来训练模型的循环神经网络算法，跟现实世界里很多公司用来解决难题（如语音识别，机器翻译）的算法是一样的。但我们的模型只建立在很少的数据量之上，所以只能算是一种“玩具”而不能动真格的。原版超级马里奥游戏里的关卡数不足以训练出一个真正好的模型。 如果我们能像任天堂一样，拿到数以十万计的玩家自制关卡数据，我们就可以做个更强的模型了。不过任天堂不会坐视其发生的，大公司都不会免费开放数据。 随着机器学习在很多行业里越来越重要，好程序和坏程序的差别越来越多地体现在，训练模型的数据量。这就是为什么Google和Facebook等公司如此需要你的数据。 比如Google最近开源了用于搭建大规模机器学习应用的软件包TensorFlow，Google免费开放了如此重要而强力的技术，引起了巨大反响，而TensorFlow正是支撑Google Translate的后台。 但如如果没有Google在每种语言上留下的海量数据宝藏，你也不可能做出Google Translate的对手，数据才是Google真正的杀手锏。下次当你打开Google Maps Location History或Facebook Location History的时候，留意它们记录了你的一切所到之处。","tags":[{"name":"技术知识","slug":"技术知识","permalink":"http://blog.buerya.cn/tags/技术知识/"},{"name":"人工智能","slug":"人工智能","permalink":"http://blog.buerya.cn/tags/人工智能/"},{"name":"机器学习","slug":"机器学习","permalink":"http://blog.buerya.cn/tags/机器学习/"}]},{"title":"ConstraintLayout 完全解析","date":"2018-01-11T03:21:00.000Z","path":"2018/01/11/android_constraintlayout/","text":"ConstraintLayout 完全解析 原文链接：ConstraintLayout 完全解析 快来优化你的布局吧 作者：张鸿洋 一、概述ConstraintLayout出现有一段时间了，不过一直没有特别去关注，也多多少少看了一些文字介绍，多数都是对使用可视化布局拖拽，个人对拖拽一直不看好，直到前段时间看到该文： 解析ConstraintLayout的性能优势 非常详尽的介绍了ConstraintLayout的性能优势，于是乎开始学习了一下ConstraintLayout。 本文的重点不在与可视化界面的学习，而在于如何手写各类约束布局属性。对于可视化界面学习推荐： Android新特性介绍，ConstraintLayout完全解析 下面开始进入正题，大家都知道，当布局嵌套深入比较深的时候，往往会伴随着一些性能问题。所以很多时候我们建议使用RelativeLayout或者GridLayout来简化掉布局的深度。 而对于简化布局深度，ConstraintLayout几乎可以做到极致，接下来我们通过实例来尽可能将所有常见的属性一步步的介绍清楚。 首先需要引入我们的ConstraintLayout，在build.gradle中加入： 1compile &apos;com.android.support.constraint:constraint-layout:1.0.2&apos; 二、来编写一个Feed Item我们先看一个简单的新闻列表中常见的feed item。 看到这样的布局，大家条件反射应该就是使用RelativeLayout来做，当然了，本案例我们使用ConstraintLayout来写： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#11ff0000\" tools:context=\"com.zhy.constrantlayout_learn.MainActivity\"&gt; &lt;TextView android:id=\"@+id/tv1\" android:layout_width=\"140dp\" android:layout_height=\"86dp\" android:layout_marginLeft=\"12dp\" android:layout_marginTop=\"12dp\" android:background=\"#fd3\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; &lt;TextView android:id=\"@+id/tv2\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"8dp\" android:layout_marginRight=\"12dp\" android:text=\"马云:一年交税170多亿马云:一年交税170多亿马云:一年交税170多亿\" android:textColor=\"#000000\" android:textSize=\"16dp\" app:layout_constraintLeft_toRightOf=\"@id/tv1\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"@id/tv1\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"8dp\" android:layout_marginTop=\"12dp\" android:text=\"8分钟前\" android:textColor=\"#333\" android:textSize=\"12dp\" app:layout_constraintLeft_toRightOf=\"@id/tv1\" app:layout_constraintBottom_toBottomOf=\"@id/tv1\" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 看上面的布局，我们好像看到了几个模式的属性： 首先是tv1，有两个没见过的属性： app:layout_constraintLeft_toLeftOf=”parent” 从字面上看，指的是让该控件的左侧与父布局对齐，当我们希望控件A与控件B左侧对齐时，就可以使用该属性。 1app:layout_constraintLeft_toLeftOf=\"@id/viewB\" 类似的还有个相似的属性为： app:layout_constraintLeft_toRightOf 很好理解，即当前属性的左侧在谁的右侧，当我们希望控件A在控件B的右侧时，可以设置： 1app:layout_constraintLeft_toRightOf=\"@id/viewB\" 与之类似的还有几个属性： layout_constraintRight_toLeftOf layout_constraintRight_toRightOf layout_constraintTop_toTopOf layout_constraintTop_toBottomOf layout_constraintBottom_toTopOf layout_constraintBottom_toBottomOf layout_constraintBaseline_toBaselineOf 类推就可以了。 现在在头看刚才的布局： 123456789101112131415tv1设置了：app:layout_constraintLeft_toLeftOf=\"parent\"app:layout_constraintTop_toTopOf=\"parent\"tv2设置了：app:layout_constraintLeft_toRightOf=\"@id/tv1\"app:layout_constraintRight_toRightOf=\"parent\"app:layout_constraintTop_toTopOf=\"@id/tv1\"tv3设置了：app:layout_constraintLeft_toRightOf=\"@id/tv1\"app:layout_constraintBottom_toBottomOf=\"@id/tv1\" 按照我们刚才的理解，再次的解读下： tv1应该是在父布局的左上角； tv2在tv1的右侧，tv2的右侧和父布局对其，tv2和tv1顶部对齐； tv3在tv1的右侧，tv3和tv1底部对其。 到这里，大家可以看到，目前我们已经可以控制任何一个控件与其他控件间的相对位置了，以及与parent间的相对位置。 和RL的差异大家是不是觉得目前来看和RelativeLayout特别像？ 其实还是有很明显的区别的，我们通过一个例子来看一下： 123456789101112131415161718&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;Button android:id=\"@+id/id_btn01\" android:layout_width=\"100dp\" android:text=\"Btn01\" android:layout_height=\"wrap_content\" /&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_toRightOf=\"@id/id_btn01\" android:text=\"Btn02\" android:layout_alignParentRight=\"true\" /&gt;&lt;/RelativeLayout&gt; 那么经过我们刚才的学习，把： layout_toRightOf=”@id/id_btn01”layout_alignParentRight=”true” 分别替换为： app:layout_constraintLeft_toRightOf=”@id/id_btn01”app:layout_constraintRight_toRightOf=”parent” 是不是觉得so easy ，但是我们看一下效果图： 是不是和预期有一定的区别，假设你将Btn02的宽度设置的非常大，你会发现更加诡异的事情： 你会发现Btn02，好像疯了一样，我们设置的在btn01右侧，和与parent右侧对齐完全失效了！！！ 别怕，接下来就让你认识到为什么这个控件叫做“Constraint”Layout。 在当控件有自己设置的宽度，例如warp_content、固定值时，我们为控件添加的都是约束“Constraint”，这个约束有点像橡皮筋一样会拉这个控件，但是并不会改变控件的尺寸（RL很明显不是这样的）。 例如上例，当btn02的宽度较小时，我们为其左侧设置了一个约束（btn01右侧），右侧设置了一个约束（parent右侧对其），当两个约束同时生效的时候（你可以认为两边都是相同的一个拉力），btn02会居中。 当btn02特别大的时候，依然是这两个力，那么会发生什么？会造成左侧和右侧超出的距离一样大。 那么现在大家肯定有些疑问： 怎么样才能和上面的RL一样，宽度刚好占据剩下的距离呢（btn01右侧到屏幕右侧的距离）？ 这个问题，问得很好，我们刚才所有的尝试都是在控件自身拥有特定的宽度情况下执行的；那么如果希望控件的宽度根据由约束来控件，不妨去掉这个特定的宽度，即设置为0试试？ 对！当我们将btn02的宽度设置为0时，一切又变得很完美。 那么这里，你可能会问0值是什么含义，其实在ConstraintLayout中0代表：MATCH_CONSTRAINT，看到这个常量，是不是瞬间觉得好理解了一点。 最后一个问题，MATCH_PARENT哪去了? 看官网的解释： Important: MATCH_PARENT is not supported for widgets contained in a ConstraintLayout, though similar behavior can be defined by using MATCH_CONSTRAINT with the corresponding left/right or top/bottom constraints being set to “parent”.` 所以你可以认为：在ConstraintLayout中已经不支持MATCH_PARENT这个值了，你可以通过MATCH_CONSTRAINT配合约束实现类似的效果。 三、增加一个banner我们现在以往在这个feed item顶部添加一个banner，宽度为占据整个屏幕，宽高比为16：6。 这里尴尬了，在之前的做法，很难在布局中设置宽高比，一般我们都需要在代码中显示的去操作，那么如果你用了ConstraintLayout，它就支持。 看一眼如何支持： 12345678910111213141516171819202122&lt;android.support.constraint.ConstraintLayout ... tools:context=\"com.zhy.constrantlayout_learn.MainActivity\"&gt; &lt;TextView android:id=\"@+id/banner\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:background=\"#765\" android:gravity=\"center\" android:text=\"Banner\" app:layout_constraintDimensionRatio=\"H,16:6\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" /&gt; &lt;TextView android:id=\"@+id/tv1\" app:layout_constraintTop_toBottomOf=\"@id/banner\" &gt;&lt;/TextView&gt; ...&lt;/...&gt; 我们添加了一个banner，还记得我们刚才所说的么，不要使用match_parent了，而是设置match_contraint，即0，让约束来控制布局宽高。 所以我们设置了宽、高都是match_contraint，然后这两个属性： 12app:layout_constraintLeft_toLeftOf=&quot;parent&quot;app:layout_constraintRight_toRightOf=&quot;parent&quot; 让我们的宽度充满整个父布局，在添加一个： 1app:layout_constraintDimensionRatio=&quot;16:6&quot; 该属性指的是宽高比，所以16：6就可以完成我们的需求。 好了看下效果图： 这个宽高比属性，还支持这样的写法： 12app:layout_constraintDimensionRatio=&quot;W,16:6&quot;app:layout_constraintDimensionRatio=&quot;H,16:6&quot; 可以自己试验下。 好了，到这里，我们又新增了一个属性，还是个非常实用的属性。 那么，我们继续，再看一个似曾相识的功能。 四、增加几个Tab现在我们希望在底部增加3个tab，均分。是不是想到了LinearLayout和weight。 没错！ConstraintLayout也支持类似的属性。 虽然我知道，但是写到这我还是有点小惊喜~~ 看下如何实现： 12345678910111213141516171819202122232425262728293031323334&lt;TextView android:id=\"@+id/tab1\" android:layout_width=\"0dp\" android:layout_height=\"30dp\" android:background=\"#f67\" android:gravity=\"center\" android:text=\"Tab1\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toLeftOf=\"@+id/tab2\" /&gt;&lt;TextView android:id=\"@+id/tab2\" android:layout_width=\"0dp\" android:layout_height=\"30dp\" android:background=\"#A67\" android:gravity=\"center\" android:text=\"Tab2\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toRightOf=\"@id/tab1\" app:layout_constraintRight_toLeftOf=\"@+id/tab3\" /&gt;&lt;TextView android:id=\"@+id/tab3\" android:layout_width=\"0dp\" android:layout_height=\"30dp\" android:background=\"#767\" android:gravity=\"center\" android:text=\"Tab3\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toRightOf=\"@id/tab2\" app:layout_constraintRight_toRightOf=\"parent\" /&gt; 我们增加3个textview来冒充tab。我们看横向的依赖，3个tab两两设置了约束（即你在我们的左边，我在你的右边），最外层的设置了parent约束；再加上我们把宽度都设置为了match_constraint，so，这样我们就完成了3个tab等分。 看一眼效果图： 你可能会说，LL配合weight更加灵活，可以单个设置占据的比例。 对，没错，我们也支持，我不是还没说完么。 现在我们可以给每个tab设置一个属性： 1app:layout_constraintHorizontal_weight 看到这个名字，应该就明白了吧，假设我们分别设置值为2，1，1。 效果图为： 是不是很惊喜，别急，刚才你说我不如LL，现在我要让你再看一些LL配合weight做不到的。 这里需要借助几张官网上的图了： 刚才我们说了，3个tab两两设置了依赖，即类似下图： 横向的相当于组成了一个链(Chains)。在这个链的最左侧的元素成为链头，我们可以在其身上设置一些属性，来决定这个链的展示效果： 该属性为： 1layout_constraintHorizontal_chainStyle 我们已经见过一种效果了，即按照weight等分，可以成为weighted chain。设置条件为：chainStyle=”spread”，所有控件宽度设置为match_constraint，因为默认就是spread，所以我们没有显示设置。 其取值还可以为： packed spread_inside 我还是分别显示一下吧： spread + 宽度为0，且可以通过weight控制分配比例 spread_inside + 宽度非0 packed + 宽度非0 好了，差不多了，我们可以在横向或者纵向组成一个Chain，然后在Chain head设置chainStyle来搞一些事情。 官网有个图： 前四个我们都演示了，最后一个设计到一个新的bias属性，别急，咱们慢慢说~~ 好了，到这里，我们再次见证了ConstraintLayout的强大。 我们最后再看一个例子。 五、增加浮动按钮一个很常见的功能，我们现在希望在右下角增加一个浮动按钮。 看下如何实现： 12345678910111213141516&lt;android.support.constraint.ConstraintLayout ... tools:context=\"com.zhy.constrantlayout_learn.MainActivity\"&gt; &lt;TextView android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:background=\"#612\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintHorizontal_bias=\"0.9\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.9\" /&gt;&lt;/....&gt; 我们在最后追加一个TextView冒充我们的浮动按钮。可以看到我们设置了固定值，被设置约束为右下角。 正常情况我们可以通过margin来设置与右侧与底部的距离。 但是这里我们尝试使用量个新的属性： 12layout_constraintHorizontal_biaslayout_constraintVertical_bias 即设置上下两侧间隙比例分别为90%与10%。这个很好理解，我们之前说了，再没有bias这个属性的时候，这两侧的拉力大小是一样的，但是你可以通过bias来控制哪一侧的力要大一些~~明白了么~ 所以，该属性可以用于约束之前，控制两侧的“拉力”。 我们看一下效果图： 那么到这里，ConstraintLayout的属性我们基本上介绍完了： 我们看一下： 1234567891011121314151617181920212223242526272829303132333435layout_constraintLeft_toLeftOflayout_constraintLeft_toRightOflayout_constraintRight_toLeftOflayout_constraintRight_toRightOflayout_constraintTop_toTopOflayout_constraintTop_toBottomOflayout_constraintBottom_toTopOflayout_constraintBottom_toBottomOf# 即文章的baseline对齐layout_constraintBaseline_toBaselineOf# 与left,right类似layout_constraintStart_toEndOflayout_constraintStart_toStartOflayout_constraintEnd_toStartOflayout_constraintEnd_toEndOf# margin不需要解释android:layout_marginStartandroid:layout_marginEndandroid:layout_marginLeftandroid:layout_marginTopandroid:layout_marginRightandroid:layout_marginBottomlayout_constraintHorizontal_bias layout_constraintVertical_bias layout_constraintHorizontal_chainStylelayout_constraintVertical_chainStylelayout_constraintVertical_weightGuideline 好像，还有个比较特殊的，叫Guideline。 好吧，继续~ 六、尝试使用Guidelineandroid.support.constraint.Guideline该类比较简单，主要用于辅助布局，即类似为辅助线，横向的、纵向的。该布局是不会显示到界面上的。 所以其有个属性为： android:orientation取值为”vertical”和”horizontal”. 除此以外，还差个属性，决定该辅助线的位置： layout_constraintGuide_begin layout_constraintGuide_end layout_constraintGuide_percent 可以通过上面3个属性其中之一来确定属性值位置。 begin=30dp，即可认为距离顶部30dp的地方有个辅助线，根据orientation来决定是横向还是纵向。 end=30dp，即为距离底部。percent=0.8即为距离顶部80%。 好了，下面看一个例子，刚才我们的浮点按钮，我决定通过两根辅助线来定位，一根横向距离底部80%，一个纵向距离顶部80%，浮点按钮就定位在他们交叉的地方。 123456789101112131415161718192021222324252627&lt;android.support.constraint.ConstraintLayout ... tools:context=\"com.zhy.constrantlayout_learn.MainActivity\"&gt; &lt;android.support.constraint.Guideline android:id=\"@+id/guideline_h\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.8\" /&gt; &lt;android.support.constraint.Guideline android:id=\"@+id/guideline_w\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.8\" /&gt; &lt;TextView android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:background=\"#612\" app:layout_constraintLeft_toRightOf=\"@id/guideline_w\" app:layout_constraintTop_toBottomOf=\"@id/guideline_h\" /&gt;&lt;/....&gt; 我感觉都不用解释了~~看眼效果图吧： 到此，属性基本上讲完啦~ 可以看到，上述相当复杂的一个布局，在ConstraintLayout中完全没有嵌套！ 六、总结本文通过实际的按钮，基本上介绍了ConstraintLayout所支持的所有的属性，全文没有提及拖拽，因为当界面复杂之后，想要完美的拖拽实在是太难了，而且谁也不期望，看不懂拖拽完成后的布局属性吧~ 所以，我建议还是尽可能手写，通过本文这样一个流程，虽然支持的属性有20多个，但是分类后并不难记，难记也可以拿出本文翻一翻~ 好了，思考了半天，如何通过一个案例介绍完所有的属性，总体来说还是完成了，给自己点个赞。","tags":[{"name":"技术知识","slug":"技术知识","permalink":"http://blog.buerya.cn/tags/技术知识/"},{"name":"Android","slug":"Android","permalink":"http://blog.buerya.cn/tags/Android/"},{"name":"ConstraintLayout","slug":"ConstraintLayout","permalink":"http://blog.buerya.cn/tags/ConstraintLayout/"},{"name":"约束布局","slug":"约束布局","permalink":"http://blog.buerya.cn/tags/约束布局/"}]},{"title":"《机器学习有意思！ 01》- 世界上最简单的机器学习入门","date":"2018-01-09T00:31:00.000Z","path":"2018/01/09/funny_machine_learning_1/","text":"《机器学习有意思！ 01》- 世界上最简单的机器学习入门 原文：Machine Learning is Fun! Part 1 —— The world’s easiest introduction to Machine Learning 作者：Adam Geitgey 你是否也曾听人们谈起机器学习但是只有一个朦胧的概念？你是否厌倦了在同事的高谈阔论中颓然欲睡？此诚求变之机。 本教程适合所有对机器学习感到好奇，却不知从何下手的读者。我想应该有很多人试着读了维基百科页面，然后愈发迷惘、沉沦，盼望着有人能够提供一个high-level的解释，那你找对地方了。 我们的目标是让所有人都能读懂——这就难免有些泛泛而谈。但是无妨，但凡本文能让一个人真正对机器学习感兴趣，那么目的就算达到了。 什么是机器学习？机器学习的核心思想是创造一种普适的算法，它能从数据中挖掘出有趣的东西，而不需要针对某个问题去写代码。你需要做的只是把数据“投喂”给普适算法，然后它会在数据上建立自己的逻辑。 比如说有一种算法，叫分类算法，它可以把数据分到不同的组别当中。一个识别手写数字的分类算法，也可以用作判断垃圾邮件，而无需修改一行代码。算法是同一个算法，只是输入了不同的训练数据，便有了不同的分类逻辑。 机器学习算法是个黑盒，且可以在不同分类问题中重复利用。 “机器学习”是个筐，什么普适算法都往里装。 两种机器学习算法机器学习主要分为两类——有监督学习和无监督学习，区别很简单，却很关键。 有监督学习想想你是一家房产中介。你的业务正在增长，所以雇了一帮实习销售来助拳。那么问题来了——身经百战的你，一眼就看穿一栋房子价值几何，但是实习生可没有这样丰富的人生经验，所以摸不准行情。 为了辅助实习生（以便解放自己度个假），你决定做个小程序，基于面积、周边环境、相似房产成交价等等，来预估本地的房价。 所以你把3个月来本市的每一笔交易都拿小本本记了下来。对每处房产都整理了一大堆细节——房间数、面积、周边环境等等，当然最重要的是，最终成交价： 这就是我们的“训练数据” 有了训练数据，我们就想搞个程序去预估其他的房价： 用训练数据去预测别的房屋价格 这就是有监督学习。你是知道每处房产到底卖多少的，换言之，问题的答案是已知的，逻辑是可以反推的。 为了开发小程序，把每处房产的训练数据导进机器学习算法里，算法试图摸索出其中的数学规律。 这有点像是去掉了符号的算术题答案： 无监督学习 Oh no!一个熊孩子把参考答案里的运算符号给涂没了！ 根据上图，你能否推算出这些题目的原貌呢？显然，我们需要对这些数字“动点手脚”，以使等式成立。 在有监督学习中，我们做的实际上就是让电脑代替人来让等式成立。一旦你学会了解决某一类问题，那么这类问题里的任何子问题都就迎刃而解了！ 无监督学习回到最开始那个卖房地产的例子。如果我们不知道具体每处房产的价格可咋整？即使仅知道面积、位置等信息，你也依然可以搞点动静出来，这就叫无监督学习。 即使不预测未知数（比如房价），机器学习也能带来有趣的结论 这就好比有人给你一张纸，上面写着一串数字，然后说“我也不知道啥意思，你可以猜猜这是什么套路——好运！” 这些数据我们能做什么呢？对于新手来讲，可以得到一个算法—，从数据中自动辨识出细分的市场定位。可能你会发现，当地大学附近的购房者偏好多卧室的小房子，而郊区的购房者则倾向于大套三。了解到不同类型消费者的存在可以指导市场行为。 另一个可以做的就是自动识别出那些少有相似点的特异房产。可能这些特异房产是豪华公馆，那么就可以调配最好的销售人员专门负责这些大买卖。 后文主要专注于有监督学习，但并非因为无监督学习的作用小或者趣味少。实际上无监督学习的重要性与日俱增且发展迅速，因为不需要事先对正确答案对应的数据加标签。 注：还有很多其他种类的机器学习算法，不过建议从这些基础算法入手。 哎哟不错，但是真的有可能“学习”到真实的房价吗？作为一个人类，你的大脑可以面对各种形势，并且在无明确指导的情况下自主学习如何应对。如果你卖了很久的房子，就会慢慢地对房价、对销售策略、对观察客户等问题产生一种“感觉”。强人工智能研究的目的就在于让计算机掌握这种能力。 但是当前的机器学习算法还没那么厉害——它们只能对很具体、有限的问题生效。或许这里的“学习”更应该定义为“基于样本数据得出解决具体问题的等式”。 不幸的是，“让机器基于样本数据得出解决具体问题的等式”不是个好名字，所以我们还是回到了“机器学习”。 当然如果你在50年后，强人工智能都普及了时候看到本文，会觉得全文都很“古典”。别看了，让你的机器人给你拿个包子吃，未来人类。 放码过来！然，上面例子里的预测房价程序应该怎么写呢？思考一秒，然后接着看。 如果你对机器学习一无所知，可能会尝试依照预测房价的基本规律，写出如下代码： 12345678910111213141516171819202122232425262728def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood): price = 0 # 这一片的均价是200美元一平米 price_per_sqft = 200 if neighborhood == &quot;hipsterton&quot;: # 有的区更贵 price_per_sqft = 400 elif neighborhood == &quot;skid row&quot;: # 有的区便宜 price_per_sqft = 100 # 根据基准价和面积预测实际价格 price = price_per_sqft * sqft # 根据房间数调整预测 if num_of_bedrooms == 0: # 公寓稍微便宜点 price = price — 20000 else: # 卧室多的房子贵 price = price + (num_of_bedrooms * 1000) return price 如果顺着写上几个小时，或许也能得到一个能跑的程序。但势必存在隐患，而且无法应对价格变化。 如果计算机能自己发现如何应用这些方程，那岂不是好得多？只要能得到正确的数字，谁管具体方程是什么呢？ 1234def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood): price = 贾维斯，帮我算一下 return price 这个问题可以想象成：价格是道炖菜，配方是卧室数量，面积和周边环境。如果你能算出每种成分对最终价格的影响是多少，或许那就是配方“搅合”最终价格的确切权重。 这可以使原程序（满是if/else）变得简单如下： 12345678910111213141516def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood): price = 0 # 加少许配方1 price += num_of_bedrooms * .841231951398213 # 加大把配方2 price += sqft * 1231.1231231 # 适量的配方3 price += neighborhood * 2.3242341421 # 最后来点盐 price += 201.23432095 return price 注意这些奇妙深刻的加粗数字——.841231951398213、 1231.1231231、2.3242341421和201.23432095，这就是我们的权重。只要我们能找到准确的权重，那就可以预测房价了。 一个比较粗暴的权重计算方法大致如下： 第一步 把所有权重都设为1.0: 12345678910111213141516def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood): price = 0 # 加少许配方1 price += num_of_bedrooms * 1.0 # 加大把配方2 price += sqft * 1.0 # 适量的配方3 price += neighborhood * 1.0 # 最后来点盐 price += 1.0 return price 第二步 把每个房产的参数代入公式，计算预测结果和实际价格的误差： 用你的方程来猜房价 比如第一个房子实际卖了250,000，但是你的方程却预测的是178,000，但这一个房子就少了72,000。 现在把每个房子对应误差的平方加起来，比方你有500单交易，那么误差的平方和就有$86,123,373，可谓谬以千里。再把平方和除以500得到平均每个房子的误差，这一平均误差值就是方程的代价（即最小二乘法，平方是为了防止误差正负相抵）。 如果我们能通过调整权重将代价降为零，那方程就完美了。这表示在所有例子中，方程都准确无误地基于输入数据猜中了房价。这就是我们的目标——尝试不同的权重，让代价尽量低。 第3步： 不断地重复第2步，尝试每一种可能的权重值组合。哪个组合能让代价最接近于0就选哪一组。找到那一组权重，就解决了问题！ 脑洞时间挺简单的对吧？回想一下刚才的所做，拿到一些数据，填进三个普适的、简单的步骤里，然后得到一个能猜房价的方程。Zillow（美国房价预测网站）面临着严重的威胁！ 但是有这么几个激动人心的事实： 过去40年里，很多领域（如语言学/翻译学）的研究已经表明，“搅合数字炖菜”（作者自己打的比方）的普适性学习算法已经超越了那些，由真人尝试自己发现显式规律的人方法。机器学习的“暴力”方法最终击败了人类专家。 刚才得出的方程其实是很笨的。它并不知道“平方米”和“卧室”到底是什么，它只知道“搅拌”多少数字可以得到正确答案。 你大概并不知道为什么某一组权重就是好的，而只是写了一个自己都不明白的方程，但却证明是好用的。 假设我们不用“平方米”和”卧室数“这些参数，而是读入一个数列。比方说每个数字代表的是”从车顶上拍的照片的某一像素的亮度”，然后我们预测的结果也不是“房价”了，而是“方向盘转过的角度”。这就是一个人自动驾驶的风方程了？ 疯了，对吧？ 第3步的“尝试每个数字”当然你不可能真的尝试每一种可能权重组合来寻找最优解，实际情况是永远尝试不完。 为了避免这一情况，数学家们发现了很多机智办法来尽快找到一个不错的结果。以下就是其中一种： 第一，写一个能够代表上面“第2步”的方程： 这就是代价函数 然后用机器学习界的黑话（暂时可以忽略）重新写一遍： θ代表当前权重。J(θ)是当前权重的代价值。 这个等式代表了在当前的权重组合下，我们的价格预测有多么离谱。 如果把房间数和平方米所有可能权重值可视化，可以得到类似下图的图像： 代价函数的图像像个碗。竖直轴表示代价。 这个图里的蓝色最低点就是代价的最低点——方程误差最小处，最高点即是最离谱的情况。所以如果我们找到一组权重值，使得方程对应最低点，那就是答案！ 所以我们只需要以“下山”的方式来调整权重，逼近最低点。如果每一次微小的调整都向着最低点进发，那迟早能够到达。 函数的导数就是切线的斜率，换句话说，这告诉我们哪条路可以“下山”。 因此如果计算代价函数对每个权重的偏微分，然后再从权重里减去这个值，这可以让我们离谷底更近。重复执行，最终我们会到达谷底并获得权重的最优解（如果没看懂，不要担心，继续看）。 这是一种寻找方程最佳权重方式的高度概括，叫作批梯度下降(batch gradient descent)。如果你对此感兴趣，不要害怕，了解更多细节。 当你使用机器学习库来解决实际问题的时候，这些都会自动完成，但是了解究竟发生了什么还是很有用的。 还略过了什么？上述的三步算法即是多变量线性回归，针对一条穿过房产数据的直线来进行预测目标等式，并用这一等式去猜测此前未曾见过的房屋价格，解决实际问题的时候这非常行之有效。 但是以上方法或许只对特别简单的例子好使，并非万金油。其中一个原因就是房价不总是简单到能用一条连续直线来代表。 好在另有很多方法解决，很多机器学习算法可以处理非线性数据（如神经网络 或 有核 的支持向量机)。同样也有算法是以更加聪明的方式使用线性回归以拟合更复杂的直线。但不论哪一方法，最根本的思想都是找到最佳的权重。 并且我忽略了过拟合问题。对于已有的原始数据，找到一组很棒的权重值不难，但是却有可能对训练集以外新的房子不适用。有很多方法可以避免这一现象（如正则化和使用交叉验证数据集），这是成功应用机器学习算法的关键命题。 尽管基本概念很简单，但是要用机器学习取得有用的结果，还是需要技巧和经验的。不过这些技巧是每一个开发者，都能够学会的！ 机器学习是魔法吗？看到机器学习技术如此轻易就解决了看起来非常困难的问题（如手写识别），你可能会感觉只要有足够多的数据，什么问题都不是问题了。导入数据，然后等着计算机变出一个适合数据的式子！ 但需要记住的事，机器学习要想生效，必须满足一个条件，就是目标问题对已有数据确实是可解的。 比如建立一个模型，根据房子里种的植物种类预测房价，这肯定不管用。因为房里的植物和售价本来就没有关系，不管再怎么试，计算机还是无法找出这种关系。 只有实际存在的关系才能建模 所以如果一位人类专家不能用数据解决某个问题，计算机也不行。相反，计算机的优势在于，对于人类能解决的问题，计算机可以更快地完成。 如何学习更多机器学习在我看来，机器学习目前最大的问题在于其主要还是存在于学术界，对于广大只是想稍微了解、而并非想成为专家的人们，通俗易懂的材料还是不够丰富，当然这一情况已经在好转。 吴恩达的Machine Learning class on Coursera相当惊艳，我强烈推荐从这里开始。对于CS专业的人，只要还记得一丁点数学，就可以学。 你也可以通过下载安装Scikit-learn，来自己尝试海量的机器学习算法，这是一个提供“黑盒”版标准算法的Python框架。","tags":[{"name":"技术知识","slug":"技术知识","permalink":"http://blog.buerya.cn/tags/技术知识/"},{"name":"人工智能","slug":"人工智能","permalink":"http://blog.buerya.cn/tags/人工智能/"},{"name":"机器学习","slug":"机器学习","permalink":"http://blog.buerya.cn/tags/机器学习/"}]},{"title":"区块链技术学习指引","date":"2017-12-31T16:00:00.000Z","path":"2018/01/01/blockchain_guide/","text":"本文为博客文章索引，小白必看。有新文章时会更新本文，建议大家加入收藏夹中，如果你觉得本站不错，欢迎你转发给朋友。 引言给迷失在如何学习区块链技术的同学一个指引，区块链技术是随比特币诞生，因此要搞明白区块链技术，应该先了解下比特币。但区块链技术不单应用于比特币，还有非常多的现实应用场景，想做区块链应用开发，可进一步阅读以太坊系列。 比特币如果你是还不知比特币是什么，那就看看比特币是什么 基础入门接下来可以通过下面这几篇文章了解比特币大概的运行原理： 区块链记账原理通过这篇可以了解到区块链是一个怎样的结构 比特币所有权及隐私问题通过这篇可以了解到地址私钥 非对称加密应用 等概念 比特币如何挖矿通过这篇了解工作量证明 比特币如何达成共识 - 最长链的选择通过这篇可以了解共识机制。 补充阅读 什么是拜占庭将军问题 进阶在基础入门之后，可以进一步阅读以下几篇，理解分布式网络，交易验证。 分析比特币网络：一种去中心化、点对点的网络架构 比特币区块结构 Merkle 树及简单支付验证分析 比特币脚本及交易分析 - 智能合约雏形 看完上面这些，区块链应该理解差不多了，就可以尝试实现一个简单的区块链了。参考这篇用Python从零开始创建区块链。 以太坊一个技术要落地还得靠应用， 以太坊就这样一个建立在区块链技术之上，去中心化的应用平台。可以阅读几下几篇，这部分以开发为主，需要大家多发时间实践。 以太坊开发入门 智能合约开发环境搭建及Hello World合约 以太坊客户端Geth命令用法-参数详解 Geth控制台使用实战及Web3.js使用 如何搭建以太坊私有链 智能合约及应用开发 一步步教你开发、部署第一个Dapp应用 一步步教你创建自己的数字货币（代币）进行ICO 实现一个可管理、增发、兑换、冻结等高级功能的代币 如何通过以太坊智能合约来进行众筹（ICO） 剖析非同质化代币ERC721–全面解析ERC721标准 Solidity语言教程 Solidity 教程系列1 - 类型介绍 Solidity 教程系列2 - 地址类型介绍 Solidity 教程系列3 - 函数类型介绍 Solidity 教程系列4 - 数据存储位置分析 Solidity 教程系列5 - 数组介绍 Solidity 教程系列6 - 结构体与映射 Solidity 教程系列7 - 以太单位及时间单位 Solidity 教程系列8 - Solidity API","tags":[{"name":"区块链","slug":"区块链","permalink":"http://blog.buerya.cn/tags/区块链/"},{"name":"目录","slug":"目录","permalink":"http://blog.buerya.cn/tags/目录/"}]},{"title":"【机器学习】先搞懂这八大基础概念，再谈机器学习入门","date":"2017-11-29T04:31:00.000Z","path":"2017/11/29/machine_learning_base/","text":"【机器学习】先搞懂这八大基础概念，再谈机器学习入门 准备好开始AI了吗？可能你已经开始了在机器学习领域的实践学习，但是依然想要扩展你的知识并进一步了解那些你听过却没有时间了解的话题。 这些机器学习的专业术语能够简要地介绍最重要的机器学习概念—包括商业界和科技界都感兴趣的话题。在你遇到一位AI指导者之前，这是一份不详尽，但清楚易懂又方便在工作、面试前快速浏览的内容。 概览： 自然语言处理 数据库 计算机视觉 监督学习 无监督学习 强化学习 神经网络###### 概览： 过拟合 1. 自然语言处理自然语言处理对于许多机器学习方法来说是一个常用的概念，它使得计算机理解并使用人所读或所写的语言来执行操作成为了可能。 自然语言处理最重要的最有用的实例： 文本分类和排序 这项任务的目标是对一个文本进行预测标签(类别)或对列表中相关联的文本进行排序。它能够用于过滤垃圾邮件(预测一封电子邮件是否是垃圾邮件)，或进行文本内容分类(从网络上筛选出那些与你的竞争者相关的文章)。 情感分析 句子分析是为了确定一个人对某个主题的看法或情感反应，如正面或负面情绪，生气，讽刺等。它广泛应用于用户满意度调查(如对产品的评论进行分析)。 文件摘要 文件摘要是用一些方法来得到长文本(如文档，研究论文)短且达意的描述。对自然语言处理方向感兴趣吗？请进一步阅读人工智能关于自然语言处理方向的文章：https://sigmoidal.io/boosting-your-solutions-with-nlp/ 命名实体识别 命名实体识别算法是用于处理一系列杂乱的文本并识别目标(实体)预定义的类别，如人，公司名称，日期，价格，标题等等。它能够将杂乱的文本信息转换成规则的类表的格式，来实现文本的快速分析。 语音识别 语音识别技术是用于得到人所讲的一段语音信号的文本表达。你可能听说过Siri助手？这就是语音识别应用的一个最好的例子。 自然语言的理解和生成 自然语言的理解是通过计算机，将人类生成的文本转换成更正式的表达。反过来，自然语言生成技术是将一些正式又有逻辑性的表达转换成类人的生成文本。如今，自然语言理解和生成主要用于聊天机器人和报告的自动生成。 从概念上来说，它与实体命名识别任务是相反的。 机器翻译 机器翻译是将一段文本或语音自动从一种语言翻译成另一种语言的一项任务。请见：https://youtu.be/Io0VfObzntA 2. 数据库数据库是机器学习一个必要的组成部分。如果你想构建一个机器学习系统，你要么可以从公众资源中得到数据，要么需要自己收集数据。所有的用于构建和测试机器学习模型的数据集合成为数据库。基本上，数据科学家会将数据划分为三个部分： 训练数据：训练数据是用于训练模型。这意味着机器学习模型需要认识并通过学习得到数据的模式以及确定预测过程中最重要的数据特征。 验证数据：验证数据是用于微调模型参数和比较不同模型来确定最优的模型。验证数据应该不同于训练数据，且不能用于训练阶段。否则，模型将出现过拟合现象，且对新的数据泛化不佳。 测试数据：这看起来似乎有些单调，但这通常是第三个也是最后的测试集(经常也被称为对抗数据)。一旦最终的模型确定，它就用于测试模型在从未见过的数据集上的表现，如这些数据从未在构建模型或确定模型时使用过。 图像：混合使用t-SNE和Jonker-Volgenant算法得到的MNIST数据库的可视化结果。T-SNE是一种广泛使用的降维算法，通过压缩数据的表达来得到更好的可视化和进一步处理。 3. 计算机视觉计算机视觉是一个专注于分析并深层次理解图像和视频数据的人工智能领域。计算机视觉领域最常见的问题包括： 图像分类 图像分类是教模型去识别给定的图像的一种计算机视觉任务。例如，训练一个模型去识别公共场景下的多个物体(这可以应用于自动驾驶)。 目标检测 目标检测是教模型从一系列预定义的类别中检测出某一类别的实例，并用矩形框框注出来的一种计算机视觉任务。例如，利用目标检测来构建人脸识别系统。模型可以在图片中检测出每张脸并画出对应的矩形框(顺便说下，图像分类系统只能识别出一张图片中是否有脸的存在，而不能检测出脸的位置，而目标检测系统就可以)。 图像分割 图像分割是训练模型去标注类的每一个像素值，并能大致确定给定像素所属的预定义类别的一种计算机视觉任务。 显著性检测 显著性检测是训练模型产生最显著区域的一种计算机视觉任务。这可以用于确定视频中广告牌的位置。需要详细了解计算机视觉？请阅读 https://sigmoidal.io/dl-computer-vision-beyond-classification/ 4. 监督学习监督学习是用实例来教模型学习的一类机器学习模型集合。这意味着用于监督学习任务的数据需要被标注(指定正确的，真实类别)。例如，如果我们想要构建一个机器学习模型用于识别一个给定的文本是否被标记过的，我们需要给模型提供一个标记过的样本集 (文本+信息，是否该文本被标记过)。给定一个新的，未见过的例子，模型能够预测它的目标，例如，规定样本的标签，1表示标记过的而0表示未标记的。 5. 无监督学习相比于监督学习，无监督学习模型是通过观察来进行自我学习。算法所用的数据是未标记过的(即提供给算法的是没有真实标签值的数据)。无监督学习模型能够发现不同输入之间的相关关系。最重要的无监督学习技术是聚类方法。对于给定的数据，模型能够得到输入的不同聚类(对于相似的数据聚合在同一类中)，并能将新的、未见过的输入归入到相似的聚类中。 6. 强化学习强化学习区别于先前我们提到的那些方法。强化学习算法一种“游戏”的过程,其目标是最大化 “游戏奖励”。该算法通过反复的实验来尝试确定不同的 “走法”，并查看哪种方式能够最大化 “游戏收益” 最广为人知的强化学习例子就是教计算机来解决魔方问题或下象棋，但是强化学习能解决的问题不仅只有游戏。最近，强化学习大量地应用于实时竞价，其模型负责为一个广告竞拍价格而它的报酬是用户的转换率。 想要学习人工智能在实时竞价和程序化广告中的应用吗？详见：https://sigmoidal.io/ai-for-advertising/ 7. 神经网络神经网络是一个非常广泛的机器学习模型集合。它的主要思想是模拟人类大脑的行为来处理数据。就像大脑中真实神经元之间相互连接形成的网络一样，人工神经网络由多层组成。每层都是一系列神经元的集合，这些神经元负责检测不同的食物。一个神经网络能够连续地处理数据，这意味着只有第一层才与输入直接相连，随着模型层数的增加，模型将学到越来越复杂的数据结构。当层数大量地增加，模型通常就是一个所谓的深度学习模型。很难给一个深度网络确定一个特定的网络层数，10年前通常3层神经网络就可谓深，而如今通常需要20层。 神经网络有许许多多不同的变体，最常用的是： 卷积神经网络—它给计算机视觉任务带来了巨大的突破(而如今，它同样对于解决自然语言处理问题有很大帮助)。 循环神经网络—被设计为处理具有序列特征的数据，如文本或股票票价。这是个相对古老的神经网络，但随着过去20年现代计算机计算能力的突飞猛进，使得它的训练变得容易并在很多时候得以应用。 全连接神经网络—这是处理静态/表格式数据最简单的模型。 8. 过拟合当模型从不充分的数据中学习会产生偏差，这对模型会有负面的影响。这是个很常见，也很重要的问题。 当你在不同的时间进入一个面包坊，而每一次所剩下的蛋糕都没有你喜欢的，那么你可能会对这个面包坊失望，即使有很多其他的顾客可能会对剩下的蛋糕满意。如果你是个机器学习模型，可以说你对这一小数量样本产生了过拟合现象—要构建一个具有偏置量的模型，其得到的表示才不会过度拟合真实数据。 当过拟合现象发生，它通常意味着模型将随机噪声当作数据，并作为一个重要的信号去拟合它，这就是为什么模型在新数据上的表现会出现退化(噪声也有差异)。这在一些非常复杂的模型如神经网络或加速梯度模型上是很常见的。 想象构建一个模型来检测文章中出现的有关奥运的特定体育项目。由于所用的训练集与文章是由偏差的，模型可能学习到诸如 “奥运”这样词的特征，而无法检测到那些未包含该词的文章。 这就是所有的问题。","tags":[{"name":"技术知识","slug":"技术知识","permalink":"http://blog.buerya.cn/tags/技术知识/"},{"name":"人工智能","slug":"人工智能","permalink":"http://blog.buerya.cn/tags/人工智能/"},{"name":"机器学习","slug":"机器学习","permalink":"http://blog.buerya.cn/tags/机器学习/"}]},{"title":"Windows + Ubuntu 双系统安装图解教程","date":"2017-08-25T04:45:53.000Z","path":"2017/08/25/ubuntu-install/","text":"终于，自己想起来自己也要写点什么了。。。(宛如一个智障=_=)。很早就有个想法，自己写点什么，但是怕是懒吧，一直不想写，或者说一直不知道写点什么。现在这个blog搭建的终于是让我满意了。那么，接下来就需要使劲写，把这个空的框架填起来，就像吹气球一样咯。加油！ps:暂时不打算放图片辣~(≧▽≦)/~ 安装Ubuntu U盘一个（请提前备份U盘里面的资料，因为后面操作要格式化U盘） Ubuntu 16.04LTS（长期支持版） 镜像： - 下载地址：http://www.ubuntu.com/download/desktop -Ubuntu中国下载地址：http://cn.ubuntu.com/download/ ultraiso 可以免费试用，地址百度一堆呢 硬盘做好分区，一般40G左右就够了。 绿色框中是留给Ubuntu的空间 注意： （1）如果想学习Linux的话，留给Ubuntu使用的空间建议大于40G。 （2）这里是一整个未分配空间，这样可以在安装Ubuntu的时候直接选择和Windows共存安装，自动分配空间，不用自己再给系统分区设置大小了。 使用ultraiso做U盘启动(老电脑记得使用MBR)，或者在Windows中用cmd命令制作启动盘。 插入用来制作启动盘的U盘（会被格式化，请备份好重要文件），打开UltraISO刻录软件（免费无限期试用）。 选择“文件(F)”-&gt;“打开”，找到“Ubuntu-16.04-desktop-amd64.iso”镜像文件，然后点击“打开”。 选择“启动(B)”-&gt;“写入硬盘映像”，打开启动盘制作界面。 然后点击下方的“写入”，会弹出警告提示，确定后，就会开始制作启动盘。写入完成后关闭UltraISO软件即可。 建议：USB3.0的U盘写入速度大约是USB2.0的10倍，推荐使用USB3.0接口的U盘。 【BIOS设置】 关机，重新打开电脑，进入BIOS，关闭Windows系统的快速启动（Fast Boot）选项，即设置为Disable状态。 在BIOS中设置U盘为第一启动项，关闭电脑。 这一步也可以省略，有些电脑在开机时可以通过按F12 或者Esc选择启动方式，看个人电脑配置吧。 【安装Ubuntu 16.04】 从U盘启动，进入刻录到U盘的Ubuntu系统中。 一般选择Try ubuntu，你不喜欢直接用桌面系统的话也可以直接选择Install Ubuntu. 选择试用Ubuntu，稍等一会，进入Ubuntu Desktop。 双击左上角的”Install Ubuntu 16.04LTS“，打开安装界面。（安装过程比较简单，根据提示输入一些信息即可） 在左侧语言栏选择安装语言，然后点击“继续”。 如果网速比较快，可以勾选“安装Ubuntu时下载更新”。（如果选择的语言是中文，这里在更新的时候会自动安装中文输入法，当然也可以安装完成后安装搜狗拼音输入法Linux版） 点击继续 在硬盘中Ubuntu检测到有Windows系统存在，所以会默认使用未分配的那部分空间安装Ubuntu。 注意：千万别选第一个选项，我就被坑过一次，导致Windows系统也要重装T_T 选择这一项，然后点击继续 进入分区界面后，可以看到/dev/sda这块磁盘已安装好windows10系统，而我们将要安装的/dev/sdb还处于空闲状态。 下面我们将进行分区，网上很多教程都说要单独将/boot挂载，其实也可以不用这样。一般情况下只用挂载/根目录 ,/home用户目录, swap交换分区三个目录就行了，我这里因为在使用中有部分数据需要存在/var目录下，所以就将/var也进行了单独的挂载。 注意，要将安装的启动引导器(grub2)设备选择在efi分区上也就是我们安装windows时设置的分区。 接下来会有提示信息。 输入自己的位置以配置时区。 键盘布局默认就可以。 输入账户信息和密码。 接下来下载更新，自动安装。 安装完成之后重启。 下面就是正常的复制文件开始安装了，安装好重启系统，就会出现grub2引导器的选择界面了。从图中可以看到第一个是ubuntu系统，第三个就是window10系统。 安装后的配置请见下一篇","tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://blog.buerya.cn/tags/Ubuntu/"},{"name":"Ubuntu 16.04","slug":"Ubuntu-16-04","permalink":"http://blog.buerya.cn/tags/Ubuntu-16-04/"}]},{"title":"各种教程分享","date":"2017-06-26T14:09:53.000Z","path":"2017/06/26/resources01/","text":"调音 节拍器 3Dmax资料: 600个3D光域网 密码: 9d3n 光域网灯光文件 密码：av8m AI资料: AI CC安装软件MAC版 链接: http://pan.baidu.com/s/1kTu0t7p 密码: fauj AI CS6安装软件MAC版 链接: http://pan.baidu.com/s/1mgADwIO 密码: cvrh AI CC官方原版 链接: http://pan.baidu.com/s/1eQtUAOy 密码: 2gjc AI CS5官方原版 链接: http://pan.baidu.com/s/1gd7zLkv 密码: s6gr AI CS6官方原版 链接: http://pan.baidu.com/s/1gd7zLkB 密码: d6vv AI CS4标准视频教程 链接: http://pan.baidu.com/s/1ptafs 密码: hfii AI CS4高级实战讲解123集 链接: http://pan.baidu.com/s/1dD6hUXb 密码: nzps AI CS4平面设计与制作标准教程 链接: http://pan.baidu.com/s/1hqyAoFq 密码: 253u AI CS4特效设计与制作实例精讲 链接: http://pan.baidu.com/s/1sjsmnEX 密码: tamn AI CS5多媒体实例教程74讲 链接: http://pan.baidu.com/s/1qWDndm8 密码: 7s5g AI CS5基础入门工具使用教程135集 链接: http://pan.baidu.com/s/1sjsSkwP 密码: df4p AI CS5平面广告创意108招 链接: http://pan.baidu.com/s/1qWHqMPQ 密码: 7gyn AI CS5入门到精通视频教程 链接: http://pan.baidu.com/s/1qEULo 密码: 2grd AI CS5实战从入门到精通200例 链接: http://pan.baidu.com/s/1kTouGYV 密码: ye2z AI CS6地产广告设计20集 链接: http://pan.baidu.com/s/1ntzLUA1 密码: 8xu8 AI CS6入门平面创意设计实例视频222集 链接: http://pan.baidu.com/s/1kTKOLN5 密码: m5ky AI CS6矢量绘图滤镜商业设计48集 链接: http://pan.baidu.com/s/1dDfJ7sl 密码: 76nj AI插画与包装设计循序渐进400例 链接: http://pan.baidu.com/s/1ntoWBB7 密码: mgnw AI创意绘图与典型设计120例 链接: http://pan.baidu.com/s/1dDk3ksT 密码: 55mq AI素材 VI文件模板元素 链接: http://pan.baidu.com/s/1c0B9D4W 密码: fve8 CAD资料: CAD2004安装软件 链接: http://pan.baidu.com/s/1qWoQ6dQ 密码: bcc6 CAD2005安装软件 链接: http://pan.baidu.com/s/1hq5vNWo 密码: x3me CAD2006安装软件 链接: http://pan.baidu.com/s/1bnnpiO3 密码: 7crs CAD2007安装软件 链接: http://pan.baidu.com/s/1jG1nZc6 密码: 14eb CAD2008安装软件 链接: http://pan.baidu.com/s/1eQ5zSB4 密码: a8kf CAD2009安装软件 链接: http://pan.baidu.com/s/1hq6HIPQ 密码: x1ge CAD2010安装软件 链接: http://pan.baidu.com/s/1jG5XJqY 密码: tuvz CAD2011安装软件 链接: http://pan.baidu.com/s/1dD30cBv 密码: svus CAD2012安装软件 链接: http://pan.baidu.com/s/1i3laZYX 密码: esft CAD2013安装软件 链接: http://pan.baidu.com/s/1pJNy207 密码: 98s9 CAD2014安装软件 链接: http://pan.baidu.com/s/1eQCl6DW 密码: vywp AutoCAD快捷键 链接: http://pan.baidu.com/s/1jG5XJro 密码: t2p7 CAD超级图库王 链接: http://pan.baidu.com/s/1dDhfy8p 密码: 3aia CAD家装施工图带实景照和效果图153套 链接: http://pan.baidu.com/s/1pJFWT5L 密码: gzfy CAD节点大样图详图129套剖面图立面图 链接: http://pan.baidu.com/s/1hqInf8o 密码: 919f CAD镂空雕花图库 链接: http://pan.baidu.com/s/1dDfJ74d 密码: 3qh1 CAD图案花纹大全 链接: http://pan.baidu.com/s/1kTqwC55 密码: tr4t CAD图库大集合中欧式建筑室内家具 链接: http://pan.baidu.com/s/16oba2 密码: zgea CAD习题图库命令表 链接: http://pan.baidu.com/s/1gdu86jD 密码: u2t3 CAD最全CAD字体2485种 链接: http://pan.baidu.com/s/1eQCR3UU 密码: qg16 梁志天施工图140套 链接: http://pan.baidu.com/s/1kT6BEy7 密码: fb8m CAD特殊符号输入法 链接: http://pan.baidu.com/s/1gdIpf6F 密码: ikuy CAD运用技巧 链接: http://pan.baidu.com/s/1i3D1uhn 密码: ej82 十年CAD经验分享 链接: http://pan.baidu.com/s/1dDsAGvv 密码: hf9f CAD2006标准教程 链接: http://pan.baidu.com/s/1jGnaQ0Y 密码: u3pt CAD2007从零开始基础培训百例 链接: http://pan.baidu.com/s/1eQGprHK 密码: dvp8 CAD2007机械制图教程 链接: http://pan.baidu.com/s/1dD0crQx 密码: pzui CAD2007建筑设计实例教程 链接: http://pan.baidu.com/s/1mgHyWI0 密码: k39s CAD2007视频教程SWF格式 链接: http://pan.baidu.com/s/1pJiMUbL 密码: n66y CAD2007视频教学录像 链接: http://pan.baidu.com/s/12kn5k 密码: s2px CAD2007室内设计教程 链接: http://pan.baidu.com/s/1eQHBk0E 密码: jhy3 CAD2007应用基础教程 链接: http://pan.baidu.com/s/1i3y8kK1 密码: 4ggt CAD2007职业应用教程 链接: http://pan.baidu.com/s/1c0ffCze 密码: z64c CAD2007装修设计完全自学手册 链接: http://pan.baidu.com/s/1qWFoUC0 密码: t4v3 CAD2007自学成才 链接: http://pan.baidu.com/s/1sjuUjYd 密码: sixm CAD2008标准教程 链接: http://pan.baidu.com/s/1o6mSGBo 密码: fzjw CAD2008电气设计基础与典型范例 链接: http://pan.baidu.com/s/1dD95Gy9 密码: zwqh CAD2008跟我学 链接: http://pan.baidu.com/s/1dDAlEPN 密码: 1pdp CAD2008机械设计典型案例 链接: http://pan.baidu.com/s/1dDfd8IH 密码: a8ns CAD2008机械制图基础教程 链接: http://pan.baidu.com/s/1i3xSl7J 密码: ud2v CAD2008实用教程机械设计 链接: http://pan.baidu.com/s/1mg5T9QK 密码: ipaj CAD2008完全掌握机械篇 链接: http://pan.baidu.com/s/1o6ssxS2 密码: v48w CAD2008完全掌握综合篇 链接: http://pan.baidu.com/s/1qW0vOnE 密码: fjse CAD2008无敌课堂 链接: http://pan.baidu.com/s/1sj7fvRn 密码: 69gt CAD2008新概念教程 链接: http://pan.baidu.com/s/1dDk3kAl 密码: 58hu CAD2008应用基础教程 链接: http://pan.baidu.com/s/1eQD70d0 密码: wkvw CAD2009电气设计详解 链接: http://pan.baidu.com/s/1nth5dPZ 密码: mm4e CAD2009机械图形设计 链接: http://pan.baidu.com/s/1eQAP9XS 密码: hhqw CAD2009机械图学基础 链接: http://pan.baidu.com/s/1o6j4SNC 密码: 1trh CAD2009建筑电气工程制图实例精解 链接: http://pan.baidu.com/s/1ntBrsed 密码: kkj4 CAD2009建筑设计实战从入门到精通 链接: http://pan.baidu.com/s/1sjQIjrn 密码: 94jc CAD2009建筑图学基础 链接: http://pan.baidu.com/s/1sjBjgaL 密码: w5v9 CAD2009室内装潢设计完美技法 链接: http://pan.baidu.com/s/1gdvUykj 密码: mjq3 CAD2009完全实战学习手册 链接: http://pan.baidu.com/s/1hqInfAc 密码: 5x2a CAD2010电气设计实例教程 链接: http://pan.baidu.com/s/1kTjBenl 密码: psd7 CAD2010辅助绘图从入门到精通 链接: http://pan.baidu.com/s/1kTqwC7P 密码: 5hps CAD2010辅助设计经典实录228例 链接: http://pan.baidu.com/s/1gdF7qDX 密码: 6xhw CAD2010基础教程 链接: http://pan.baidu.com/s/1nt7T4DF 密码: gh5n CAD2010基础与实例全科教程 链接: http://pan.baidu.com/s/1i3w6rLb 密码: fx96 CAD2010建筑设计绘图基础入门与范例精通 链接: http://pan.baidu.com/s/1c0lllIw 密码: 7fdr CAD2010建筑设计经典208例 链接: http://pan.baidu.com/s/1i3xSl9b 密码: ehqc CAD2010建筑设计经典案例指导教程 链接: http://pan.baidu.com/s/1sjoi6kt 密码: evbg CAD2010建筑水暖电设计从入门到精通 链接: http://pan.baidu.com/s/1hqo0RnI 密码: xwfv CAD2010建筑图形设计 链接: http://pan.baidu.com/s/1eQ3ycRg 密码: 46vu CAD2010快捷命令一册通 链接: http://pan.baidu.com/s/1hqpMJKo 密码: gvrt CAD2010入门与精通教程 链接: http://pan.baidu.com/s/1gdhHtcR 密码: jjci CAD2010视频教程 链接: http://pan.baidu.com/s/1gdixoPH 密码: gbmj CAD2010室内设计视频教程 链接: http://pan.baidu.com/s/1nt7T4EX 密码: kq92 CAD2010室内装潢设计从入门到精通 链接: http://pan.baidu.com/s/1jGre9Zw 密码: 8868 CAD2010手把手教你学教程 链接: http://pan.baidu.com/s/1jGhBkB8 密码: pg9p CAD2010园林设计实践案例与练习 链接: http://pan.baidu.com/s/1mgBttjE 密码: w9a4 CAD2011电气设计教程 链接: http://pan.baidu.com/s/1kTpGD6n 密码: rqib CAD2011工程制图 链接: http://pan.baidu.com/s/1pJmkKGz 密码: 79cm CAD2011机械绘图实例教程 链接: http://pan.baidu.com/s/1ntoqGvZ 密码: j7wr CAD2011机械设计经典208例 链接: http://pan.baidu.com/s/136k2q 密码: yepr CAD2011机械设计实战从入门到精通 链接: http://pan.baidu.com/s/1i3ENpsx 密码: uz47 CAD2011机械制图快速入门实例教程 链接: http://pan.baidu.com/s/1c0dJDWs 密码: yniq CAD2011建筑图形设计 链接: http://pan.baidu.com/s/1i3F3l2l 密码: caef CAD2012 7天精通视频教程 链接: http://pan.baidu.com/s/1dDIZfX3 密码: 638x CAD2012从入门到精通 链接: http://pan.baidu.com/s/1mgmWL1e 密码: app8 CAD2012机械设计绘图入门与精通 链接: http://pan.baidu.com/s/1o6oUB4A 密码: cvek CAD2012机械设计完全学习手册 链接: http://pan.baidu.com/s/1Fb4cA 密码: 9qfh CAD2012基础教程30章 链接: http://pan.baidu.com/s/1mgkUUE0 密码: tjq3 CAD2012建筑设计从入门到精通 链接: http://pan.baidu.com/s/1gdu86or 密码: dims CAD2012建筑与土木工程制图快速入门实例教程 链接: http://pan.baidu.com/s/1eQtUBhK密码: u3xb CAD2012经典实例教程15章 链接: http://pan.baidu.com/s/1o6qq2EY 密码: iwk3 CAD2012精彩百例与解析 链接: http://pan.baidu.com/s/1eQ4JWPG 密码: 5za3 CAD2012入门教程9章 链接: http://pan.baidu.com/s/1bnwIApp 密码: mu9f CAD2012三维造型实例教程 链接: http://pan.baidu.com/s/1pJJuLcf 密码: 7gdw CAD2012实战教程14章 链接: http://pan.baidu.com/s/1fjGcu 密码: 3cut CAD2012室内装潢设计标准实例教程 链接: http://pan.baidu.com/s/1mgGJd12 密码: y2b9 CAD2012室内装潢设计从入门到精通 链接: http://pan.baidu.com/s/1c0ATJ0k 密码: 8yre CAD2012图形设计教程 链接: http://pan.baidu.com/s/1x09YY 密码: uujf CAD2012应用完全学习手册 链接: http://pan.baidu.com/s/1c075Uec 密码: u19m CAD2013高手140集案例视频教程 链接: http://pan.baidu.com/s/1c0ffFpA 密码: r5u5 CAD2013全套机械设计图纸绘图技法精讲 链接: http://pan.baidu.com/s/1mgADzQw 密码: i3y2 CAD2013入门到精通视频教程 链接: http://pan.baidu.com/s/1o65jDuM 密码: 5krf CAD电气系统图与给排水图绘制教程 链接: http://pan.baidu.com/s/1nt3PMrv 密码: mhcj CAD给排水暖通空调·建筑电气设计与工程项目实战 链接: http://pan.baidu.com/s/1dD4Maop 密码: uew4 CAD模具设计排位教程 链接: http://pan.baidu.com/s/1i36FIjN 密码: 5pj6 CAD室内外施工图绘制视频教程 链接: http://pan.baidu.com/s/1bnwIAon 密码: 4r5a CAD天正建筑视频教程演示全套29讲 链接: http://pan.baidu.com/s/1gds6EAJ 密码: bjg7 CAD制图规范最新施工图标 链接: http://pan.baidu.com/s/1bnjRtWr 密码: ue7h CDR资料: CDR X4安装软件 链接: http://pan.baidu.com/s/1gdGTp6b 密码: g99f CDR X5安装软件 链接: http://pan.baidu.com/s/1kTipiEN 密码: uvgz CDR X6安装软件 链接: http://pan.baidu.com/s/1dDCT7UD 密码: n649 CDR X7安装软件 链接: http://pan.baidu.com/s/1ntnAJpf 密码: r5gf CDR X4案例实战从入门到精通 链接: http://pan.baidu.com/s/1ntkSXrN 密码: 9vdb CDR X4入门与提高基础自学视频教程 链接: http://pan.baidu.com/s/1c0DB8eW 密码: xd27 CDR X4实例教学视频教程 链接: http://pan.baidu.com/s/1jGmuXSi 密码: ak8r CDR X5产品包装设计入门到精通教程 链接: http://pan.baidu.com/s/1o6j4VFk 密码: qpy5 CDR广告设计高级教程 链接: http://pan.baidu.com/s/1c054cWK 密码: qf83 Office资料: Excel_2003视频教程 链接: http://pan.baidu.com/s/1sjFmVQP 密码: s8h2 Excel_2007视频教程 链接: http://pan.baidu.com/s/1i30AgW9 密码: 9g8r Excel_2007循序渐进视频教程 链接: http://pan.baidu.com/s/1o6Drk6m 密码: rskk Excel_2010视频教程 链接: http://pan.baidu.com/s/1CtHRg 密码: 3u9c Excel_2010数据透视表教程 链接: http://pan.baidu.com/s/1o6j4VFG 密码: bcsm Excel_2010完全自学教程 链接: http://pan.baidu.com/s/1kTnEOuj 密码: gk5d Excel_2013视频教程 链接: http://pan.baidu.com/s/1eQq6Nya 密码: 9eh3 Excel常用表格模板120个 链接: http://pan.baidu.com/s/1nt892oL 密码: 8dzi Excel函数查询手册1000页 链接: http://pan.baidu.com/s/1hqH7kDA 密码: 54uc Excel快捷键查询手册 链接: http://pan.baidu.com/s/1o6656jC 密码: 3pti OneNote_2010视频教程 链接: http://pan.baidu.com/s/1pJsWw5P 密码: h53p Outlook_2010视频教程 链接: http://pan.baidu.com/s/1ntGHckL 密码: 2xvx PPT_2003视频教程 链接: http://pan.baidu.com/s/1hqs4BWw 密码: vjuz PPT_2007视频教程 链接: http://pan.baidu.com/s/1gdKqZDL 密码: psc3 PPT_2010从入门到精通 链接: http://pan.baidu.com/s/1o6qW2UI 密码: ppg3 PPT_2010视频教程 链接: http://pan.baidu.com/s/1o67l30Q 密码: fsft PPT_2013视频教程 链接: http://pan.baidu.com/s/1gdkznpx 密码: y4ea PPT常用图片素材 链接: http://pan.baidu.com/s/1jGELqPS 密码: 9rre PPT地产策划方案146个 链接: http://pan.baidu.com/s/1gdxqyfp 密码: vd3c PPT模板大全设计素材 链接: http://pan.baidu.com/s/1hqAL424 密码: kj5x PPT视频教程全套27课 链接: http://pan.baidu.com/s/1jGCduGQ 密码: 13ta PPT最常用的字库集 链接: http://pan.baidu.com/s/1pJusoZp 密码: ebsx Publisher_2010视频教程 链接: http://pan.baidu.com/s/1dDGrxCl 密码: cuq7 SharePoint和Workspace_2010视频教程 链接: http://pan.baidu.com/s/1gdvU1NX 密码: 3vun Word_2003视频教程 链接: http://pan.baidu.com/s/1twNro 密码: ig6i Word_2007视频教程 链接: http://pan.baidu.com/s/1gdCj73P 密码: 9spk Word_2010教学用PPT文档20章 链接: http://pan.baidu.com/s/1FH53C 密码: 9xh6 Word_2010视频教程 链接: http://pan.baidu.com/s/1i3s292P 密码: q8xy Word_2010中文版完全自学手册 链接: http://pan.baidu.com/s/1Gx1ee 密码: czcn Word_2013视频教程 链接: http://pan.baidu.com/s/1nttayLz 密码: nwwv Word常用快捷键查询手册261个 链接: http://pan.baidu.com/s/1jGhBons 密码: v85g Word常用文书模板150个 链接: http://pan.baidu.com/s/1qWsotju 密码: mia5 PS资料: PS CS4安装软件PC版 链接: http://pan.baidu.com/s/1dDtWFct 密码: 2baf PS CS5安装软件PC版 链接: http://pan.baidu.com/s/1hqH7lxa 密码: x3qd PS CS6安装软件MAC版 链接: http://pan.baidu.com/s/1jGowM4u 密码: jh7y PS CS6安装软件PC版 链接: http://pan.baidu.com/s/1gdKqZGB 密码: u35b PS CS2李涛主讲视频教程24集 链接: http://pan.baidu.com/s/1nt3PNeD 密码: qpy4 PS CS2中文学习教程9章 链接: http://pan.baidu.com/s/1gdrkJpL 密码: hvcu PS CS3完全自学教程 链接: http://pan.baidu.com/s/1kT5VFEn 密码: ecgz PS CS3中文版视频教程100集 链接: http://pan.baidu.com/s/1i3BzzBv 密码: fzrw PS CS4时尚杂志婚纱设计 链接: http://pan.baidu.com/s/1eQxs2n4 密码: npsv PS CS4数码照片处理与精修完全学习手册 链接: http://pan.baidu.com/s/1dDcvKzv 密码: v9ne PS CS4特效创意视频教程 链接: http://pan.baidu.com/s/1mg3lRYg 密码: pazm PS CS4完全自学教程54课 链接: http://pan.baidu.com/s/1ntilew5 密码: sav2 PS CS4影楼数码照片色彩处理技法25课 链接: http://pan.baidu.com/s/1i3EhvLz 密码: wy3p PS CS5经典案例视频教程95集 链接: http://pan.baidu.com/s/1o6sY2jo 密码: uxdr PS CS5实例视频195集 链接: http://pan.baidu.com/s/1vyJgE 密码: nw6z PS CS5完全自学教程(超值版) 链接: http://pan.baidu.com/s/1c0nThzq 密码: y42t PS CS5完全自学教程-实例视频19章 链接: http://pan.baidu.com/s/1qWuqsxQ 密码: x96t PS CS5综合实例视频教学50例 链接: http://pan.baidu.com/s/1hqJ9cnM 密码: yfj4 PS CS6案例视频教程 链接: http://pan.baidu.com/s/1dDItm1N 密码: anb2 PS CS6基础视频教程51课 链接: http://pan.baidu.com/s/1c0wG9vM 密码: rqq4 PS大师之路基础视频教程15章 链接: http://pan.baidu.com/s/1sjBjj1F 密码: ixhj PS电脑美术绘画教程 链接: http://pan.baidu.com/s/1o60zTF0 密码: 9g3s PS工具栏巧妙运用技巧94集 链接: http://pan.baidu.com/s/1bne1KXT 密码: kxc8 PS和CDR平面设计入门进阶与提高 链接: http://pan.baidu.com/s/1c0CV9IC 密码: ht9m PS婚纱与写真实用技术精粹 链接: http://pan.baidu.com/s/1jG1UbKq 密码: 493x PS经典实例1000例 链接: http://pan.baidu.com/s/1mg3RNYS 密码: m7fz PS经典文字教程集合 链接: http://pan.baidu.com/s/1hqrOExQ 密码: sr6q PS经典效果289例 链接: http://pan.baidu.com/s/1dDhf2gD 密码: ndjd PS经典效果视频教程100例 链接: http://pan.baidu.com/s/1mBs8e 密码: vrqb PS滤镜详解视频教程 链接: http://pan.baidu.com/s/1kT5pJ2R 密码: wpjh PS巧夺天工入门与进阶实例教程 链接: http://pan.baidu.com/s/16oghw 密码: be92 PS人物数码照片处理实战36集 链接: http://pan.baidu.com/s/1ntKeM05 密码: bnhy PS入门基础教程92课 链接: http://pan.baidu.com/s/1qWqS1Xy 密码: 2z9k PS摄影后期调色技法32例 链接: http://pan.baidu.com/s/1bnAVN6B 密码: d5zj PS深度学习不同抠图技巧70集 链接: http://pan.baidu.com/s/1pJ3fLBd 密码: ke62 PS实战前沿3章 链接: http://pan.baidu.com/s/1dD6NWfZ 密码: 42bk PS视频教程106集 链接: http://pan.baidu.com/s/1pJKaJph 密码: 7d4c PS数码照片处理经典13章 链接: http://pan.baidu.com/s/1c0uEEQ0 密码: 3xbk PS文字特效教程3辑 链接: http://pan.baidu.com/s/1dD2ekwh 密码: qqax PS文字艺术效果100例 链接: http://pan.baidu.com/s/1pJtCyAR 密码: iwhq PS终极人像修饰教程3章 链接: http://pan.baidu.com/s/1i3grwfb 密码: 6bcm PS字体设计视频8章 链接: http://pan.baidu.com/s/1pJC9no3 密码: srfe 150款photoshop形状 链接: http://pan.baidu.com/s/1mgxgmPa 密码: y8zr 18套漂亮宝宝字体PSD模版 链接: http://pan.baidu.com/s/1jGnaVrw 密码: ar8b 2000个photoshop动作 链接: http://pan.baidu.com/s/1i3ncVZ3 密码: kusm 26款photoshop常用极品滤镜 链接: http://pan.baidu.com/s/1pJOK0UB 密码: 5rqi 47套影楼美工字体PSD模版 链接: http://pan.baidu.com/s/1ntta0kD 密码: ynyx 500个photoshop渐变 链接: http://pan.baidu.com/s/1dDo7dT3 密码: thvm 6套漂亮婚纱字体PSD模版 链接: http://pan.baidu.com/s/1ntBXtbj 密码: v7bd 8套可爱动物字体PSD模版 链接: http://pan.baidu.com/s/1o6xIg6A 密码: grfb 9套可爱英文字体PSD模版 链接: http://pan.baidu.com/s/1pJKaJpD 密码: g5a9 PSD韩国时尚花纹图案 链接: http://pan.baidu.com/s/1mg3lTqS 密码: 7nue PS画笔笔刷2000款 链接: http://pan.baidu.com/s/1i3iZo9J 密码: gmzd PS图层样式100款 链接: http://pan.baidu.com/s/1i3ittjB 密码: dr5v 韩国风尚写真PSD模板 链接: http://pan.baidu.com/s/1o6uuwlk 密码: ahtb 韩国设计素材psd模板 链接: http://pan.baidu.com/s/1o69Twcq 密码: mg8j 婚纱PSD素材37例 链接: http://pan.baidu.com/s/1qWA5pVY 密码: hbbb 经典高贵风格婚纱模板psd素材 链接: http://pan.baidu.com/s/1kTMQHGN 密码: bqvq 平面广告PSD分层素材 链接: http://pan.baidu.com/s/1mgvetZy 密码: art7 人物相册图片后期处理psd模板 链接: http://pan.baidu.com/s/1bnoBeuN 密码: vixq 台湾婚纱模板珍藏psd模板 链接: http://pan.baidu.com/s/1kTlCZOz 密码: hv4a 服装资料: 服装搭配教程 链接: http://pan.baidu.com/s/1qWokBSg 密码: smau 看图学艺图解童装纸样设计 链接: http://pan.baidu.com/s/1dD6NWwL 密码: 3utu 美容化妆: 常用美发男发修剪教程 链接: http://pan.baidu.com/s/1ntCDrMp 密码: 8bn8 儿童发型编发视频教程 链接: http://pan.baidu.com/s/1ntDZhDB 密码: xra8 巧编儿童发辫发型65例 链接: http://pan.baidu.com/s/1qWMG9Ww 密码: 4i33 发型搭配文字教程集合 链接: http://pan.baidu.com/s/1kTqwH99 密码: 453s 韩国专业发型视频教程 链接: http://pan.baidu.com/s/1mgmWQ3u 密码: kgv2 流行美经典盘发视频教程 链接: http://pan.baidu.com/s/1i3ittkx 密码: hchn 日常时尚发型视频教程 链接: http://pan.baidu.com/s/1o6rC4aA 密码: pivh 小P老师主讲发型视频教程 链接: http://pan.baidu.com/s/1hq0Cndy 密码: 76hb 新天地影楼发型技法 链接: http://pan.baidu.com/s/1i3mxa2h 密码: nkwx 百变彩妆视频教程29集 链接: http://pan.baidu.com/s/1pJBnpIb 密码: 5d3g 彩妆常识视频教程46集 链接: http://pan.baidu.com/s/1dDB7GWh 密码: h3fw 韩版妆化妆技巧视频教程 链接: http://pan.baidu.com/s/1i34DRd7 密码: pm2u 韩国化妆方法视频教程 链接: http://pan.baidu.com/s/1eQhJyLk 密码: 3r2d 化妆方法一学就会视频教程 链接: http://pan.baidu.com/s/1hqAL6fy 密码: ja5n 化妆方面文字教程集合 链接: http://pan.baidu.com/s/1sjyXUmp 密码: x9vg 化妆技巧视频教程50集 链接: http://pan.baidu.com/s/1mggRnGs 密码: ia4k 睫毛嫁接视频教程 链接: http://pan.baidu.com/s/1sjwqh8D 密码: r6en 美容化妆400问PDF教程 链接: http://pan.baidu.com/s/1dDjhyJB 密码: wmdc 新增化妆视频教程19集 链接: http://pan.baidu.com/s/1hqxov8S 密码: etf7 学做化妆师技能培训讲座 链接: http://pan.baidu.com/s/1eQ8NMOq 密码: 67mb 自我美容彩妆技巧视频教程 链接: http://pan.baidu.com/s/1ntKeMJf 密码: vytr 3D水晶甲视频教程 链接: http://pan.baidu.com/s/1dDwE8Jf 密码: uqy6 法式水晶甲视频教程 链接: http://pan.baidu.com/s/1kT7rEy7 密码: jrah 花式水晶甲视频教程 链接: http://pan.baidu.com/s/1hqH7nd6 密码: gm5m 镭射法式光疗甲视频教程 链接: http://pan.baidu.com/s/1sGRU2 密码: rhs3 美甲彩绘视频教程 链接: http://pan.baidu.com/s/1eQ1wlG2 密码: ujrs 美甲技巧视频教程 链接: http://pan.baidu.com/s/1eQEn13k 密码: rg2w 民间彩绘视频教程 链接: http://pan.baidu.com/s/1c0AnNSc 密码: qc7k 双色花艺术彩绘视频教程 链接: http://pan.baidu.com/s/1c010p4O 密码: gqba 水晶指甲制作视频教程 链接: http://pan.baidu.com/s/1o6mmQQu 密码: kf72 五指美甲机VCD简视频 链接: http://pan.baidu.com/s/1eQ6fWUQ 密码: dftc 炫彩美甲视频教程 链接: http://pan.baidu.com/s/1dD95Mt7 密码: a7gb 艺术彩绘视频教程 链接: http://pan.baidu.com/s/1c0dJJS8 密码: ukbx 指甲护理视频教程 链接: http://pan.baidu.com/s/1mgj9grI 密码: pcd6 指甲画花视频教程 链接: http://pan.baidu.com/s/1dDlPmI9 密码: n5b7 美术资料: 白衣女子肖像 链接: http://pan.baidu.com/s/1o6BptP4 密码: p41p 北京的静物创作示范 链接: http://pan.baidu.com/s/1eQuACzo 密码: hea3 高考色彩静物 蔬菜视频教程 链接: http://pan.baidu.com/s/1sjsSqAh 密码: 8fqs 宫崎骏 链接: http://pan.baidu.com/s/1i3CL1o5 密码: h6u7 海量名师作品集 链接: http://pan.baidu.com/s/1gdhb3KB 密码: gi8z 花间美人古风CG插画技法 链接: http://pan.baidu.com/s/1ntIITWd 密码: d2c6 绘画色彩基础视频教程 链接: http://pan.baidu.com/s/1jGH3hQY 密码: 83e4 绘画透视应用技法视频教程 链接: http://pan.baidu.com/s/1pJsWyON 密码: 3b6n 暴走漫画表情素材 链接: http://pan.baidu.com/s/1jGGhmx4 密码: 9q75 漫画人物五官手脚画法 链接: http://pan.baidu.com/s/1hqEPwjE 密码: sgp7 美术基础训练视频教程 链接: http://pan.baidu.com/s/1hqo0Xc4 密码: i84h 名画欣赏技法分析视频教程 链接: http://pan.baidu.com/s/1i3peSj7 密码: 3css 人体结构设计资料 链接: http://pan.baidu.com/s/1bn6mfxX 密码: aya4 日式造型巨可爱游戏原画素材 链接: http://pan.baidu.com/s/1sjoiCmL 密码: scpu 沙画学习视频教程 链接: http://pan.baidu.com/s/1pJkiTM7 密码: u5cf 适合新手临摹练习的Q版图集 链接: http://pan.baidu.com/s/1c054gfu 密码: dqru 工装设计手绘效果图 链接: http://pan.baidu.com/s/1pJ41GGN 密码: ytyf 建筑大师手绘表现图 链接: http://pan.baidu.com/s/1c0Er54G 密码: 2cci 建筑基础手绘教程 链接: http://pan.baidu.com/s/1bnHHv59 密码: ans9 景观设计手绘表现图 链接: http://pan.baidu.com/s/1o69TwQu 密码: kkgg 庐山手绘视频教程 链接: http://pan.baidu.com/s/1sjn2GUh 密码: x4vw 汽车手绘表现图 链接: http://pan.baidu.com/s/1qWsUvak 密码: 3ium 人物手绘表现图 链接: http://pan.baidu.com/s/1dDEp6ut 密码: 7ym1 设计手绘表达教程 链接: http://pan.baidu.com/s/1bnrYVCV 密码: 3c5q 室内设计手绘表现图 链接: http://pan.baidu.com/s/1c0ddL8c 密码: e3ip 手绘设计方案36套 链接: http://pan.baidu.com/s/1jG9vCMi 密码: 6ija 外景手绘细节表现图 链接: http://pan.baidu.com/s/1hqgt0xe 密码: 2x4h 色彩静物视频教程 链接: http://pan.baidu.com/s/1c0Gt0nm 密码: 5z25 色彩学习视频教程 链接: http://pan.baidu.com/s/1dD8jS1V 密码: 42tc 水彩静物视频教程 链接: http://pan.baidu.com/s/1gdtSCoz 密码: 5ewy 静物素描视频教程 链接: http://pan.baidu.com/s/1dDvYAsT 密码: gnkt 素描基础训练视频教程 链接: http://pan.baidu.com/s/1jGqyOdS 密码: yhyu 素描几何体视频教程 链接: http://pan.baidu.com/s/1jGIPedC 密码: 8dfk 素描男人体视频教程 链接: http://pan.baidu.com/s/1pJqU3FH 密码: syne 素描男头像视频教程 链接: http://pan.baidu.com/s/1jn1UY 密码: u6dv 素描男肖像视频教程 链接: http://pan.baidu.com/s/1eQm3hRW 密码: egj8 素描女人体视频教程 链接: http://pan.baidu.com/s/1c0rqU44 密码: ga36 素描女肖像视频教程 链接: http://pan.baidu.com/s/1c0yc7za 密码: p74t 素描石膏视频教程 链接: http://pan.baidu.com/s/1dD4Mdup 密码: 5tb2 速写学习视频教程 链接: http://pan.baidu.com/s/1nt7TAC5 密码: 8equ 写意人物画技法视频教程 链接: http://pan.baidu.com/s/1nt23TMT 密码: jhmj 艾轩油画西藏女孩 链接: http://pan.baidu.com/s/1i31WeYp 密码: 3fp3 古典油画肖像技法视频教程 链接: http://pan.baidu.com/s/1hq7xNlq 密码: a9cn 静物油画技法视频教程 链接: http://pan.baidu.com/s/1sjvAhBn 密码: dmsx 油画风景写生视频教程 链接: http://pan.baidu.com/s/1gd2ah5h 密码: iiaq 油画钢琴姑娘视频教程 链接: http://pan.baidu.com/s/1bnpXbyB 密码: 5qeh 油画静物与肖像视频教程 链接: http://pan.baidu.com/s/1o6ijeDO 密码: 3ymu 油画男肖像视频教程 链接: http://pan.baidu.com/s/1ntuwvMT 密码: zddq 油画女人体视频教程 链接: http://pan.baidu.com/s/1kT5VIbP 密码: 237n 油画女肖像视频教程 链接: http://pan.baidu.com/s/1o6DXk4y 密码: 7yvq 油画人物视频教程 链接: http://pan.baidu.com/s/1dDyG269 密码: 3xa9 油画手部描绘视频教程 链接: http://pan.baidu.com/s/1o6pACMA 密码: 9f3s 勒尚谊 链接: http://pan.baidu.com/s/1gdpiU3p 密码: f63x 美术电子书： POP 链接: http://pan.baidu.com/s/1gdfF5o3 密码: sicb 插画 链接: http://pan.baidu.com/s/1c1TF4 密码: 2hxk 动物类画技 链接: http://pan.baidu.com/s/1pJJuNWZ 密码: wjpd 卡通 链接: http://pan.baidu.com/s/1mgmWRlY 密码: 11dg 漫画 链接: http://pan.baidu.com/s/1sjOGyF7 密码: xzi3 其他 链接: http://pan.baidu.com/s/1hqrOGDI 密码: pv6v 铅笔画 链接: http://pan.baidu.com/s/1o6N0BiE 密码: 6fup 手绘 链接: http://pan.baidu.com/s/1o6sY446 密码: 2rve 水彩 链接: http://pan.baidu.com/s/1eQ6LWtk 密码: ekp5 素描 链接: http://pan.baidu.com/s/1kTMQIyV 密码: wc3j 速写 链接: http://pan.baidu.com/s/1jGrKG66 密码: vj34 油画 链接: http://pan.baidu.com/s/1c0FD4Og 密码: sris 其他资料: 打毛衣文字教程资料 链接: http://pan.baidu.com/s/1bnk7w79 密码: hmuk 工作求职简历模板 链接: http://pan.baidu.com/s/1qW9jtBA 密码: 1t8f 广告制作技术资料 链接: http://pan.baidu.com/s/1o6N0BlK 密码: hmx8 蝴蝶结发饰教程 链接: http://pan.baidu.com/s/1c0g19uw 密码: s9m6 皮艺皮具设计制作教程 链接: http://pan.baidu.com/s/1qWMa8Ss 密码: uhdb 生活百科健康养生资料收集（值得收藏）链接: http://pan.baidu.com/s/1mgmqVES 密码: hiyg 绳结技法教程 链接: http://pan.baidu.com/s/1sjBPinr 密码: cqqx 童话故事 链接: http://pan.baidu.com/s/1bnhj9mR 密码: cwpa 棋牌资料: 国际象棋 链接: http://pan.baidu.com/s/1c0FD4Q0 密码: etq9 麻将电子书 链接: http://pan.baidu.com/s/1bn6ScpD 密码: 48m5 麻将视频教学 链接: http://pan.baidu.com/s/1mgxMnFU 密码: wzc1 扑克牌 链接: http://pan.baidu.com/s/1mgy2jhu 密码: yd7z 围棋 链接: http://pan.baidu.com/s/1sjyXUZ7 密码: aptz 中国象棋初中高级教程 链接: http://pan.baidu.com/s/1ntGHeB3 密码: x2vv 中国象棋实战攻防 链接: http://pan.baidu.com/s/1ntoWHGt 密码: pjte 球类资料: 高尔夫初学视频教程 链接: http://pan.baidu.com/s/1jGf9ymy 密码: a3tt Better Basketball篮球教学视频教程 链接: http://pan.baidu.com/s/1o6rC4Oy 密码: tu14 NBA篮球教学视频 链接: http://pan.baidu.com/s/1bnfhIEV 密码: qaa5 NBA十大过人高手百大过人 链接: http://pan.baidu.com/s/1kTte5AB 密码: 248x 加农贝克篮球训练视频教程 链接: http://pan.baidu.com/s/16ohjC 密码: 1jrd 街头篮球视频教程 链接: http://pan.baidu.com/s/1sj0ZPpj 密码: n9u1 科比门徒全集 链接: http://pan.baidu.com/s/1nt9p1Mx 密码: egir 篮球基础与实战技巧视频教程 链接: http://pan.baidu.com/s/1fjJie 密码: cw2q 篮球教学视频教程50集 链接: http://pan.baidu.com/s/1sjvAhC5 密码: a4sf 五虎篮球教学视频教程 链接: http://pan.baidu.com/s/1ntL0MSh 密码: ed4n 约翰逊篮球防守训练视频教程 链接: http://pan.baidu.com/s/1mgHzcFY 密码: djb9 张卫平篮球教学视频教程 链接: http://pan.baidu.com/s/1i36FLtF 密码: 6ag7 乒乓球教学视频教程 链接: http://pan.baidu.com/s/1bndLOuF 密码: xdk7 巴尼台球视频教程 链接: http://pan.baidu.com/s/1qW1HMva 密码: ewft 和尚台球系列专题教学 链接: http://pan.baidu.com/s/1qWkgSfM 密码: fr93 经验一枪台球视频教学 链接: http://pan.baidu.com/s/1pJBTpaz 密码: 2xkj 刘新臣斯诺克教程 链接: http://pan.baidu.com/s/1gdeZ6Wr 密码: nur7 罗建宇入门斯诺克台球教程 链接: http://pan.baidu.com/s/1o6JwPgY 密码: kpcp 斯诺克北京刘军台球教学 链接: http://pan.baidu.com/s/1g5Eiy 密码: ra77 唐建军台球视频教程 链接: http://pan.baidu.com/s/1c0AnOAW 密码: hfr4 张东涛斯诺克基础教程 链接: http://pan.baidu.com/s/1kTzkhF5 密码: q21g 陈伟华羽毛球视频教程 链接: http://pan.baidu.com/s/1o65jG98 密码: v83h 惠程俊羽毛球教学视频 链接: http://pan.baidu.com/s/1pJC9oxX 密码: yktp 李玲蔚羽毛球视频教程 链接: http://pan.baidu.com/s/1mgGJgDi 密码: u4ay 李在福羽毛球视频教程 链接: http://pan.baidu.com/s/1kT7rFnD 密码: 8rke 刘瑞豪羽毛球新手教学 链接: http://pan.baidu.com/s/1dDxu6Vf 密码: pvsa 肖杰学打羽毛球视频教程 链接: http://pan.baidu.com/s/1pJGCXYj 密码: jsyk 肖杰赵剑华羽毛球专家把脉 链接: http://pan.baidu.com/s/1i3J7bPb 密码: p5hq 熊国宝羽毛球技术教学 链接: http://pan.baidu.com/s/1qWE9dU0 密码: dwgc DAY城市运动KE足球教学 链接: http://pan.baidu.com/s/1qWokCJ6 密码: cmmz TBALLER街头足球教学 链接: http://pan.baidu.com/s/1c0m7r0W 密码: kgn6 贝克汉姆20大绝妙助攻 链接: http://pan.baidu.com/s/1ygCzk 密码: qkvq 贝克汉姆30大经典进球 链接: http://pan.baidu.com/s/1o6IaWRK 密码: qsgq 比利温格罗夫教你玩街头足球 链接: http://pan.baidu.com/s/1ntOi8Il 密码: u6tm 顶级实战足球教程STR足训 链接: http://pan.baidu.com/s/1kTmYWp5 密码: ypii 跟我踢足球教程 链接: http://pan.baidu.com/s/1qWBRlCw 密码: dth4 冠军俱乐部足球教学 链接: http://pan.baidu.com/s/1kTnER3p 密码: n64e 科化足球视频教程 链接: http://pan.baidu.com/s/1eQrmOdO 密码: xtgu 像贝克汉姆一样踢球 链接: http://pan.baidu.com/s/1i3ENvsL 密码: wp6t 学踢足球入门教程 链接: http://pan.baidu.com/s/1gd4HYMn 密码: q9wu 英国足球视频教程 链接: http://pan.baidu.com/s/1bnnpoOR 密码: 4hxw 足球50大技巧 链接: http://pan.baidu.com/s/1bn8TUCB 密码: 5dwx 足球训练技巧教程 链接: http://pan.baidu.com/s/1qW2xJp6 密码: bfr8 室内设计: 家居与室内设计风水视频教程 链接: http://pan.baidu.com/s/1pJ5NBHx 密码: fd7k 室内表现行业视频 链接: http://pan.baidu.com/s/1c1TKy 密码: upst 室内设计CAD常用图库 链接: http://pan.baidu.com/s/1dD0cxLf 密码: ez1j 室内设计《7000个装饰材料价格》 链接: http://pan.baidu.com/s/1i3IRg1J 密码: 54xx 室内设计《工艺工法》 链接: http://pan.baidu.com/s/1o6kQWAI 密码: vd7e 室内设计《家装风水大全》风水知识 链接: http://pan.baidu.com/s/1jGBx4ge 密码: nkm8 室内设计《设计师理论参考资料:》理论设计常识 链接: http://pan.baidu.com/s/1nt7TAFv 密码: 23dn 室内设计《施工工艺宝典》 链接: http://pan.baidu.com/s/1ntKeN9n 密码: dten 室内设计《施工工艺视频》 链接: http://pan.baidu.com/s/1mgy2jkk 密码: xre4 室内设计《室内设计常用尺寸表》人体工程学 链接: http://pan.baidu.com/s/1qWNw8pu 密码: hads 室内设计视频教程 链接: http://pan.baidu.com/s/1c0nTjW0 密码: riif 外语资料: 大学德语高教版本mp3格式 链接: http://pan.baidu.com/s/1kTpaKab 密码: 7cnw 基础德语入门教程mp3格式 链接: http://pan.baidu.com/s/1sj5J6YL 密码: yajk 新东方德语入门一月通 链接: http://pan.baidu.com/s/1pJGCXZH 密码: mcvn 俄语小故事175集MP3格式 链接: http://pan.baidu.com/s/1bnCXGkf 密码: nis4 实用商务俄语口语王全集MP3格式 链接: http://pan.baidu.com/s/1gd6dTC3 密码: enen 法语零基础入门音标语音 链接: http://pan.baidu.com/s/1gdIVj1L 密码: ivtg 法语入门走遍法国第一册上通关班 链接: http://pan.baidu.com/s/1jG5XPuY 密码: 5xje 新东方法语入门一月通 链接: http://pan.baidu.com/s/1bnm9odT 密码: j27n 走遍法国语音教程MP3格式 链接: http://pan.baidu.com/s/1bndfORH 密码: 5jfq 阿里郎电视台韩语视频教学 链接: http://pan.baidu.com/s/1i3nITM1 密码: 941a 标准韩语基础会话 链接: http://pan.baidu.com/s/1hqxowvE 密码: mfs8 标准韩语语音入门 链接: http://pan.baidu.com/s/1o6KcOzS 密码: cmai 崔羲秀初级韩国语 链接: http://pan.baidu.com/s/1c0cxOLq 密码: 4uiu 韩国高手会“踢的革命”教学片 链接: http://pan.baidu.com/s/1hqpgXTU 密码: h6df 韩国会话3月通 链接: http://pan.baidu.com/s/1qW616Pm 密码: zsc6 韩国外国语大学《韩国语教程》 链接: http://pan.baidu.com/s/1mgmWRrE 密码: 2u4y 韩国语课堂旅游基础会话 链接: http://pan.baidu.com/s/1mgtI0Jm 密码: mdpf 韩语口语8000字mp3格式 链接: http://pan.baidu.com/s/1bnApR5P 密码: xwu4 韩语口语900句mp3音频 链接: http://pan.baidu.com/s/1c010qru 密码: cdsu 韩语自学视频教程 链接: http://pan.baidu.com/s/1hqAL6TI 密码: ic27 老版Let’sSpeakKorean视频教学 链接: http://pan.baidu.com/s/1pJ63AUR 密码: pqnk 临时急需要马上说韩语 链接: http://pan.baidu.com/s/1sjJWInF 密码: 8q5p 零起点韩语口语入门 链接: http://pan.baidu.com/s/1pJ9RvHx 密码: gbhk 零起点韩语口语入门王视频 链接: http://pan.baidu.com/s/1gd5xVhD 密码: h7p8 民族出版社韩国语MP3格式 链接: http://pan.baidu.com/s/1i3Gjn9N 密码: w7i7 实用初级韩国语教程 链接: http://pan.baidu.com/s/1mg9r5lY 密码: dx2z 实用韩国语教程 链接: http://pan.baidu.com/s/1mgtI0JI 密码: fi3r 实用韩语单词500个 链接: http://pan.baidu.com/s/1qW9jtDU 密码: 4eyk 我为韩语狂入门篇 链接: http://pan.baidu.com/s/1qWn4Hmk 密码: ty7w 无师自通韩国语视频教程 链接: http://pan.baidu.com/s/1i3H5hhN 密码: 6mhy 新版Let’sSpeakKorean 260集视频 链接: http://pan.baidu.com/s/1mgAD3eC 密码: rd7r 新编中级韩国语MP3格式 链接: http://pan.baidu.com/s/1dD0cxNj 密码: ysxp 新东方韩语入门一月通 链接: http://pan.baidu.com/s/1c06kchE 密码: ng25 新概念韩国语视频 链接: http://pan.baidu.com/s/1kTpaKbd 密码: kpbh 中韩交流标准韩国语 链接: http://pan.baidu.com/s/1qW5fBTq 密码: sxqi 中韩交流实用韩国语 链接: http://pan.baidu.com/s/1pJusrNH 密码: ft8u Erin挑战！学会日语视频25讲 链接: http://pan.baidu.com/s/1ntIcYnf 密码: m9bn Go Go Japan第一季8集 链接: http://pan.baidu.com/s/1bnCXGAV 密码: h6p8 北海道漫游记 链接: http://pan.baidu.com/s/1bnrsWl5 密码: 1xa5 标准日本语 链接: http://pan.baidu.com/s/1ntABznz 密码: bsgv 标准日语初级教程 链接: http://pan.baidu.com/s/1bn4kmfl 密码: ckji 别笑！我是日语学习书MP3格式 链接: http://pan.baidu.com/s/1pJOK2uB 密码: 4h5p 超简单-手绘旅游日语MP3格式 链接: http://pan.baidu.com/s/1ntoqMTF 密码: sjrg 从日本中小学课本学日文 链接: http://pan.baidu.com/s/1jG2AaA6 密码: v1db 大家的日本语(1-2册)MP3格式 链接: http://pan.baidu.com/s/1qWoQC8k 密码: 3g8k 大学日语专业四级轻松过级一点通mp3格式 链接: http://pan.baidu.com/s/1kTDxt3L 密码: mppu 蛋蛋动漫日语学堂70讲 链接: http://pan.baidu.com/s/1gd2aibx 密码: jxn9 东京印象 链接: http://pan.baidu.com/s/1o6rC5rc 密码: k98i 读唐诗学日语汉字MP3格式 链接: http://pan.baidu.com/s/1mg3lUNQ 密码: 4a2r 短期掌握日本语能力测试N1级 链接: http://pan.baidu.com/s/1sjFSWwt 密码: b74a 疯狂日语MP3版7讲 链接: http://pan.baidu.com/s/1sjA3rAl 密码: sqvk 跟NHK学简明日语 链接: http://pan.baidu.com/s/1qW9Pw3y 密码: gt9k 沪江日语 链接: http://pan.baidu.com/s/1pJ0xUTP 密码: 9xi3 环游日本学日语 链接: http://pan.baidu.com/s/1fPIZc 密码: fete 叫醒耳朵日语会话通3000句日常日语句型 链接: http://pan.baidu.com/s/1pJiNaqf 密码: 71yd 口语及短句888个4讲MP3格式 链接: http://pan.baidu.com/s/18pZXG 密码: div3 来去日本第二季17集 链接: http://pan.baidu.com/s/1sjn2H1V 密码: 23ve 赖户内海心动之旅5集 链接: http://pan.baidu.com/s/1qWzFUI4 密码: 9feh 老外最想与你聊的100日语话题 链接: http://pan.baidu.com/s/1bfYUU 密码: xu45 日本九州北部之旅5集 链接: http://pan.baidu.com/s/1kTnERVD 密码: 817r 日本语能力测试1234级词汇背诵手册MP3版 链接: http://pan.baidu.com/s/1gdCP8zD 密码: w42w 日英双解辞典 链接: http://pan.baidu.com/s/1ntwyoZJ 密码: 7jnd 日语300句 链接: http://pan.baidu.com/s/1pJ3LK3T 密码: 7vgd 日语初级1-24集MP3格式 链接: http://pan.baidu.com/s/1mgBtz2g 密码: 8x7r 日语基础中央广播电视大学教学视频40集 链接: http://pan.baidu.com/s/1c054gBQ 密码: egjr 日语口译综合能力（二级）mp3格式 链接: http://pan.baidu.com/s/1sjsSriH 密码: uj4r 日语口语900句音频教程 链接: http://pan.baidu.com/s/1jGxQqfs 密码: q83c 日语口语王想说就说mp3格式 链接: http://pan.baidu.com/s/1eQ2cjse 密码: gyk1 日语能力考试2级听力模拟训练DOC文本MP3格式 链接: http://pan.baidu.com/s/1sjt8qC1密码: ce8h 日语能力考试二级听力模拟训练MP3格式 链接: http://pan.baidu.com/s/1hqhFz1a 密码: gbxm 日语一月通全套教程合集 链接: http://pan.baidu.com/s/1ntl8WpN 密码: 6v1u 商务日语教程 链接: http://pan.baidu.com/s/1i3pKT4D 密码: mn42 上外新编日语答疑解难视频 链接: http://pan.baidu.com/s/1o6zJZN8 密码: n3v4 生活日语半日通 链接: http://pan.baidu.com/s/1c0tsMFA 密码: 8ukk 实用初级日语视频教程32讲 链接: http://pan.baidu.com/s/1fPIZO 密码: ev2w 实用日语口语句典MP3格式 链接: http://pan.baidu.com/s/1sj2vHST 密码: 6bmh 哇!原来这句日语这样说! 链接: http://pan.baidu.com/s/1o67l6no 密码: zmpq 无师自通日本语口语MP3格式 链接: http://pan.baidu.com/s/1ntCDtd3 密码: 5sya 现在就说日语 链接: http://pan.baidu.com/s/1c0lRrfq 密码: tc69 新版标准日本语 链接: http://pan.baidu.com/s/1sj0ZPMX 密码: fmgr 新编日语1-4册MP3格式全套 链接: http://pan.baidu.com/s/1kT3nVIB 密码: eurw 新编日语教程1-5册MP3格式 链接: http://pan.baidu.com/s/1qWOI1Uc 密码: gxs5 新编日语修订本mp3格式4册 链接: http://pan.baidu.com/s/1kTzQh3x 密码: 861q 新编生活日语视频25讲 链接: http://pan.baidu.com/s/1qWFUUq4 密码: 7ipe 新东方日语讲义 链接: http://pan.baidu.com/s/1mgy2jA4 密码: jfjc 新东方日语入门一月通 链接: http://pan.baidu.com/s/1gdvo8bL 密码: 2v9w 新东方日语一级讲座视频教程 链接: http://pan.baidu.com/s/1qWBlnC4 密码: mrtv 新概念日语视频教学15集 链接: http://pan.baidu.com/s/1g5ECe 密码: hn7j 新日本语能力测试N3词汇背诵手册mp3版 链接: http://pan.baidu.com/s/1o6A9vPS 密码: xw5p 学日语高手系列-流行口语及短句888个 链接: http://pan.baidu.com/s/1c0Er5WO 密码: 6xkt 樱花日语多媒体课程12级别 链接: http://pan.baidu.com/s/1o6qq9cu 密码: 2hfg 原来日语这样说MP3格式71讲 链接: http://pan.baidu.com/s/1dDItprb 密码: epxa 张向荣日语教程 链接: http://pan.baidu.com/s/1kTlDbbL 密码: ann5 中日交流标准日本语 链接: http://pan.baidu.com/s/1mgsw65U 密码: 6dav 走遍日本教程 链接: http://pan.baidu.com/s/1o60zW9s 密码: axh3 大学泰语听力教程 链接: http://pan.baidu.com/s/1eQ2cjvk 密码: 43v7 基础泰语MP3格式 链接: http://pan.baidu.com/s/1eQ8NOiu 密码: yhdx 实用初级泰国语视频教学 链接: http://pan.baidu.com/s/1o6zee3g 密码: n33g 泰语入门基础课程文字教程 链接: http://pan.baidu.com/s/1o6j4Znc 密码: kfam 新东方西班牙语入门一月通 链接: http://pan.baidu.com/s/1hqyAvuW 密码: j7kb 新东方新概念英语1-4册 链接: http://pan.baidu.com/s/1o6MKDPC 密码: 3ay4 新概念英语1-4册视频教程 链接: http://pan.baidu.com/s/1jGAH7JC 密码: wrsu 新概念英语精品课堂mp3格式 链接: http://pan.baidu.com/s/1bnbJUe7 密码: 3ara 365天英语口语大全 链接: http://pan.baidu.com/s/1dhTF4 密码: eu3w 9小时快学国际音标 链接: http://pan.baidu.com/s/1gdEl1BX 密码: ba37 海伦从零开始英语音标 链接: http://pan.baidu.com/s/1ntkTbb7 密码: x12k 新东方4+1课堂教程 链接: http://pan.baidu.com/s/1mgxgosg 密码: 69tq 新东方王强口语全集 链接: http://pan.baidu.com/s/1sjC5hmt 密码: au3a 英语口音纠正课程 链接: http://pan.baidu.com/s/1ucP3o 密码: ygcn 英语口语8000句 链接: http://pan.baidu.com/s/1kTCHsI7 密码: 9qqr 英语口语900句系列 链接: http://pan.baidu.com/s/1qWMa9u0 密码: 2t3t 网店资料: (176套)宝贝描述模板 链接: http://pan.baidu.com/s/1jGxktzo 密码: dgk6 (2442款)促销水印模板 链接: http://pan.baidu.com/s/1dDtWHQp 密码: 6uxh (2864款)店铺装修漂亮素材 链接: http://pan.baidu.com/s/1jGowPym 密码: 2tfr (45套)宝贝团购模板 链接: http://pan.baidu.com/s/1dDrUQjB 密码: wgb6 2000多款网店轮播海报 链接: http://pan.baidu.com/s/1qWmiNqk 密码: 5nij 200多款服装宝贝描述模板 链接: http://pan.baidu.com/s/1jGowPwE 密码: zi3w 200多款首页装修PSD模板 链接: http://pan.baidu.com/s/1eQvW6CM 密码: s63a 600多款宝贝描述模板 链接: http://pan.baidu.com/s/1jGBx4Bc 密码: 9dsn 700多款直通车广告图 链接: http://pan.baidu.com/s/1kTIhd9H 密码: eaaz 淘宝教程 链接: http://pan.baidu.com/s/1ntknbVN 密码: 7t7p 维修资料: 摩托车维修技术 链接: http://pan.baidu.com/s/1FH8vG 密码: driv 奥迪A6电喷系统的原理与检测 链接: http://pan.baidu.com/s/1ntmoRTR 密码: 5cbx 电喷系统结构原理及故障诊断 链接: http://pan.baidu.com/s/1kT7rFIv 密码: mmp5 都市先锋-捷达王-捷达轿车电喷系统检修 链接: http://pan.baidu.com/s/1sjNu6z7 密码: x9ft 富康轿车电喷系统检测与维修 链接: http://pan.baidu.com/s/1qWDTfZ2 密码: yg1v 捷达电喷系统检测与维修 链接: http://pan.baidu.com/s/1c0llsmW 密码: rsk6 桑塔纳2000GSI电喷系统检测与维修 链接: http://pan.baidu.com/s/1jGgVsNW 密码: pfr1 雅阁电喷系统检测与维修 链接: http://pan.baidu.com/s/1bnDDATD 密码: trhq 电控发动机波形分析视频教程 链接: http://pan.baidu.com/s/1jG6DKCA 密码: 7c8x 魏俊强电控发动机故障诊断高级讲解 链接: http://pan.baidu.com/s/1qWp68pA 密码: sy4b 朱军电控发动机波形分析 链接: http://pan.baidu.com/s/1qFbmI 密码: zpq6 朱军电控发动机原理与诊断 链接: http://pan.baidu.com/s/1sjLYArN 密码: 1peg 东风牌D6114型柴油机使用技巧 链接: http://pan.baidu.com/s/1gdfF5QV 密码: nsub 丰田普锐斯原厂技术培训视频(英文) 链接: http://pan.baidu.com/s/1c02MnW8 密码: vekr 跟我学汽车养护 链接: http://pan.baidu.com/s/1dDAlLxZ 密码: 5g67 金奔腾汽车电脑解码器使用方法 链接: http://pan.baidu.com/s/1bn99TYR 密码: gjif 汽车必需设施的安装 链接: http://pan.baidu.com/s/1dDvsB9f 密码: a8ej 汽车电器与电子控制技术 链接: http://pan.baidu.com/s/1hqivuMo 密码: 68ji 汽车电子技术与检测仪器的应用 链接: http://pan.baidu.com/s/1bnoBfFh 密码: 5haq 汽车各部件工作原理视频 链接: http://pan.baidu.com/s/1qW3JIt2 密码: jkwf 汽车故障高级诊断技术 链接: http://pan.baidu.com/s/1eQjLvns 密码: e4tr 汽车故障诊断基本思路 链接: http://pan.baidu.com/s/1c0sCR0c 密码: v6g4 汽车驾驶学习技巧 链接: http://pan.baidu.com/s/1i3grxHV 密码: hmda 汽车喷漆涂装技术 链接: http://pan.baidu.com/s/1qWxEbMk 密码: 6tnd 汽车音响防盗 气囊修复 仪表芯片解密 链接: http://pan.baidu.com/s/1sjyXV8h 密码: 7gej 汽车在途中常见故障应急修理 链接: http://pan.baidu.com/s/1gdjJqp1 密码: rbsc 汽车专业英语视频教程 链接: http://pan.baidu.com/s/1gdjJqpH 密码: mt6e 数据流分析方法视频教程 链接: http://pan.baidu.com/s/1kTEJqUr 密码: zjkq 现代汽车电控系统诊断新理念 链接: http://pan.baidu.com/s/1mgFxmbA 密码: mnkr 蓄电池修理技术视频教程 链接: http://pan.baidu.com/s/1mg04cFQ 密码: 2yn3 玉林YC4110ZQ柴油机装配工艺 链接: http://pan.baidu.com/s/1sjG8P21 密码: 7pct 朱军自动变速器原理与诊断 链接: http://pan.baidu.com/s/1i3grxIH 密码: x95p 自动变速器结构原理与检修 链接: http://pan.baidu.com/s/1ygCV0 密码: 37k4 跟我学汽车美容 链接: http://pan.baidu.com/s/1jGMmNUu 密码: 5efm 汽车美容视频教程 链接: http://pan.baidu.com/s/1dDo7fBN 密码: pjuh 汽车美容与装饰 链接: http://pan.baidu.com/s/1dD1yorn 密码: meg7 汽车内外饰物的安装 链接: http://pan.baidu.com/s/1qWyZY3M 密码: zdeu 本田汽车维修视频 链接: http://pan.baidu.com/s/1dDEp6Xr 密码: 7n9i 大众汽车维修视频 链接: http://pan.baidu.com/s/1hqvm7Ta 密码: 2vz2 大众自动变速器构造原理与维修 链接: http://pan.baidu.com/s/1gdlflBl 密码: hu7c 国产轿车维修跟我学 链接: http://pan.baidu.com/s/1qWxEbMG 密码: faf1 机修技师中高级视频教程 链接: http://pan.baidu.com/s/1eQfHAlO 密码: vg7w 轿车维修文字教程 链接: http://pan.baidu.com/s/1ntwypg1 密码: ehuc 捷达车系维修技术 链接: http://pan.baidu.com/s/1nt3jRjb 密码: 983y 汽车车身修复教程 链接: http://pan.baidu.com/s/1c032kvu 密码: yfnb 汽车电脑工作原理与检修 链接: http://pan.baidu.com/s/1c0cxPrM 密码: 94dt 汽车机修教学视频教程 链接: http://pan.baidu.com/s/1mgosNk0 密码: m3ge 汽车维修高级工培训视频教程 链接: http://pan.baidu.com/s/1pJwujcn 密码: wbj1 汽车维修工中高级视频教程 链接: http://pan.baidu.com/s/1c0pUY0C 密码: un2m 汽车维修技师技能训练教程 链接: http://pan.baidu.com/s/1ntpCDZV 密码: jqyd 汽车维修技术视频教程 链接: http://pan.baidu.com/s/1c00ewNY 密码: tmd4 汽车维修职业技能培训教材 链接: http://pan.baidu.com/s/1pJ1dRMr 密码: 88vs 汽车维修自学通视频教程 链接: http://pan.baidu.com/s/1eQB5FvO 密码: cc2b 汽修电工视频教程 链接: http://pan.baidu.com/s/1pJNy9cv 密码: s1ry 汽修手册文字资料 链接: http://pan.baidu.com/s/1pJmQMBT 密码: 24nq 汽修专家讲汽修视频教程 链接: http://pan.baidu.com/s/1jGELtTc 密码: rqe1 通用五菱汽车维修视频 链接: http://pan.baidu.com/s/1mgMOHks 密码: fxgj 现代伊兰特维修视频 链接: http://pan.baidu.com/s/1gd4HZt5 密码: 82ry 新编电动自行车维修速成 链接: http://pan.baidu.com/s/1o6tEwS6 密码: u354 玉林YC6105柴油机的装拆与维修 链接: http://pan.baidu.com/s/1sjHUOMh 密码: 8wrc 自动变速箱维修视频教程 链接: http://pan.baidu.com/s/1kTKiXrp 密码: tem3 液晶电视维修教程 链接: http://pan.baidu.com/s/1i37vKxv 密码: nms4 电动车维修视频教程 链接: http://pan.baidu.com/s/1mgxMox6 密码: i648 本文永久地址：http://blog.itrover.cf/?p=215 转载请注明出处","tags":[{"name":"资源分享","slug":"资源分享","permalink":"http://blog.buerya.cn/tags/资源分享/"}]},{"title":"一个孤独的人","date":"2017-06-25T13:37:57.000Z","path":"2017/06/25/diary06-25/","text":"new APlayer({ element: document.getElementById(\"aplayer0\"), narrow: false, autoplay: false, showlrc: 0, music: { title: \"她的睫毛\", author: \"周杰伦\", url: \"http://home.ustc.edu.cn/~mmmwhy/%d6%dc%bd%dc%c2%d7%20-%20%cb%fd%b5%c4%bd%de%c3%ab.mp3\", pic: \"http://home.ustc.edu.cn/~mmmwhy/jay.jpg\", } }); 你好，听说你很神奇，我现在一个人，不知道要干什么，该干什么。 很孤独，很难过。 我想去到一个没有人认识的地方。 我不想跟别人聊天，就真的没有人跟我聊天。 很多事，我就想一个失败者。 我现在每天活的好像一个行尸走肉，没有目的。 自己都不知道自己在干什么。 我想要抓住什么稻草，客户说没有什么可以让我抓。 我更难过 真的是失败，失败者。 好希望有人能来解救我。","tags":[{"name":"日记","slug":"日记","permalink":"http://blog.buerya.cn/tags/日记/"}]},{"title":"Markdown 11种基本语法","date":"2017-06-24T15:31:00.000Z","path":"2017/06/24/markdown/","text":"现在是我在学习MARKDOWN时做的笔记。学完这些MARKDOWN的基本使用已经不成问题。标题设置（让字体变大，和word的标题意思一样）在Markdown当中设置标题，有两种方式：第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大） 块注释（blockquote）通过在文字开头添加“&gt;”表示块注释。（当&gt;和文字之间添加五个blank时，块注释的文字会有变化。） 斜体将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来 粗体将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来 无序列表在文字开头添加(, +, and -)实现无序列表。但是要注意在(, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式） 有序列表使用数字后面跟上句号。（还要有空格） 链接（Links）Markdown中有两种方式，实现链接，分别为内联方式和引用方式。内联方式：This is an [example link](http://example.com/).引用方式：I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3].[1]: http://google.com/ “Google”[2]: http://search.yahoo.com/ “Yahoo Search”[3]: http://search.msn.com/ “MSN Search” 图片（Images）图片的处理方式和链接的处理方式，非常的类似。内联方式：![alt text] (/path/to/img.jpg “Title”)引用方式：![alt text] [id][id]: /path/to/img.jpg “Title” 代码（HTML中所谓的Code） 实现方式有两种：第一种：简单文字出现一个代码框。使用&lt;blockquote&gt;。（不是单引号而是左上角的ESC下面~，数字1左边的按键）第二种：大片文字需要实现代码框。使用Tab和四个空格。 脚注（footnote）实现方式如下：hello[^hello][^hello]: hi 下划线在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题） References：以上内容根据官方文档基本文档进行整理。http://daringfireball.net/projects/markdown/basicsMarkdown官方网站：http://daringfireball.net/projects/markdown/ 推荐一款在线的Markdown编辑器：https://stackedit.io/","tags":[{"name":"Markdown语法","slug":"Markdown语法","permalink":"http://blog.buerya.cn/tags/Markdown语法/"},{"name":"技术知识","slug":"技术知识","permalink":"http://blog.buerya.cn/tags/技术知识/"}]}]